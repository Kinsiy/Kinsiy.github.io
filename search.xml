<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图论 - 环</title>
    <url>/Graph-Cycles/</url>
    <content><![CDATA[<blockquote>
<p>一个回路是一条非空的路径，其中第一个顶点和最后一个顶点相同。令图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo separator="true">,</mo><mi mathvariant="normal">∅</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V,E,\empty)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∅</span><span class="mclose">)</span></span></span></span>，一个回路是一条非空路径<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>e</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>e</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(e_1,e_2,...,e_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其顶点序列为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_1,v_2,...,v_n,v_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>一个环路或简单回路是只有第一个与最后一个顶点相同的回路</p>
<p>回路和环的长度是它们经过的边的个数</p>
<p>——Wikipedia. 环(图论)</p>
</blockquote>
<span id="more"></span>
<h2 id="环探测">环探测</h2>
<p>使用深度优先遍历的方法，通过寻找一条连接当前顶点与之前顶点的边(它包含了一条后向边)，我们可以探测有向图和无向图上环的存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">isCyclic</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 是否遍历过</span></span><br><span class="line">    <span class="keyword">const</span> recStack = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 是否在递归栈中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">      visited.<span class="title function_">set</span>(key, <span class="literal">false</span>);</span><br><span class="line">      recStack.<span class="title function_">set</span>(key, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isCyclicUtil</span>(key, visited, recStack)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">isCyclicUtil</span>(<span class="params">key, visited, recStack</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (recStack.<span class="title function_">get</span>(key)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (visited.<span class="title function_">get</span>(key)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    visited.<span class="title function_">set</span>(key, <span class="literal">true</span>);</span><br><span class="line">    recStack.<span class="title function_">set</span>(key, <span class="literal">true</span>); <span class="comment">// 入栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> adjcent <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(key).<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isCyclicUtil</span>(adjcent.<span class="property">value</span>, visited, recStack)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    recStack.<span class="title function_">set</span>(key, <span class="literal">false</span>); <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;undirected graph&quot;</span>); <span class="comment">// 无向图</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">DIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;directed graph&quot;</span>); <span class="comment">// 有向图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="title class_">Graph</span>.<span class="property">DIRECTED</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">g.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">isCyclic</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="寻找简单环-有向图">寻找简单环(有向图)</h2>
<p>算法基于强连通图，能够找出图中所有的简单环，强连通图可以用<a href="https://kinsiy.github.io/Graph-Tarjan/">图论 - Tarjan算法</a>得到。</p>
<div class="note primary"><p>英文论文(科学上网)<a href="https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF">Finding all the elementary circuits of a directed graph.</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">simple_cycles</span>(<span class="params">G</span>) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 解锁顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; thisnode 要解锁的顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Set</span>&#125; blocked 已锁顶点集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Map</span>&#125; blockedMap 连锁顶点对照</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">_unblock</span>(<span class="params">thisnode, blocked, B</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [thisnode];</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (blocked.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">        blocked.<span class="title function_">delete</span>(node);</span><br><span class="line">        <span class="keyword">if</span> (B.<span class="title function_">has</span>(node)) &#123;</span><br><span class="line">          stack.<span class="title function_">push</span>(...B.<span class="title function_">get</span>(node));</span><br><span class="line">          B.<span class="title function_">delete</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// G = _.cloneDeep(G) 为了不影响原图，可以复制一份</span></span><br><span class="line">  <span class="keyword">const</span> sccs = G.<span class="title function_">SCC</span>();</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (sccs.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> scc = sccs.<span class="title function_">pop</span>(); <span class="comment">// 强连通分量(数组 [顶点值, 顶点值...])</span></span><br><span class="line">    <span class="keyword">if</span> (scc.<span class="property">length</span> &lt; <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 只有一个顶点的强连通分量无环</span></span><br><span class="line">    <span class="keyword">const</span> H = G.<span class="title function_">subGraph</span>(scc); <span class="comment">// 强连通分量(图)        Graph.subGraph 见附录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> startNode = scc.<span class="title function_">pop</span>(); <span class="comment">// 遍历起点</span></span><br><span class="line">    <span class="keyword">const</span> path = [startNode]; <span class="comment">// 深度遍历路径</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> blocked = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 已封锁顶点</span></span><br><span class="line">    <span class="keyword">const</span> closed = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 环内顶点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    blocked.<span class="title function_">add</span>(startNode);</span><br><span class="line">    <span class="keyword">const</span> B = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 连锁顶点对照</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">SNAdj</span> = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> vertex <span class="keyword">of</span> H.<span class="property">nodes</span>.<span class="title function_">get</span>(startNode).<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">      <span class="title class_">SNAdj</span>.<span class="title function_">push</span>(vertex.<span class="property">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stack = [[startNode, <span class="title class_">SNAdj</span>]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> [thisnode, nbrs] = stack[stack.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nbrs.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 邻接顶点(未遍历过的)不为空</span></span><br><span class="line">        <span class="keyword">const</span> nextNode = nbrs.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextNode === startNode) &#123;</span><br><span class="line">          <span class="comment">// 找到环</span></span><br><span class="line">          result.<span class="title function_">push</span>([...path]);</span><br><span class="line">          path.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> closed.<span class="title function_">add</span>(e));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!blocked.<span class="title function_">has</span>(nextNode)) &#123;</span><br><span class="line">          <span class="comment">// 邻接顶点未被封锁</span></span><br><span class="line">          path.<span class="title function_">push</span>(nextNode);</span><br><span class="line">          <span class="keyword">const</span> <span class="title class_">NNAdj</span> = [];</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> vertex <span class="keyword">of</span> H.<span class="property">nodes</span>.<span class="title function_">get</span>(nextNode).<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">            <span class="title class_">NNAdj</span>.<span class="title function_">push</span>(vertex.<span class="property">value</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          stack.<span class="title function_">push</span>([nextNode, <span class="title class_">NNAdj</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          closed.<span class="title function_">delete</span>(nextNode);</span><br><span class="line">          blocked.<span class="title function_">add</span>(nextNode);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 邻接顶点为空(顶点的所有邻接顶点均遍历过了)</span></span><br><span class="line">        <span class="keyword">if</span> (closed.<span class="title function_">has</span>(thisnode)) &#123;</span><br><span class="line">          <span class="title function_">_unblock</span>(thisnode, blocked, B); <span class="comment">// 解锁顶点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">const</span> adjacent <span class="keyword">of</span> H.<span class="property">nodes</span>.<span class="title function_">get</span>(thisnode).<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">            <span class="keyword">const</span> blockedChain = B.<span class="title function_">get</span>(adjacent) ?? <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            B.<span class="title function_">set</span>(adjacent, blockedChain); <span class="comment">// 连锁</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stack.<span class="title function_">pop</span>();</span><br><span class="line">        path.<span class="title function_">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G.<span class="title function_">removeVertex</span>(startNode);</span><br><span class="line">    H.<span class="title function_">removeVertex</span>(startNode);</span><br><span class="line">    sccs.<span class="title function_">push</span>(...H.<span class="title function_">SCC</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g4 = <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="title class_">Graph</span>.<span class="property">DIRECTED</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">9</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">simple_cycles</span>(g4); <span class="comment">//[[0, 3, 2], [0, 1, 2], [6, 4], [6, 4, 5], [9, 8]]</span></span><br></pre></td></tr></table></figure>
<h2 id="附录">附录</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">subGraph</span>(<span class="params">vertexKeyList</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> subG = <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> vertexKeyList) &#123;</span><br><span class="line">      <span class="keyword">let</span> vertex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(key);</span><br><span class="line">      subG.<span class="title function_">addVertex</span>(key);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> adjacent <span class="keyword">of</span> vertex.<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vertexKeyList.<span class="title function_">includes</span>(adjacent.<span class="property">value</span>)) &#123;</span><br><span class="line">          subG.<span class="title function_">addEdge</span>(key, adjacent.<span class="property">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subG;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.geeksforgeeks.org/detect-cycle-in-a-graph/?ref=gcse">GeeksforGeeks. Detect Cycle in a Directed Graph.</a></p>
<p>[2]<a href="https://networkx.org/documentation/networkx-1.10/_modules/networkx/algorithms/cycles.html#simple_cycles">NetworkX. Source code for networkx.algorithms.cycles</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>环</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 栅格布局 - Ⅰ</title>
    <url>/CSS-Grid-1/</url>
    <content><![CDATA[<p>很早之前就看过如何应用栅格布局,但平常都是flex布局用的多.导致grid布局都忘了.最近重新复习了一遍.这里记录下</p>
<h2 id="基本术语">基本术语</h2>
<ul>
<li><strong>栅格容器</strong>:  是确立栅格格式化上下文的框体,即定义一个栅格区域,其中的元素根据栅格布局(而非块级布局)规则排布</li>
<li><strong>栅格元素</strong>:  是在栅格格式化上下文中参与栅格布局的东西</li>
<li><strong>栅格轨道</strong>: 指两条相邻的栅格线之间夹住的整个区域,从栅格容器的一边延伸到对边,即栅格列或栅格行</li>
<li><strong>栅格单元</strong>: 指四条栅格线限定的区域,内部没有其他栅格线贯穿</li>
<li><strong>栅格区域</strong>:  指任何四条栅格线限定的矩形区域,有一个或多个栅格单元构成</li>
</ul>
<span id="more"></span>
<h2 id="放置栅格线">放置栅格线</h2>
<p>使用<mark class="label primary">grid-template-rows</mark>, <mark class="label primary">grid-template-columns</mark>大致定义栅格模板中的栅格线</p>
<h3 id="宽度固定的栅格轨道">宽度固定的栅格轨道</h3>
<p>“<strong>宽度固定</strong>”的栅格线指栅格线之间的距离不随栅格轨道中的内容变化而变化</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">50%</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为栅格线命名</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [start col-a] <span class="number">200px</span> [col-b] <span class="number">50%</span> [col-c] <span class="number">100px</span> [stop end last];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为轨道尺寸设定极值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [start col-a] <span class="number">200px</span> [col-b] <span class="number">50%</span> [col-c] <span class="number">100px</span> [stop end last];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [start masthead] <span class="number">3em</span> [content] <span class="built_in">minmax</span>(<span class="number">3em</span>, <span class="number">100%</span>) [footer] <span class="number">2em</span> [stop end]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: 如果minmax()中指定的最大值比最小值小,最大值将被忽略,最小值将用于设定宽度固定的轨道长度</p>
<p>也可以使用<mark class="label primary">calc()</mark>计算</p>
<h3 id="弹性栅格轨道">弹性栅格轨道</h3>
<p>弹性栅格轨道的尺寸基于弹性容器中非弹性轨道意外的空间确定,或者基于整个轨道中的具体内容而定</p>
<p>使用<mark class="label primary">fr</mark>单位把余下的空间分成一定份数, 以分配给各栏</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">15em</span> <span class="number">1</span>fr <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意: <mark class="label primary">minmax()</mark>表达式的最小值部分不允许使用<mark class="label primary">fr</mark>单位</p>
<p>使用<mark class="label primary">min-content</mark>, <mark class="label primary">max-context</mark>根据内容设定轨道尺寸</p>
<ul>
<li>max-content. 占据内容所需的最大空间. “宽度尽量大,以防换行”</li>
<li>min-content. 占据内容所需的最小空间.  “尽量少占据空间,够显示内容即可”, 对文本来说,只保证最长的单词能够在一行里完整显示,会导致大量断行</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: max-content max-content max-content max-content;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: max-content max-content max-content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动适配">自动适配</h3>
<p>除<mark class="label primary">min-content</mark>和<mark class="label primary">max-content</mark>外,还可以使用<mark class="label primary">fix-content()</mark>函数以简练的方式表达特定类型的尺寸模型</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>-colums: <span class="number">1</span>fr <span class="built_in">fit-content</span>(<span class="number">150px</span>) <span class="number">2</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<mark class="label primary">fit-content</mark>的伪公式
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fit-<span class="title function_">content</span>(arg) =&gt; <span class="title function_">min</span>(max-content, <span class="title function_">max</span>(min-content, arg))</span><br></pre></td></tr></table></figure>
<p>可以这么理解: <mark class="label primary">fit-content(arg)</mark> 等价于 <code>minmax(min-content, max-content)</code>, 除非参数指定的值设置了更大的上限</p>
<h3 id="重复栅格线">重复栅格线</h3>
<p>可以使用<mark class="label primary">repeat()</mark>重复声明同一尺寸的轨道</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>-columus: <span class="built_in">repeat</span>(<span class="number">10</span>, <span class="number">5em</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述规则创建了10个列轨道,每个轨道的宽度为5em, 共计50em.</p>
<p>在repeat中, 轨道的尺寸可以使用任何值,可以是<mark class="label primary">min-content</mark>和<mark class="label primary">max-content</mark>,也可以是<mark class="label primary">fr</mark>值和<mark class="label primary">auto</mark>等,而且不限于只提供一个值. 但是不能在重复中嵌套重复</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>-columus: <span class="built_in">repeat</span>(<span class="number">4</span>, <span class="number">10px</span> [col-start] <span class="number">250px</span> <span class="number">1</span>fr [col-end] <span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以使用<mark class="label primary">auto-fill</mark>,对轨道尺寸进行简单重复,直到填满整个栅格容器为止.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>-columus: <span class="built_in">repeat</span>(auto-fill, [top] <span class="number">5em</span> [bottom])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每隔5em放置一条行栅格线,直到没有空间为止.</p>
<mark class="label primary">auto-fill</mark>的局限是只能有一个可选的栅格线名称,一个尺寸固定的轨道和另一个栅格线名称.上面`[top] 5em [bottom]`就是这种模式下值最多的情况. 且在一个轨道模板中只能有一个自动重复的模式. 
<p>但是, 可以和固定数量的重复结合</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template</span>-columus: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">20em</span>) <span class="built_in">repeat</span>(auto-fill, <span class="number">100px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<mark class="label primary">auto-fill</mark>的行为类似的声明还有一个<mark class="label primary">auto-fit</mark>, 其与<mark class="label primary">auto-fill</mark>的区别是, <strong>没有栅格元素的轨道将被剔除</strong></p>
<h2 id="栅格区域">栅格区域</h2>
<p>使用<mark class="label primary">grid-template-areas</mark>可以栅格画出来</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">&quot;h h h h&quot;</span></span><br><span class="line">    <span class="string">&quot;l c c r&quot;</span></span><br><span class="line">    <span class="string">&quot;l f f f&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<mark class="label primary">grid-template-areas</mark>中每个字符串(放在一对双引号中)定义栅格中的一行. 相同的字符串值用于定义栅格区域的形状.</p>
<p>注意: 栅格区域必须是矩形, 如果区域形状太复杂,整个模板都将失效</p>
<p>对不想命名的区域可以使用一个或多个<mark class="label primary">.</mark>字符占位</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">&quot;header header header header&quot;</span></span><br><span class="line">    <span class="string">&quot;left ... ... right&quot;</span></span><br><span class="line">    <span class="string">&quot;footer footer footer footer&quot;</span>;</span><br><span class="line">  <span class="attribute">grid-template</span>-colums: <span class="number">1</span>fr <span class="number">20em</span> <span class="number">20em</span> <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">40px</span> <span class="number">10em</span> <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义好栅格区域之后, 接下来要使用前面介绍的 <mark class="label primary">grid-template-columns</mark> 和 <mark class="label primary">grid-template-rows</mark> 定义栅格轨道的尺寸.</p>
<p>对于命名区域, 会自动为构成栅格区域的栅格线进行命名, 对矩形的左/上两条栅格线命名为 <mark class="label primary">$1</mark>, 右/下则为<mark class="label primary">$1</mark>. 对与上方的规则来说, 自动为第一条列栅格线命名<mark class="label primary">header-start</mark>, 最后一条列栅格线命名<mark class="label primary">header-end</mark>, 行栅格线同理.</p>
<p>除显式声明栅格区域, 也可以通过为栅格线命名<mark class="label primary">$1</mark>, <mark class="label primary">$1</mark>的形式隐式声明栅格区域 <strong>(不建议)</strong></p>
<h2 id="附加元素">附加元素</h2>
<h3 id="使用列线和行线">使用列线和行线</h3>
<p>可以通过使用<mark class="label primary">grid-row-start</mark>, <mark class="label primary">grid-row-end</mark>, <mark class="label primary">grid-column-start</mark>, <mark class="label primary">grid-column-end</mark>.四个属性把栅格元素附加到栅格中.</p>
<p>这几个属性的意思是, “我想把元素的边界附加到某条栅格线上”</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50em</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, <span class="number">5em</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">10</span>, <span class="number">5em</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果省略结束栅格线,那么结束栅格线使用序列中的下一条栅格线.</p>
<p>还可以使用 <mark class="label primary">span n</mark> 相对于 开始/结束 栅格线横跨 <mark class="label primary">n</mark> 条栅格线, <mark class="label primary">n</mark> 为正整数, 默认值 1. 还可以在 <mark class="label primary">n</mark> 前/后指定命名栅格线, 以横跨<mark class="label primary">n</mark>条特定栅格线,  若未指定栅格线名字,则为任意栅格线</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50em</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, [R] <span class="number">5em</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">5</span>, [col-A] <span class="number">5em</span> [col-B] <span class="number">5em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: R <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: <span class="number">5</span>;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: col-B;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row-start</span>: R;</span><br><span class="line">  <span class="attribute">grid-row-end</span>: span R <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: col-A <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: span <span class="number">2</span> col-A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="行和列的简写属性">行和列的简写属性</h3>
<p>使用<mark class="label primary">grid-row</mark>, <mark class="label primary">grid-column</mark>简化把元素附加到栅格线上的过程.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  dispaly: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">10</span>, [R] <span class="number">1.5em</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2em</span> <span class="built_in">repeat</span>(<span class="number">5</span>, [col-A] <span class="number">5em</span> [col-B] <span class="number">5em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: R <span class="number">3</span> / <span class="number">7</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: col-B / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: R / span R <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: col-A <span class="number">3</span> / span <span class="number">2</span> col-A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果值中间没有斜线,那么定义的是开始栅格线,结束栅格线取决于开始栅格线的值.如果开始栅格线是用名称引用的,那么结束栅格线也使用那个名称引用.</p>
<h3 id="隐式栅格">隐式栅格</h3>
<p>当栅格元素(或其一部分)超出了显式定义的栅格, 浏览器或隐式的创建栅格线以满足定义.</p>
<p>注意: 跨度是从显式栅格开始计数的. (注意看box4/5)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">2em</span> <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">6</span>, <span class="number">4em</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box01</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box02</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box03</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: span <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box04</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">4</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: span <span class="number">2</span> / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box05</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">5</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: span <span class="number">4</span> / <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box06</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">6</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: -<span class="number">1</span> / span <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box07</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">7</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: span <span class="number">3</span> / -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220716173940540.png" alt="image-20220716173940540"></p>
<h3 id="错误处理">错误处理</h3>
<ol>
<li>开始线在结束线之后 =&gt; 对调两个值</li>
<li>开始线与结束线都声明为跨度 =&gt; 丢弃结束线的值, 替换为 auto</li>
<li>只使用具名跨度指明栅格元素的位置 =&gt; <mark class="label primary">span name</mark>将被替换为<mark class="label primary">span 1</mark></li>
</ol>
<h3 id="使用区域">使用区域</h3>
<p>可以直接使用<mark class="label primary">grid-area</mark>一个属性引用栅格区域</p>
<p>定义了具名栅格区域</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">&quot;header header header header&quot;</span></span><br><span class="line">    <span class="string">&quot;leftside content content rightside&quot;</span></span><br><span class="line">    <span class="string">&quot;leftside footer footer footer&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box01</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box02</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: leftside;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box03</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box04</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: rightside;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box05</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220716180651012.png" alt="image-20220716180651012"></p>
<p>未定义栅格区域, 可以分别指定围成栅格区域的四条栅格线引用该栅格区域. 其顺序为row-start, column-start, row-end, column-end.</p>
<p>若存在省缺值, 且未省缺值为具名栅格线,那么省缺值与未省缺值一致.否则省缺值为auto</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1-start] <span class="number">1</span>fr [r1-end r2-start] <span class="number">2</span>fr [r2-end];</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [col-start] <span class="number">1</span>fr [col-end main-start] <span class="number">1</span>fr [main-end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box01</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: r1 / main / r1 / main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box02</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: r2-start / col-start / r2-end / main-end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box03</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">2</span> / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220716182339313.png" alt="image-20220716182339313"></p>
<h3 id="重叠栅格元素">重叠栅格元素</h3>
<p>附加栅格元素时,完全可以重叠每个元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1-start] <span class="number">1</span>fr [r1-end r2-start] <span class="number">2</span>fr [r2-end];</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [col-start] <span class="number">1</span>fr [col-end main-start] <span class="number">1</span>fr [main-end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box01</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: r1 / col / r1 / main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box02</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: r1-start / main-start / r2-end / main-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220716182911866.png" alt="image-20220716182911866"></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/33398314/">Eric A. Meyer / Estelle Weyl. CSS权威指南（第四版）</a></p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS - 栅格布局 - Ⅱ</title>
    <url>/CSS-Grid-2/</url>
    <content><![CDATA[<p>承接上篇<a href="https://kinsiy.github.io/CSS-Grid-1/">CSS - 栅格布局 - Ⅰ</a> , 上篇说了如何定义栅格轨道及如何将栅格元素附加到栅格轨道/区域上.这篇主要说下栅格流/栏距/栅格的对齐方式等</p>
<h2 id="栅格流">栅格流</h2>
<p>前面附加元素时基本上都明确指定了栅格元素在栅格中的位置,对与未明确指定的栅格元素,其位置将按照栅格流自动放入栅格中.</p>
<p>栅格流主要分为两种模式,即行优先和列优先,不过二者都可以通过密集流增强.栅格流通过<mark class="label primary">grid-auto-flow</mark>设置</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;grid&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.grid</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: grid;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">45em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">8em</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">grid-auto-flow</span>: row;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717203504024.png" alt="image-20220717203504024"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid-auto-flow</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717203632833.png" alt="image-20220717203632833"></p>
<p>对栅格元素的尺寸,如果没有显示设定,元素的尺寸将自动调整,以便附加到所定义的栅格线上.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">7.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717204038058.png" alt="image-20220717204038058"></p>
<p>对比为栅格元素设定尺寸前后两张图,不难发现每个栅格的起始位置是一致的,但结束位置不一致.这表面,栅格流其实放置的是栅格区域,然后再把栅格元素附加到栅格区域中.</p>
<p>自动附加的栅格元素不会考虑其他其他栅格元素的存在,观察下面的图,可以发现,有些图被覆盖了.</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717210745862.png" alt="image-20220717210745862"></p>
<p>可以通过为占据多个轨道的栅格元素添加适合的类名,指定其跨度,得到不重叠的布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wide</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column</span>: auto / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tall</span> &#123;</span><br><span class="line">  <span class="attribute">grid-row</span>: auto / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717212225412.png" alt="image-20220717212225412"></p>
<p>注意上图, 05 右边存在空白, 这是因为我们设定的栅格流设定的是<mark class="label primary">row</mark>. 行流在每一行从左向右排,如果有足够的空间放下一个栅格元素,那就把该栅格元素方在哪儿,如果放不下或栅格单元被其他栅格元素占据了,就挑个那个栅格单元.</p>
<p>05 右边的栅格单元明显放不下06, 所以跳过了 06 导致了空白.</p>
<p>如果想让栅格元素尽量靠紧,而不管顺序会受到什么影响. 在<mark class="label primary">grid-auto-flow</mark>的值里加上关键字<mark class="label primary">dense</mark>即可</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid-auto-flow</span>: row dense;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220717212949221.png" alt="image-20220717212949221"></p>
<h2 id="自动增加栅格线">自动增加栅格线</h2>
<p>当栅格元素超出了栅格边界时,默认情况下会根据布局要求增加所需的行或列.因此,如果在行主导的栅格末尾有一个跨三行的栅格元素,将在显式栅格后增加三行.</p>
<p>默认情况下,自动增加的行是所需的最小尺寸.可以使用<mark class="label primary">grid-auto-rows</mark>和<mark class="label primary">grid-auto-columns</mark>控制自动增加的轨道尺寸</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220718211818826.png" alt="image-20220718211818826"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid-auto-columns</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220718212044968.png" alt="image-20220718212044968"></p>
<h2 id="grid简写属性">grid简写属性</h2>
<p>grid属性的作用是以简洁的句法定义栅格模板.<strong>未定义的值都重置为默认值</strong></p>
<p>下面两个声明是等效的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid</span>: </span><br><span class="line">    <span class="string">&quot;h h h h&quot;</span> <span class="number">3em</span></span><br><span class="line">    <span class="string">&quot;. c c .&quot;</span> <span class="number">4em</span></span><br><span class="line">    <span class="string">&quot;f f f f&quot;</span> <span class="number">5em</span> /</span><br><span class="line">    <span class="number">2em</span> <span class="number">3em</span> <span class="built_in">minmax</span>(<span class="number">10em</span>, <span class="number">20em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>:</span><br><span class="line">    <span class="string">&quot;h h h h&quot;</span></span><br><span class="line">    <span class="string">&quot;. c c .&quot;</span></span><br><span class="line">    <span class="string">&quot;f f f f&quot;</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">3em</span> <span class="number">4em</span> <span class="number">5em</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">2em</span> <span class="number">3em</span> <span class="built_in">minmax</span>(<span class="number">10em</span>, <span class="number">20em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用grid声明时,<mark class="label primary">grid-template-rows</mark>的值被拆开了,分配与每行栅格区域声明后.</p>
<p>当不声明栅格区域时,可以简写为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  gird: <span class="number">3em</span> <span class="number">4em</span> <span class="number">5em</span> / <span class="number">2em</span> <span class="number">3em</span> <span class="built_in">minmax</span>(<span class="number">10em</span>, <span class="number">20em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>融合命名栅格线</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid</span>: </span><br><span class="line">    <span class="string">&quot;h h h h&quot;</span> <span class="number">3em</span></span><br><span class="line">    [main-start] <span class="string">&quot;. c c .&quot;</span> <span class="number">4em</span> [main-end]</span><br><span class="line">    <span class="string">&quot;f f f f&quot;</span> <span class="number">5em</span> [page-end] /</span><br><span class="line">    <span class="number">2em</span> <span class="number">3em</span> <span class="built_in">minmax</span>(<span class="number">10em</span>, <span class="number">20em</span>) <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><mark class="label primary">grid</mark>属性会将所有未设置的值设定为默认值, 所以一定要把<mark class="label primary">grid</mark>属性设定在其他与栅格有关的其他属性之前</p>
</div>
<h3 id="子栅格">子栅格</h3>
<mark class="label primary">grid</mark>属性还可以取一个值: <mark class="label primary">subgrid</mark>
<p>此时,每个栅格元素的子元素将根据父栅格对齐. <strong>略</strong></p>
<h2 id="释放栅格空间">释放栅格空间</h2>
<h3 id="栏距">栏距</h3>
<p>栏距是两个栅格轨道之间的间隔.使用<mark class="label primary">row-gap</mark>, <mark class="label primary">column-gap</mark>设定</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">50px</span>) / <span class="built_in">repeat</span>(<span class="number">4</span>, <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">row-gap</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用简写属性 */</span></span><br><span class="line"><span class="selector-class">.grid</span> &#123;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">2em</span> / <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220718220605124.png" alt="image-20220718220605124"></p>
<h3 id="margin">margin</h3>
<p>在栅格区域中,盒模型中的外边距属性<mark class="label primary">margin</mark>与普通布局稍有不同,设置<mark class="label primary">margin</mark>时<strong>元素在外边距的边界处附加到栅格中</strong></p>
<p>这意味着, 正外边距使元素向栅格内部收缩, 负外边距, 元素向栅格外部扩张, 也不会出现外边距坍缩的现象</p>
<div class="note primary"><p>计算栅格轨道的尺寸时将忽略栅格元素的外边距.这意味着,不管栅格元素的外边距有多大,都不会改变<mark class="label primary">min-content</mark>列的尺寸,增加栅格元素的外边距也不会改变使用<mark class="label primary">fr</mark>单位设定尺寸的栅格轨道的尺寸</p>
</div>
<div class="note warning"><p>对于绝对定位, 书<sup>[1]</sup>中指出开始栅格线和结束栅格线围成的栅格区域用作容纳块和定位上下文,栅格元素就在这个上下文中定位.</p>
<p>但截至<mark class="label primary">2022/07/19</mark>,在<mark class="label primary">Chrome v103.0.5060.114</mark>没有测试成功</p>
</div>
<h2 id="栅格对齐">栅格对齐</h2>
<table>
<thead>
<tr>
<th>属性</th>
<th>对齐的目标</th>
<th>适用于</th>
</tr>
</thead>
<tbody>
<tr>
<td>justify-self</td>
<td>行内方向(横向)上的一个栅格元素</td>
<td>栅格元素</td>
</tr>
<tr>
<td>justify-items</td>
<td>行内方向(横向)上的全部栅格元素</td>
<td>栅格容器</td>
</tr>
<tr>
<td>justify-content</td>
<td>行内方向(横向)上的整个栅格</td>
<td>栅格容器</td>
</tr>
<tr>
<td>align-self</td>
<td>块级方向(纵向)上的一个栅格元素</td>
<td>栅格元素</td>
</tr>
<tr>
<td>align-items</td>
<td>块级方向(纵向)上的全部栅格元素</td>
<td>栅格容器</td>
</tr>
<tr>
<td>align-content</td>
<td>块级方向(纵向)上的整个栅格</td>
<td>栅格容器</td>
</tr>
</tbody>
</table>
<h3 id="对齐单个栅格元素">对齐单个栅格元素</h3>
<mark class="label primary">justify-self</mark>各个值的取值情况, <mark class="label primary">align-self</mark>除方向不一致外,这8个取值效果完全一样
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220719220231406.png" alt="image-20220719220231406"></p>
<p>另外纵向对齐还可以使用<mark class="label primary">baseline</mark>,<mark class="label primary">last-baseline</mark>.这两个值把栅格元素中的第一条或最后一条基线与栅格轨道中最高或最低的基线对齐.</p>
<mark class="label primary">flex-start</mark>与<mark class="label primary">flex-end</mark>之应该在弹性盒布局中使用,在其他布局中等同与<mark class="label primary">start</mark>与<mark class="label primary">end</mark>
<h3 id="对齐全部栅格元素">对齐全部栅格元素</h3>
<mark class="label primary">justify-items</mark>与<mark class="label primary">align-items</mark>取值与<mark class="label primary">justify-self</mark>/<mark class="label primary">align-self</mark>完全一致,只不过应用与栅格容器中,对所有栅格元素起作用.
<mark class="label primary">justify-content</mark>/<mark class="label primary">align-content</mark>的作用与<mark class="label primary">flex</mark>布局中的作用类似, 用于分配剩余空间.
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220719222614834.png" alt="image-20220719222614834"></p>
<p>分配多出的空间其实就是调整栅格栏距的尺寸.如果没有声明栏距,那么分配的空间将成为栏距.如果声明了栏距,其尺寸将根据分配的情况调整</p>
<div class="note warning"><p><mark class="label primary">stretch</mark>把余下的空间均匀的分配给各个栅格轨道,而不分配给栏距.</p>
<p>截至<mark class="label primary">2022/07/19</mark>,在<mark class="label primary">Chrome v103.0.5060.114</mark>没有测试成功</p>
</div>
<h2 id="分层和排序">分层和排序</h2>
<p>对于重叠的栅格元素,默认按照在文档源码中的顺序叠放.可以使用<mark class="label primary">z-index</mark>或者<mark class="label primary">order</mark>进行调整, <mark class="label primary">z-index</mark>无需多说, 与其他布局的行为一样.</p>
<p>也可以调整<mark class="label primary">order</mark>的值改变栅格元素的顺序,以改变叠放顺序,但是<strong>不推荐</strong>使用.</p>
<p>仅当与视觉顺序无需与阅读和导航顺序一致时才可以使用<mark class="label primary">order</mark>属性; 否则应该调整元素在文档源码中的顺序</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/33398314/">Eric A. Meyer / Estelle Weyl. CSS权威指南（第四版）</a></p>
]]></content>
  </entry>
  <entry>
    <title>图论 - 最短路径(Dijkstra)</title>
    <url>/Graph-Dijkstra/</url>
    <content><![CDATA[<p>最短路径,是指两顶点之间经过的边上权值之和最少的路径</p>
<blockquote>
<p>戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91">最短路径树</a></p>
<p>该算法解决了图  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>上带权的单源最短路径问题。</p>
<p>具体来说，戴克斯特拉算法设置了一顶点集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>，在集合<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中所有的顶点与源点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>之间的最终最短路径权值均已确定。算法反复选择最短路径估计最小的点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>V</mi><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">u \in V - S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>并将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>加入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>中。</p>
<p>——Wikipedia. 戴克斯特拉算法</p>
</blockquote>
<span id="more"></span>
<h2 id="代码实现">代码实现</h2>
<p>Dijkstra算法要求使用 <a href="/Graph-store-1">图论 - 存储结构 - Ⅰ </a> 中介绍的邻接矩阵存储图数据。</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Dijkstra_Animation.gif" alt=""></p>
<div style="font-style: italic;text-align: center;">由Ibmua - Work by uploader.，公有领域</div>
<div class="note warning"><p>基于 <a href="/Graph-store-1">图论 - 存储结构 - Ⅰ </a> 的简单实现, 仅用于学习算法思想.</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Dijkstra 算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Graph</span>&#125; graph 邻接矩阵存储的图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; start 起始顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Map&lt;Node, Node&gt;</span>&#125; path 最短路径链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Map&lt;Node, number&gt;</span>&#125; minWeight 最短路径对应的权</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dijkstra</span>(<span class="params">graph, start, path, minWeight</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; nodes, matrix &#125; = graph;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> final = <span class="keyword">new</span> <span class="title class_">Map</span>();	<span class="comment">// 表示是否找到最短路径 Map&lt;Node, 0 | 1&gt;</span></span><br><span class="line">  <span class="keyword">let</span> k = nodes.<span class="title function_">indexOf</span>(start);</span><br><span class="line">  <span class="keyword">if</span> (k === -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> weight = matrix[k][i] === <span class="title class_">Graph</span>.<span class="property">UNBOUND</span> ? <span class="title class_">Infinity</span> : matrix[k][i];</span><br><span class="line">    final.<span class="title function_">set</span>(nodes[i], <span class="number">0</span>);</span><br><span class="line">    minWeight.<span class="title function_">set</span>(nodes[i], weight);</span><br><span class="line">    path.<span class="title function_">set</span>(nodes[i], start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minWeight.<span class="title function_">set</span>(start, <span class="number">0</span>);</span><br><span class="line">  final.<span class="title function_">set</span>(start, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nodes.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (final.<span class="title function_">get</span>(nodes[j]) || minWeight.<span class="title function_">get</span>(nodes[j]) &gt;= min) <span class="keyword">continue</span>;</span><br><span class="line">      k = j;</span><br><span class="line">      min = minWeight.<span class="title function_">get</span>(nodes[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final.<span class="title function_">set</span>(nodes[k], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nodes.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> weight = matrix[k][j] === <span class="title class_">Graph</span>.<span class="property">UNBOUND</span> ? <span class="title class_">Infinity</span> : matrix[k][j];</span><br><span class="line">      <span class="keyword">if</span> (final.<span class="title function_">get</span>(nodes[j]) || min + weight &gt;= minWeight.<span class="title function_">get</span>(nodes[j])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      minWeight.<span class="title function_">set</span>(nodes[j], min + matrix[k][j]);</span><br><span class="line">      path.<span class="title function_">set</span>(nodes[j], nodes[k]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证">验证</h3>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20221127114233075.png" alt="image-20221127114233075"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = graph.<span class="title function_">addVertex</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> minWeight = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">dijkstra</span>(graph, start, path, minWeight);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> end = graph.<span class="title function_">addVertex</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// v0 - v8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;minWeight: &quot;</span>, minWeight.<span class="title function_">get</span>(end));	<span class="comment">// minWeight:  16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shortestPath = <span class="string">&quot;shortestPath: &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> prev = end;</span><br><span class="line"><span class="keyword">while</span> (prev !== start) &#123;</span><br><span class="line">  shortestPath += prev.<span class="property">value</span> + <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">  prev = path.<span class="title function_">get</span>(prev);</span><br><span class="line">&#125;</span><br><span class="line">shortestPath += start.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(shortestPath);	<span class="comment">// shortestPath: 8 -&gt; 7 -&gt; 6 -&gt; 3 -&gt; 4 -&gt; 2 -&gt; 1 -&gt; 0</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95">Wikipedia. 戴克斯特拉算法.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Dijkstra算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - 最小生成树</title>
    <url>/Graph-MST/</url>
    <content><![CDATA[<blockquote>
<p><strong>最小生成树</strong>是一副<a href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E9%80%9A%E5%9B%BE">连通</a><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">加权无向图</a>中一棵权值最小的<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E6%A0%91">生成树</a>。</p>
<p>在一给定的无向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G = (V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>代表连接顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span>与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的边(即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(u,v)\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>)，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>代表此边的权重，若存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>的子集(即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>⊂</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">T \subset E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>)且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V,T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>为树，使得</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mpadded lspace="-0.5width" width="0px"><mrow><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>T</mi></mrow></mpadded></munder><mi>w</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(T) = \sum_{\mathclap{(u,v)\in T}} w(u,v)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.5660100000000003em;vertical-align:-1.516005em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.808995em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord vbox mtight"><span class="thinbox mtight"><span class="clap mtight"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner mtight"><span><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">u</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="fix"></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.516005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></span></p>
<p>的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">w(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>最小，则此<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的最小生成树</p>
<p>最小生成树其实是最小权重生成树的简称</p>
<p>——Wikipedia. 最小生成树</p>
</blockquote>
<span id="more"></span>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/UntitledDiagram92.png" alt=""></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/UntitledDiagram93.png" alt=""></p>
<h2 id="普里姆-Prim-算法">普里姆(Prim)算法</h2>
<p><strong>普里姆算法</strong>（Prim’s algorithm），可在<strong>加权连通图</strong>里搜索最小生成树。</p>
<div class="note warning"><p>简单实现，核心思想很简单，从任一顶点出发，每次选择所有顶点指向未选中顶点的最小权邻接边, 直至所有顶点军被选中即可. 图定义见附录</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优先队列节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vertex, key</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vertex</span> = vertex; <span class="comment">// 顶点下标</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key; <span class="comment">// 权</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">primsMst</span>(<span class="params">Graph</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nodes = [...<span class="title class_">Graph</span>.<span class="property">nodes</span>.<span class="title function_">values</span>()]; <span class="comment">// 图所有节点的数组形式</span></span><br><span class="line">  <span class="keyword">const</span> mstVertex = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="title class_">Graph</span>.<span class="property">nodes</span>.<span class="property">size</span>).<span class="title function_">fill</span>(<span class="literal">false</span>); <span class="comment">// 标志已经遍历过的顶点</span></span><br><span class="line">  <span class="keyword">const</span> queueNodes = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">    &#123; <span class="attr">length</span>: <span class="title class_">Graph</span>.<span class="property">nodes</span>.<span class="property">size</span> &#125;,</span><br><span class="line">    <span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">QueueNode</span>(i, <span class="title class_">Infinity</span>)</span><br><span class="line">  ); <span class="comment">// 优先队列节点数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parent = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="title class_">Graph</span>.<span class="property">nodes</span>.<span class="property">size</span>).<span class="title function_">fill</span>(-<span class="number">1</span>); <span class="comment">// 以下标标识边，parent[n] → n</span></span><br><span class="line"></span><br><span class="line">  mstVertex[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">// 初始化，从下标为 0 的顶点开始生成</span></span><br><span class="line">  queueNodes[<span class="number">0</span>].<span class="property">key</span> = <span class="number">0</span>; <span class="comment">// 初始化，队首节点key(weight)最小</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [...queueNodes]; <span class="comment">// 优先队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当优先队列不为空</span></span><br><span class="line">  <span class="keyword">while</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> curQueueNode = queue.<span class="title function_">shift</span>(); <span class="comment">// 出队key(weight)最小的节点</span></span><br><span class="line"></span><br><span class="line">    mstVertex[curQueueNode.<span class="property">vertex</span>] = <span class="literal">true</span>; <span class="comment">// 此顶点选中为最小生成树顶点(标志遍历)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历此顶点的邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [adjacent, weight] <span class="keyword">of</span> nodes[curQueueNode.<span class="property">vertex</span>].<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">      <span class="keyword">const</span> curIndex = nodes.<span class="title function_">indexOf</span>(adjacent); <span class="comment">// 获取邻接顶点在顶点数组中的下标</span></span><br><span class="line">      <span class="keyword">if</span> (mstVertex[curIndex]) <span class="keyword">continue</span>; <span class="comment">// 邻接顶点在选中最小生成树顶点中(已遍历过)</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (queueNodes[curIndex].<span class="property">key</span> &lt;= weight) <span class="keyword">continue</span>;</span><br><span class="line">      queueNodes[curIndex].<span class="property">key</span> = weight; <span class="comment">// 更新优先队列节点key(weight)</span></span><br><span class="line">      parent[curIndex] = curQueueNode.<span class="property">vertex</span>; <span class="comment">// 记录邻接顶点权值最小的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">key</span> - b.<span class="property">key</span>); <span class="comment">// 排序优先队列，保证在队首的是已选出的连通子图里的顶点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; parent.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(nodes[parent[i]].<span class="property">value</span> + <span class="string">&quot; - &quot;</span> + nodes[i].<span class="property">value</span> + <span class="string">&quot; - &quot;</span> + queueNodes[i].<span class="property">key</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>);</span><br><span class="line"></span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>);</span><br><span class="line">graph.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">primsMst</span>(graph);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 - 1 - 4</span></span><br><span class="line"><span class="comment">// 0 - 7 - 8</span></span><br><span class="line"><span class="comment">// 5 - 2 - 4</span></span><br><span class="line"><span class="comment">// 2 - 8 - 2</span></span><br><span class="line"><span class="comment">// 7 - 6 - 1</span></span><br><span class="line"><span class="comment">// 6 - 5 - 2</span></span><br><span class="line"><span class="comment">// 2 - 3 - 7</span></span><br><span class="line"><span class="comment">// 3 - 4 - 9</span></span><br></pre></td></tr></table></figure>
<h2 id="克鲁斯克尔-Kruskal-算法">克鲁斯克尔(Kruskal)算法</h2>
<p>克鲁斯克尔算法要求使用 <a href="https://kinsiy.github.io/Graph-store-2/">图论 - 存储结构 - Ⅱ</a> 中介绍的边集数组存储图数据。</p>
<ol>
<li>新建图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中拥有原图中相同的节点，但没有边</li>
<li>将原图中所有的边按权值从小到大排序</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中不在同一个连通分量中，则添加这条边到图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中</li>
<li>重复3，直至<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中所有的节点都在同一个连通分量中</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">KruskalMST</span>(<span class="params">vertexs, edges</span>) &#123;</span><br><span class="line">  edges.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> parent = <span class="title class_">Array</span>(vertexs.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> src, dest;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; edges.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    src = <span class="title function_">find</span>(parent, edges[i][<span class="number">0</span>]);</span><br><span class="line">    dest = <span class="title function_">find</span>(parent, edges[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (src != dest) &#123;</span><br><span class="line">      parent[src] = dest;</span><br><span class="line">      result.<span class="title function_">push</span>(edges[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">find</span>(<span class="params">parent, index</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      index = parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vertexs = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">const</span> edges = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">7</span>, <span class="number">11</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">5</span>, <span class="number">14</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">]; <span class="comment">// [[src,dest,weight]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">KruskalMST</span>(vertexs, edges)); <span class="comment">//[[7, 6, 1], [2, 8, 2], [6, 5, 2], [0, 1, 4], [2, 5, 4], [2, 3, 7], [0, 7, 8], [3, 4, 9]]</span></span><br></pre></td></tr></table></figure>
<h2 id="附录">附录</h2>
<p>普里姆(Prim)算法中用到的图结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 邻接链表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 新增邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; node 邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; weight 权</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addAdjacent</span>(<span class="params">node, weight = <span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">set</span>(node, weight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 移除邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeAdjacent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">delete</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 节点是否与node邻接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isAdjacent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">has</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 获取所有邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Array</span>&#125; 邻接节点数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">getAdjacents</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">entries</span>()];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 获取某邻接节点边权重</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Number</span>&#125; 边权重</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">getAdjacentWeight</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">get</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 图初始化</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Symbol</span>&#125; edgeDirection Graph.DIRECTED 或 Graph.UNDIRECTED</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">edgeDirection = Graph.DIRECTED</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">edgeDirection</span> = edgeDirection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 向图中增加顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125; 新顶点或已存在顶点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> vertex = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">set</span>(value, vertex);</span><br><span class="line">      <span class="keyword">return</span> vertex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除值为value的顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 移除是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        node.<span class="title function_">removeAdjacent</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">delete</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 在图中创建边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">source, destination, weight</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(destination);</span><br><span class="line"></span><br><span class="line">    sourceNode.<span class="title function_">addAdjacent</span>(destinationNode, weight);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">      destinationNode.<span class="title function_">addAdjacent</span>(sourceNode, weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode, weight];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(destination);</span><br><span class="line">    <span class="keyword">let</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceNode &amp;&amp; destinationNode) &#123;</span><br><span class="line">      weight = sourceNode.<span class="title function_">getAdjacentWeight</span>(destinationNode);</span><br><span class="line">      sourceNode.<span class="title function_">removeAdjacent</span>(destinationNode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">        destinationNode.<span class="title function_">removeAdjacent</span>(sourceNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode, weight];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 判断两节点是否邻接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 邻接与否</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isAdjacent</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceNode &amp;&amp; destinationNode) &#123;</span><br><span class="line">      <span class="keyword">return</span> sourceNode.<span class="title function_">isAdjacent</span>(destinationNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;undirected graph&quot;</span>); <span class="comment">// 无向图</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">DIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;directed graph&quot;</span>); <span class="comment">// 有向图</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">Wikipedia. 最小生成树.</a></p>
<p>[3]<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95">Wikipedia. 克鲁斯克尔算法</a></p>
<p>[4]<a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/">geeksforgeeks.org. Prim’s MST for Adjacency List Representation | Greedy Algo-6</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Prim算法</tag>
        <tag>Kruskal算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - Tarjan算法</title>
    <url>/Graph-Tarjan/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<p>Tarjan算法是一个在图中查找强连通分量的算法</p>
<p><img data-src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/kosaraju.jpg" alt=""></p>
<div class="note info"><p>在有向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中，如果对于每一对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo>≠</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_i,v_j \in V, v_i \not = v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都存在路径，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>是强连通图。有向图中的极大连通子图称作有向图的强连通分量</p>
</div>
<span id="more"></span>
<h2 id="代码实现">代码实现</h2>
<p>图数据结构使用<a href="https://kinsiy.github.io/Graph-store-1/">图论 - 存储结构 - Ⅰ </a>中的邻接表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">SCC</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="keyword">const</span> lowLink = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">      index.<span class="title function_">set</span>(key, -<span class="number">1</span>);</span><br><span class="line">      lowLink.<span class="title function_">set</span>(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (index.<span class="title function_">get</span>(key) === -<span class="number">1</span>) &#123;</span><br><span class="line">        time = <span class="variable language_">this</span>.<span class="title class_">SCCUtil</span>(key, index, lowLink, stack, time, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title class_">SCCUtil</span>(key, index, lowLink, stack, time, result) &#123;</span><br><span class="line">    index.<span class="title function_">set</span>(key, time);</span><br><span class="line">    lowLink.<span class="title function_">set</span>(key, time);</span><br><span class="line">    time++;</span><br><span class="line">    stack.<span class="title function_">push</span>(key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> adjcent <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(key).<span class="title function_">getAdjacents</span>()) &#123;</span><br><span class="line">      <span class="keyword">let</span> adjcentKey = adjcent.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (index.<span class="title function_">get</span>(adjcentKey) === -<span class="number">1</span>) &#123;</span><br><span class="line">        time = <span class="variable language_">this</span>.<span class="title class_">SCCUtil</span>(adjcentKey, index, lowLink, stack, time, result);</span><br><span class="line">        lowLink.<span class="title function_">set</span>(key, <span class="title class_">Math</span>.<span class="title function_">min</span>(lowLink.<span class="title function_">get</span>(key), lowLink.<span class="title function_">get</span>(adjcentKey)));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stack.<span class="title function_">includes</span>(adjcentKey)) &#123;</span><br><span class="line">        lowLink.<span class="title function_">set</span>(key, <span class="title class_">Math</span>.<span class="title function_">min</span>(lowLink.<span class="title function_">get</span>(key), index.<span class="title function_">get</span>(adjcentKey)));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> w = <span class="title class_">Symbol</span>(<span class="string">&quot;NUll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index.<span class="title function_">get</span>(key) === lowLink.<span class="title function_">get</span>(key)) &#123;</span><br><span class="line">      <span class="keyword">let</span> scc = [];</span><br><span class="line">      <span class="keyword">while</span> (w !== key) &#123;</span><br><span class="line">        w = stack.<span class="title function_">pop</span>();</span><br><span class="line">        scc.<span class="title function_">push</span>(w);</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="title function_">push</span>(scc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g4 = <span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="title class_">Graph</span>.<span class="property">DIRECTED</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">5</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">g4.<span class="title function_">addEdge</span>(<span class="number">9</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g4.<span class="title function_">SCC</span>(); <span class="comment">// [[8, 9], [7], [5, 4, 6], [3, 2, 1, 0]]</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">GeeksforGeeks. Tarjan’s Algorithm to find Strongly Connected Components.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>Tarjan算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - 定义</title>
    <url>/Graph-define/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<div class="note primary"><p>本文除特别指出，相关定义均出自 程杰. 《大话数据结构》</p>
</div>
<p>图( Graph )是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G ( V, E ), 其中, G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合</p>
<p>无向边：若顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的边没有方向，则称这条边为无向边( Edge ), 用无序偶对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_i,v_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 来表示。</p>
<p>无向图(Undirected graphs)：图中任意两个顶点之间的边都是无向边</p>
<span id="more"></span>
<p>有向边：若顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的边有方向，则称这条边为有向边，也称为弧 ( Arc )。用有序偶<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>来表示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称为弧尾(Tail), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>称为弧头 (Head).</p>
<p>有向图(Directed graphs)：图中任意两个顶点之间的边都是有向边</p>
<p>简单图：图中不存在顶点到其自身的边，且同一条边不重复出现</p>
<p>无向完全图：无向图中任意两个顶点之间都存在边</p>
<p>有向完全图：有向图中任意两个顶点之间都存在方向互为相反的两条弧</p>
<p>权(Weight)：与图的边或弧相关的数</p>
<p>网(Network)：带权的图</p>
<h2 id="点边关系">点边关系</h2>
<p>对于无向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>, 如果边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(v,v&#x27;)\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>，则称顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>互为邻接点(Adjacent), 即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>相邻接。边<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v,v&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>依附(incident)于顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>，或者说 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v,v&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>相关联。顶点的度(Degree) 是和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>相关联的边的数目，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>.</p>
<p>对于有向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>, 如果弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">&lt;v,v&#x27;&gt;\in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span> ，则称顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>邻接到顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,  顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>邻接自顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>。弧<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v,v&#x27;&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>与顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>相关联。以顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>为头的弧的数目称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的入度(InDegree), 记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ID(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>; 以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>为尾的弧的数目称为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的出度(OutDegree)，记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">OD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>；顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>的度 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mi>I</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TD(v)=ID(v) + OD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p>
<p>无向图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>中从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>到顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>的路径 (Path) 是一个顶点序列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo>=</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v=v_{(i,0)},v_{(i,1)},...,v_{(i,m)}=v&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7857599999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">m</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">(v_{(i,j-1)},v_{(i,j)})\in E, 1\le j \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<p>如果 G 是有向图，则路径也是有向的，顶点序列应满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">&lt;v_{(i,j-1)},v_{(i,j)}&gt;\in E,1 \le j \le m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8942999999999999em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span></p>
<p>路径的长度是路径上的边或弧的数目</p>
<p>第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环</p>
<h2 id="连通图">连通图</h2>
<p>在无向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中，如果从顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>到顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>有路径，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>v</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">v&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>是连通的。如果对于图中任意两个顶点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v_i, v_j \in V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>都是连通的，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>是连通图 ( Connected Graph )</p>
<p>无向图中的极大连通子图称为连通分量</p>
<p>在有向图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>中，如果对于每一对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>∈</mo><mi>V</mi><mo separator="true">,</mo><msub><mi>v</mi><mi>i</mi></msub><mo mathvariant="normal">≠</mo><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_i,v_j \in V,v_i \ne v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> ，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都存在路径，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>是强连通图。有向图中的极大强连通子图称做有向图的强连通分量</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论</a>中，<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">无向图</a> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的<strong>生成树</strong>（Spanning Tree）是具有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的全部<a href="https://zh.wikipedia.org/wiki/%E9%A1%B6%E7%82%B9_(%E5%9B%BE%E8%AE%BA)">顶点</a>，但边数最少的连通子图</p>
<p>以若图 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>g</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>g</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V_g,E_g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和树<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>t</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=(V_t,E_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>t</mi></msub><mo>⊂</mo><msub><mi>E</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">E_t \subset E_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>t</mi></msub><mo>=</mo><msub><mi>V</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">V_t = V_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, 那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>的生成树</p>
<p>——Wikipedia. 生成树</p>
</blockquote>
<p>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树</p>
<p>一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵互不相交的有向树的弧</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E6%A0%91">Wikipedia. 生成树</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>连通图</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - 存储结构 - Ⅱ</title>
    <url>/Graph-store-2/</url>
    <content><![CDATA[<p>在图论 - Ⅱ 中学习了图的邻接矩阵及邻接表实现，本部分学习十字链表优化有向图的存储结构、邻接多重表优化无向图的存储结构，以及边集数组的使用</p>
<h2 id="十字链表">十字链表</h2>
<p><strong>十字链表 (orthogonal List) 就是把邻接表和逆邻接表结合起来</strong>，解决邻接表只关心出\入度中的一种，查找另一种时必须遍历整个图才能知道的缺陷.</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10H10U6236.gif" alt="首元节点结构"></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10H1092b49.gif" alt="弧节点结构"></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10H11122456.gif" alt="有向图及其十字链表"></p>
<span id="more"></span>
<h3 id="代码实现">代码实现</h3>
<div class="note info"><p>上方图示结构简单实现! 重在理解，生产环境使用考虑更稳健的第三方库。</p>
<p>考虑 <a href="https://kinsiy.github.io/Graph-store-1/">图论 - 存储结构 - Ⅰ</a>  中邻接表实现方式，可舍弃弧节点结构，顶点新增逆邻接表维护逆邻接顶点</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 十字邻接表节点</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">headLink</span> = <span class="literal">null</span>; <span class="comment">// 第一条以 this 为弧头的弧</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tailLink</span> = <span class="literal">null</span>; <span class="comment">// 第一条以 this 为弧尾的弧</span></span><br><span class="line">    <span class="comment">// 使用headLink而非firstIn, 能更好的进行链表操作；tailLink同理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Arc</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tailVex, headVex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tailVex</span> = tailVex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">headVex</span> = headVex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">headLink</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tailLink</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 十字邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 图初始化</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 向图中增加顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125; 新顶点或已存在顶点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> vertex = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">set</span>(value, vertex);</span><br><span class="line">      <span class="keyword">return</span> vertex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除值为value的顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 移除是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">while</span> (current.<span class="property">tailLink</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeEdge</span>(value, current.<span class="property">tailLink</span>.<span class="property">headVex</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (current.<span class="property">headLink</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">removeEdge</span>(current.<span class="property">headLink</span>.<span class="property">tailVex</span>, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">delete</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 在图中创建边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(destination);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> arc = <span class="keyword">new</span> <span class="title class_">Arc</span>(source, destination);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curTailEdge = sourceNode;</span><br><span class="line">    <span class="keyword">while</span> (curTailEdge.<span class="property">tailLink</span>) &#123;</span><br><span class="line">      curTailEdge = curTailEdge.<span class="property">tailLink</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curTailEdge.<span class="property">tailLink</span> = arc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curHeadEdge = destinationNode;</span><br><span class="line">    <span class="keyword">while</span> (curHeadEdge.<span class="property">headLink</span>) &#123;</span><br><span class="line">      curHeadEdge = curHeadEdge.<span class="property">headLink</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curHeadEdge.<span class="property">headLink</span> = arc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(destination);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curTailArc = sourceNode;</span><br><span class="line">    <span class="keyword">while</span> (curTailArc.<span class="property">tailLink</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (curTailArc.<span class="property">tailLink</span>.<span class="property">headVex</span> === destination) &#123;</span><br><span class="line">        curTailArc.<span class="property">tailLink</span> = curTailArc.<span class="property">tailLink</span>.<span class="property">tailLink</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      curTailArc = curTailArc.<span class="property">tailLink</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curHeadArc = destinationNode;</span><br><span class="line">    <span class="keyword">while</span> (curHeadArc.<span class="property">headLink</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (curHeadArc.<span class="property">headLink</span>.<span class="property">tailVex</span> === source) &#123;</span><br><span class="line">        curHeadArc.<span class="property">headLink</span> = curHeadArc.<span class="property">headLink</span>.<span class="property">headLink</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      curHeadArc = curHeadArc.<span class="property">headLink</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="邻接多重表">邻接多重表</h2>
<p>针对无向图的邻接表存储方式进行优化，其核心思想是同一条边在不同节点的邻接表上用相同的边节点表示。</p>
<div class="note info"><p>其实前面邻接表的实现舍弃了边节点，把邻接节点存放在链表中(Set)就已经是这种方法的实现，而且是更好的实现。毕竟两个顶点已经可以唯一确定一条边。</p>
</div>
<p>若使用图示结构实现，由于存储的是无向图需要考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mi>V</mi><mi>e</mi><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mi>V</mi><mi>e</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(iVex,jVex)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>是无序偶对，使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mi>V</mi><mi>e</mi><mi>x</mi><mo separator="true">,</mo><mi>j</mi><mi>V</mi><mi>e</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(iVex,jVex)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>唯一确定一条无向边，而非与十字链表一般直接将弧插入到对应链表中</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10R04635G8.gif" alt="首元节点的结构示意图"></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10R04A6457.gif" alt="边节点结构"></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/2-1Z10R04Hb26.gif" alt="无向图及其邻接多重表"></p>
<p>iVex 和 jVex 是与某条边依附的两个顶点在顶点表中下标。iLink 指向依附顶点iVex 的下一条边，jLink指向依附顶点jVex的下一条边</p>
<h2 id="边集数组">边集数组</h2>
<blockquote>
<p>边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标(begin)、终点下标(end)和权(weight)组成</p>
<p>——程杰. 《大话数据结构》</p>
</blockquote>
<p><img data-src="https://img-blog.csdnimg.cn/20200903141819409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW1pbmdidWhhbw==,size_16,color_FFFFFF,t_70" alt="边集数组"></p>
<p>边集数组关注的是边的集合，在边集数组中要查找一个顶点的度需要扫描整个边数组，效率并不高。更适合对边一次经行处理的操作，不适合对顶点相关的操作</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="http://data.biancheng.net/graph/">data.biancheng.net. 数据结构图(Graph)详解</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>十字链表</tag>
        <tag>邻接多重表</tag>
        <tag>边集数组</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - 存储结构 - Ⅰ</title>
    <url>/Graph-store-1/</url>
    <content><![CDATA[<h2 id="邻接矩阵">邻接矩阵</h2>
<blockquote>
<p>图的邻接矩阵 (Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组 (称为邻接矩阵) 存储图中的边或弧的信息</p>
<p>——程杰. 《大话数据结构》.</p>
</blockquote>
<p>设图<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span></span></span></span>有 n 个顶点，则邻接矩阵是一个 n * n 的方阵，定义为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mtext> 或</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">arc[i][j] =
\begin{cases} 
1 &amp;(v_i,v_j) \in E(G) \text{ 或} &lt;v_i,v_j&gt; \in E(G)  \\
0 
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">或</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>也可以用大于0的值表示边的权值</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>W</mi><mtext>ij</mtext></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mtext> 或</mtext><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi mathvariant="normal">∞</mi></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">arc[i][j] =
\begin{cases} 
W_\text{ij} &amp;(v_i,v_j) \in E(G) \text{ 或} &lt;v_i,v_j&gt; \in E(G)  \\
\infty
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span><span class="mord text"><span class="mord"> </span><span class="mord cjk_fallback">或</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<span id="more"></span>
<p>无向图的邻接矩阵是<a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E7%9F%A9%E9%99%A3">对称矩阵</a></p>
<div class="note primary"><p>所谓对称矩阵就是 n 阶矩阵元满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mtext>ij</mtext></msub><mo>=</mo><msub><mi>a</mi><mtext>ji</mtext></msub><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_\text{ij} = a_\text{ji}, (0 \le i, j \le n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ji</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。即从矩阵的左上角到右下角的主对角线为轴，由上角的元与左下角对应的元全都是相等的</p>
</div>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/1_lMI_7wNnNgr3rqRqLULMZQ.png" alt=""></p>
<p>对于有向图，定义有向图的邻接矩阵中某个元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mtext>ij</mtext></msub></mrow><annotation encoding="application/x-tex">A_\text{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.317502em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord text mtight"><span class="mord mtight">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 代表：从 i 指向 j 的边的数目，则：</p>
<p>有向图的某个节点的入度可以通过对应的列(column) 求和得到，出度可以通过对应的行(row)求和而得。</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/1_O6lPwoKQKFPpBEH7QhxIIw.png" alt=""></p>
<h3 id="代码实现">代码实现</h3>
<div class="note info"><p>简单实现! 重在理解，生产环境使用考虑更稳健的第三方库</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接矩阵实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 图初始化</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; edgeDirection Graph.DIRECTED 或 Graph.UNDIRECTED</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">edgeDirection = Graph.DIRECTED</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span> = [];        <span class="comment">// 顶点表</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span> = [];        <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">edgeDirection</span> = edgeDirection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 向图中新增顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125; 新顶点或已存在顶点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">find</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="property">value</span> === value);</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">    current = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">push</span>(current);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="title function_">push</span>(<span class="title class_">Graph</span>.<span class="property">UNBOUND</span>));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span>.<span class="title function_">push</span>(<span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">matrix</span>.<span class="property">length</span> + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Graph</span>.<span class="property">UNBOUND</span>));</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除值为value的顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 移除是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="property">value</span> === value);</span><br><span class="line">    <span class="keyword">if</span> (currentIndex === -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">splice</span>(currentIndex, <span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="title function_">splice</span>(currentIndex, <span class="number">1</span>));</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span>.<span class="title function_">splice</span>(currentIndex, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 在图中创建边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">source, destination, weight = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sourceIndex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">indexOf</span>(sourceNode);</span><br><span class="line">    <span class="keyword">const</span> destinationIndex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">indexOf</span>(destinationNode);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">matrix</span>[sourceIndex][destinationIndex] = weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">matrix</span>[destinationIndex][sourceIndex] = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceIndex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="property">value</span> === source);</span><br><span class="line">    <span class="keyword">const</span> destinationIndex = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> e.<span class="property">value</span> === destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (~sourceIndex &amp;&amp; ~destinationIndex) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">matrix</span>[sourceIndex][destinationIndex] = <span class="title class_">Graph</span>.<span class="property">UNBOUND</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">matrix</span>[destinationIndex][sourceIndex] = <span class="title class_">Graph</span>.<span class="property">UNBOUND</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="variable language_">this</span>.<span class="property">nodes</span>[sourceIndex], <span class="variable language_">this</span>.<span class="property">nodes</span>[destinationIndex]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">UNBOUND</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;unbound&quot;</span>);</span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;undirected graph&quot;</span>); <span class="comment">// 无向图</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">DIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;directed graph&quot;</span>); <span class="comment">// 有向图</span></span><br></pre></td></tr></table></figure>
<h2 id="邻接表">邻接表</h2>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论</a>和<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>邻接表(adjacency list)</strong> 是表示了<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE_(%E6%95%B0%E5%AD%A6)">图</a>中与每一个<a href="https://zh.wikipedia.org/wiki/%E9%A1%B6%E7%82%B9_(%E5%9B%BE%E8%AE%BA)">顶点</a>相邻的边集的<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)">集合</a>，这里的集合指的是无序集。</p>
<p>——Wikipedia. 邻接表</p>
</blockquote>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/1_iGp2hOLcnMaKD3zE262ZAg.png" alt=""></p>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();        <span class="comment">// 邻接链表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 新增邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addAdjacent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">add</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 移除邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeAdjacent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">delete</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 节点是否与node邻接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; <span class="variable">node</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isAdjacent</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">adjacents</span>.<span class="title function_">has</span>(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 获取所有邻接节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Array</span>&#125; 邻接节点数组</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">getAdjacents</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [...<span class="variable language_">this</span>.<span class="property">adjacents</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 图初始化</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Symbol</span>&#125; edgeDirection Graph.DIRECTED 或 Graph.UNDIRECTED</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">edgeDirection = Graph.DIRECTED</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nodes</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">edgeDirection</span> = edgeDirection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 向图中增加顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Node</span>&#125; 新顶点或已存在顶点</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">has</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> vertex = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">set</span>(value, vertex);</span><br><span class="line">      <span class="keyword">return</span> vertex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除值为value的顶点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; value 顶点值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 移除是否成功</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeVertex</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (current) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">values</span>()) &#123;</span><br><span class="line">        node.<span class="title function_">removeAdjacent</span>(current);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">delete</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 在图中创建边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="title function_">addVertex</span>(destination);</span><br><span class="line"></span><br><span class="line">    sourceNode.<span class="title function_">addAdjacent</span>(destinationNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">      destinationNode.<span class="title function_">addAdjacent</span>(sourceNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 从图中移除边/弧</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">[Node, Node]</span>&#125; 邻接节点对</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">removeEdge</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceNode &amp;&amp; destinationNode) &#123;</span><br><span class="line">      sourceNode.<span class="title function_">removeAdjacent</span>(destinationNode);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">edgeDirection</span> === <span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span>) &#123;</span><br><span class="line">        destinationNode.<span class="title function_">removeAdjacent</span>(sourceNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [sourceNode, destinationNode];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 判断两节点是否邻接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">source</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">destination</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="type">Boolean</span>&#125; 邻接与否</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">isAdjacent</span>(<span class="params">source, destination</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sourceNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(source);</span><br><span class="line">    <span class="keyword">const</span> destinationNode = <span class="variable language_">this</span>.<span class="property">nodes</span>.<span class="title function_">get</span>(destination);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sourceNode &amp;&amp; destinationNode) &#123;</span><br><span class="line">      <span class="keyword">return</span> sourceNode.<span class="title function_">isAdjacent</span>(destinationNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">UNDIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;undirected graph&quot;</span>); <span class="comment">// 无向图</span></span><br><span class="line"><span class="title class_">Graph</span>.<span class="property">DIRECTED</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;directed graph&quot;</span>); <span class="comment">// 有向图</span></span><br></pre></td></tr></table></figure>
<p>有向图的邻接表由于有方向，我们以顶点为弧尾来存储边表，这样很容易就可以得到每个顶点的出度。但也有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个<strong>有向图的逆邻接表，即对每个顶点都建立一个连接为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为弧头的表</strong></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://reginafurness.medium.com/representing-a-weighted-graph-with-an-adjacency-matrix-in-javascript-8a803bfbc36f">Refina Furness.  Representing a Weighted Graph with an Adjacency Matrix in JavaScript</a></p>
<p>[2]<a href="https://adrianmejia.com/data-structures-for-beginners-graphs-time-complexity-tutorial/#Adjacency-List-Graph-OO-Implementation">AdrianMejia.com Graph Data Structures in JavaScript for Beginners.</a></p>
<p>[3]<a href="https://github.com/amejiarosario/dsa.js-data-structures-algorithms-javascript/tree/master/src/data-structures/graphs">Github.com amejiarosario.  dsa.js-data-structures-algorithms-javascript</a></p>
<p>[4]<a href="https://blog.sessionstack.com/how-javascript-works-introduction-to-graphs-and-trees-708da0020cf8">Blog.sessionstack.com. How JavaScript works: introduction to Graphs and Trees</a></p>
<p>[5]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>邻接矩阵</tag>
        <tag>邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title>图论 - 遍历</title>
    <url>/Graph-traverse/</url>
    <content><![CDATA[<h2 id="图的遍历">图的遍历</h2>
<p>从图中某一顶点出发访遍图中其余顶点，且使每个顶点仅被访问一次，这一过程就叫做图的遍历(Traversing Graph)</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>深度优先遍历(Depth-First-Search)，也有称为深度优先搜索，简称为DFS。</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Depth-First-Search.gif" alt=""></p>
<span id="more"></span>
<h3 id="代码实现">代码实现</h3>
<p>存储结构采用邻接表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 深度优先遍历，生成器函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; first 第一个开始遍历的节点</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  *<span class="title function_">dfs</span>(<span class="params">first</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Map</span></span><br><span class="line">    <span class="keyword">const</span> visitList = [first]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(visitList.<span class="property">length</span> !== <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> node = visitList.<span class="title function_">pop</span>()</span><br><span class="line">      <span class="keyword">if</span>(node &amp;&amp; !visited.<span class="title function_">has</span>(node))&#123;</span><br><span class="line">        <span class="keyword">yield</span> node</span><br><span class="line">        visited.<span class="title function_">set</span>(node)</span><br><span class="line">        visitList.<span class="title function_">push</span>(...node.<span class="title function_">getAdjacents</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>广度优先遍历(Breadth-First-Search)，又称广度优先搜索，简称BFS</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Breadth-First-Search-Algorithm.gif" alt=""></p>
<h3 id="代码实现-2">代码实现</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 图 - 邻接表实现</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>: 深度优先遍历，生成器函数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">Node</span>&#125; first 第一个开始遍历的节点</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">  *<span class="title function_">dfs</span>(<span class="params">first</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Map</span></span><br><span class="line">    <span class="keyword">const</span> visitList = [first]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(visitList.<span class="property">length</span> !== <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> node = visitList.<span class="title function_">pop</span>()</span><br><span class="line">      <span class="keyword">if</span>(node &amp;&amp; !visited.<span class="title function_">has</span>(node))&#123;</span><br><span class="line">        <span class="keyword">yield</span> node</span><br><span class="line">        visited.<span class="title function_">set</span>(node)</span><br><span class="line">        visitList.<span class="title function_">push</span>(...node.<span class="title function_">getAdjacents</span>())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://adrianmejia.com/data-structures-for-beginners-graphs-time-complexity-tutorial/#Adjacency-List-Graph-OO-Implementation">AdrianMejia.com Graph Data Structures in JavaScript for Beginners.</a></p>
<p>[3]<a href="https://github.com/amejiarosario/dsa.js-data-structures-algorithms-javascript/tree/master/src/data-structures/graphs">Github.com amejiarosario.  dsa.js-data-structures-algorithms-javascript</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-Cache</title>
    <url>/HTTP-cache/</url>
    <content><![CDATA[<h2 id="HTTP-缓存">HTTP 缓存</h2>
<blockquote>
<p>HTTP 缓存存储与请求关联的响应，并将存储的响应复用于后续请求。</p>
<p>可复用性有几个优点。首先，由于不需要将请求传递到源服务器，因此客户端和缓存越近，响应速度就越快。最典型的例子是浏览器本身为浏览器请求存储缓存。</p>
<p>此外，当响应可复用时，源服务器不需要处理请求——因为它不需要解析和路由请求、根据 cookie 恢复会话、查询数据库以获取结果或渲染模板引擎。这减少了服务器上的负载。</p>
<p>缓存的正确操作对系统的稳定运行至关重要。</p>
<p>——MDN - HTTP缓存</p>
</blockquote>
<span id="more"></span>
<h3 id="缓存类型">缓存类型</h3>
<ul>
<li>
<p>首次请求[<mark class="label success">Client 1</mark>]：浏览器首次请求资源时，由于浏览器缓存中没有对应的缓存，此时需要去服务器请求，待返回数据后将其存储在缓存数据库中。当浏览器存在对应缓存数据后，下次请求可以根据需要决定是否向服务器发起请求</p>
</li>
<li>
<p>强缓存[<mark class="label success">Client 2</mark>]：用户请求数据，如果命中强缓存，则不向服务器请求，而直接从本地资源获取，返回200状态码，并提示from disk cache或from memory cache（比从disk快）</p>
</li>
<li>
<p>协商缓存[<mark class="label success">Client 3</mark>]：在用户请求资源时，浏览器直接向服务器发送请求，协商对比服务端和本地的资源，验证本地资源是否失效</p>
</li>
</ul>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/HTTPStaleness.png" alt="HTTPStaleness"></p>
<p>强制缓存和协商缓存命中缓存资源后，都是从本地读取资源。如果强制缓存生效，则不需要再向服务器发出请求；而协商缓存，不管是否使用缓存，必须向服务器发送一个请求来协商。</p>
<p>两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。如果强制缓存规则不生效，则需要进行协商缓存判断</p>
<h3 id="缓存相关Header">缓存相关Header</h3>
<h4 id="强缓存">强缓存</h4>
<p>强制缓存的response header中会有两个字段来表明失效规则（Expires/Cache-Control）</p>
<ul>
<li>Cache-Control：Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">更多指令</a>
<ul>
<li>no-store：所有内容都不会缓存，强缓存，协商缓存都不会触发</li>
<li>no-cache： 需要使用协商缓存来验证缓存数据</li>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age = xxx： 缓存内容将在xxx秒后失效</li>
</ul>
</li>
<li>Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。</li>
<li>Pragma：一个HTTP1.0中规定的通用首部，如果<mark class="label primary">Cache-Control</mark>不存在的话，它的行为与<mark class="label primary">Cache-Control: no-cache</mark>一致</li>
</ul>
<p>在HTTP1.0的环境下，Cache-Control不起作用，Expires起作用； 在HTTP1.1的环境之下， Expires不起作用，而Cache-Control起作用。当前一般都是http1.1的情况，所以Expires是作为一种向下兼容的形式而存在的。</p>
<div class="note warning"><p>Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<p>Expires 到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这会导致缓存命中的误差。</p>
<p>Pragma 的值就只有一个，no-cache，并且它的优先级比 Cache-Control 高</p>
</div>
<h4 id="协商缓存">协商缓存</h4>
<h5 id="Last-Modified-If-Modified-Since">Last-Modified / If-Modified-Since</h5>
<ul>
<li>
<p>Last-Modified：服务器响应请求时，告诉浏览器资源最后的修改时间。</p>
</li>
<li>
<p>If-Modified-Since：浏览器再次请求资源时，浏览器通知服务器，上次请求时，返回的资源最后修改时间。</p>
</li>
</ul>
<p>若最后修改时间小于等于If-Modified-Since，则response header返回304，告知浏览器继续使用所保存的cache。若大于If-Modified-Since，则说明资源被改动过，返回状态码200；</p>
<h5 id="If-none-match-Etag"><strong>If-none-match / Etag</strong></h5>
<ul>
<li>
<p>Etag：服务器响应请求时，告诉浏览器当前资源在浏览器的唯一标识（生成规则由服务器确定）</p>
</li>
<li>
<p>If-None-Match：再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。</p>
<p>服务器收到请求后发现有If-None-Match 则与被请求资源的唯一标识进行比对：</p>
<ul>
<li>不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；</li>
<li>相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。</li>
</ul>
</li>
</ul>
<p>本地缓存时间到期后，浏览器向服务端发送请求报文，其中Request Header中包含If-none-match和Last-Modified-Since（与服务端Etag和Last-Modified对比，Etag优先级高），用以验证本地缓存数据验证是否与服务端保持一致。在服务器端会优先判断Etag。如果相同，返回304；如果不同，就继续比较Last-Modified，然后决定是否返回新的资源。若服务端验证本地缓存与服务端一致，返回304，浏览器加载本地缓存；否则，服务器返回请求的资源，同时给出新的Etag以及Last-Modified时间。</p>
<div class="note warning"><p>在精确度上，Etag优于Last-Modified。Last-Modified精确到s，如果1s内，资源多次改变，Etag是可以判断出来并返回最新的资源。</p>
<p>在性能上，Last-Modified优于Etag，因为Last-Modified只需要记录时间，而Etag需要服务器重新生成hash值，所以性能上略差。</p>
<p>在优先级上，Etag优于Last-Modified，Etag和Last-Modified可同时存在。</p>
</div>
<h3 id="流程图">流程图</h3>
<p><img data-src="https://pic1.zhimg.com/80/v2-b52f314c86e3e95459845589d4d35570_720w.jpg" alt=""></p>
<h3 id="用户行为对缓存的影响">用户行为对缓存的影响</h3>
<table>
<thead>
<tr>
<th>用户操作</th>
<th>Expires/Cache-Control</th>
<th>Last-Modied/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址栏回车</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>页面链接跳转</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>新开窗口</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>前进回退</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>F5刷新</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Ctrl+F5强制刷新</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<h3 id="缓存更新">缓存更新</h3>
<p>通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。</p>
<h4 id="用数字做版本号">用数字做版本号</h4>
<p><img data-src="https://pic1.zhimg.com/80/8a8676e933478d1a73777d84a5de55f5_720w.jpg?source=1940ef5c" alt=""></p>
<p>但是如果使用版本号的话，假设某次更新只更改了一个文件，其他未更改的文件为了保持版本一致都需要更新，会导致原有缓存失效，造成无效更新</p>
<h4 id="用文件摘要做版本号">用文件摘要做版本号</h4>
<p>采用<strong>数据摘要要算法</strong>对文件求摘要值，拼接到路径参数上，更新某一文件时，只需更新对应文件的路径即可。</p>
<p><img data-src="https://pic3.zhimg.com/80/5276595f41d6276e21e5bc1d25741680_720w.jpg?source=1940ef5c" alt=""></p>
<p>但这样会导致无论<strong>先部署页面</strong>还是<strong>先部署静态资源</strong>都会导致部署过程中发生页面错乱的问题</p>
<p><strong>先部署页面</strong>，在两者部署间隔中，假如有用户访问新页面，此时<strong>页面中的资源路径已经更新，但资源仍未更新</strong>。客户端看到这个新的路径，就会发起请求，然而依然会拿到旧资源并作为缓存，并且，即便后面资源更新了，在已拿到资源缓存过期前，一直都不会重新请求，<strong>一直都会是旧资源</strong></p>
<p><strong>先部署资源</strong>，在两者部署间隔中，假如有用户访问，此时 html 中资源路径仍未更新，资源已经更新。这时假如本地缓存未过期，则不会请求，一切安好。假如这时本地缓存过期了，会去协商缓存，就会出现<strong>旧 html 引用新资源的情况，可能会导致页面出错</strong>。</p>
<h4 id="更好的做法">更好的做法</h4>
<p>用文件的摘要信息来对资源文件进行重命名，把摘要信息放到资源文件发布路径中，这样，内容有修改的资源就变成了一个新的文件发布到线上，不会覆盖已有的资源文件。上线过程中，先全量部署静态资源，再灰度部署页面</p>
<p><img data-src="https://pic4.zhimg.com/80/9b3a9df114d14a14130a70abf5733837_720w.jpg?source=1940ef5c" alt=""></p>
<h3 id="参考">参考</h3>
<p>[1]<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">MDN. HTTP 缓存. </a></p>
<p>[2]<a href="https://www.cnblogs.com/huaweiyun/p/13390041.html">华为云开发者社区. 深入理解浏览器的缓存机制. 博客园</a></p>
<p>[3]<a href="https://zhuanlan.zhihu.com/p/360512798">字节前端. 浅析HTTP缓存. 知乎专栏</a></p>
<p>[4]<a href="https://www.zhihu.com/question/20790576/answer/32602154">张云龙. 大公司里怎样开发和部署前端代码？问题下回答. 知乎</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP-Header</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-语言基础</title>
    <url>/JavaScript-Basics/</url>
    <content><![CDATA[<p>本文依据红宝书内容概括了 Javascript 的语言基础，分语法、关键字与保留字、变量、数据类型、操作符、语句、函数六部分。为个人读书笔记，可能会有错误的地方。</p>
<span id="more"></span>
<h2 id="语法">语法</h2>
<h3 id="区分大小写">区分大小写</h3>
<p>ECMAScript 中一切都区分大小写。无论是变量、函数名、还是操作符，都区分大小写。</p>
<h3 id="标识符">标识符</h3>
<ul>
<li>第一个字符必须是字母、下划线(_)或美元符号($)</li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字</li>
</ul>
<p>字母可以是扩展 ASCII 中的字母，也可以是 Unicode 的字母字符。<br>
按照惯例，ECMAScript 标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p>
<h3 id="注释">注释</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 驼峰大小写(单行注释)</span></span><br><span class="line"><span class="comment">/*· 多行注释</span></span><br><span class="line"><span class="comment">    firstSecond</span></span><br><span class="line"><span class="comment">    myCar</span></span><br><span class="line"><span class="comment">    doSomethingImportant</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="严格模式">严格模式</h3>
<p>严格模式(ECMAScript 5 增加)是一种不同的 Javascript 解析和执行模式，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; <span class="comment">//对整个脚本启用严格模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>; <span class="comment">// 在指定函数中启用严格模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语句">语句</h3>
<p>ECMAScript 中的语句以分号结尾。多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号( { )标识开始，一个右花括号( } )标识结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = a + b; <span class="comment">//没有分号也有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> sum = a - b; <span class="comment">//加分号有效，推荐</span></span><br><span class="line"><span class="comment">/* 代码块 */</span></span><br><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">  test = <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* if 之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句 */</span></span><br></pre></td></tr></table></figure>
<h3 id="关键字与保留字">关键字与保留字</h3>
<p>ECMA-262 第六版规定的所有关键字如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
<th style="text-align:center">-</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">do</td>
<td style="text-align:center">in</td>
<td style="text-align:center">typeof</td>
<td style="text-align:center">case</td>
<td style="text-align:center">else</td>
<td style="text-align:center">instanceof</td>
<td style="text-align:center">var</td>
</tr>
<tr>
<td style="text-align:center">catch</td>
<td style="text-align:center">export</td>
<td style="text-align:center">new</td>
<td style="text-align:center">void</td>
<td style="text-align:center">class</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">return</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">finally</td>
<td style="text-align:center">super</td>
<td style="text-align:center">with</td>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">switch</td>
<td style="text-align:center">yield</td>
</tr>
<tr>
<td style="text-align:center">debugger</td>
<td style="text-align:center">function</td>
<td style="text-align:center">this</td>
<td style="text-align:center">default</td>
<td style="text-align:center">if</td>
<td style="text-align:center">throw</td>
<td style="text-align:center">delete</td>
<td style="text-align:center">import</td>
</tr>
<tr>
<td style="text-align:center">try</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h4 id="未来的保留字">未来的保留字</h4>
<p>ECMA-262 第 6 版为将来保留的所有词汇：<br><br>
始终保留：<b>enum</b></p>
<p>严格模式下保留：</p>
<table>
<thead>
<tr>
<th style="text-align:center">implements</th>
<th style="text-align:center">package</th>
<th style="text-align:center">public</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">static</th>
<th style="text-align:center">let</th>
<th style="text-align:center">private</th>
</tr>
</thead>
</table>
<p>代码块中保留：<b>await</b></p>
<h3 id="变量">变量</h3>
<p>有三个关键字可以声明变量：var、const 和 let。const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</p>
<h4 id="var">var</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hello worid!&quot;</span>;</span><br><span class="line">message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 合法，但不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用var操作符定义的变量会成为包含它的函数的局部变量</span></span><br><span class="line"><span class="comment">    在使用var声明变量时，变量会自动添加到最接近的上下文中(参见《变量、作用域与内存》，不好意思还没写！) */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> firstName = <span class="string">&quot;Kinsiy&quot;</span>; <span class="comment">//局部变量</span></span><br><span class="line">  secondName = <span class="string">&quot;Kinsiy&quot;</span>; <span class="comment">//全局变量。不推荐，难维护</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sex); <span class="comment">//不会报错</span></span><br><span class="line">  <span class="keyword">var</span> sex = <span class="string">&quot;boy&quot;</span>; <span class="comment">//使用var这个关键字声明的变量会自动提升到函数作用域的顶部</span></span><br><span class="line">  <span class="keyword">var</span> sex = <span class="string">&quot;girl&quot;</span>; <span class="comment">//反复多次使用var声明一个变量也没有问题</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName); <span class="comment">//ReferenceError</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondName); <span class="comment">//Kinsiy</span></span><br></pre></td></tr></table></figure>
<h4 id="let">let</h4>
<p>let 和 var 的作用差不多,但有着非常重要的区别。最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局声明</span></span><br><span class="line"><span class="comment">/* 使用let在全局作用域中声明的变量不会成为window对象的属性(var声明则会) */</span></span><br><span class="line"><span class="keyword">var</span> car = <span class="string">&quot;civic&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> house = <span class="string">&quot;Oh! No&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">car</span>); <span class="comment">//civic</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">house</span>); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myName); <span class="comment">//undefined     myName变量提升</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(anotherName); <span class="comment">//ReferenceError    anotherName不会被提升   暂时性死区</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> myName = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> anotherName = <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> anotherName = <span class="string">&quot;QING&quot;</span>; <span class="comment">//SyntaxError; 标识符anotherName已经声明过了</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(myName); <span class="comment">//Kinsiy</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(anotherName); <span class="comment">//Restituo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName); <span class="comment">//Kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherName); <span class="comment">//ReferenceError     作用域仅作用与块内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件声明</span></span><br><span class="line"><span class="comment">/* let 不能依赖条件声明模式，即使使用try/catch或typeof也不能解决 */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Testname</span> === <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title class_">Testname</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Testname 被限制在 if &#123; &#125; 块的作用域中</span></span><br><span class="line"><span class="comment">    这个声明形同下面这个全局声明 */</span></span><br><span class="line"><span class="title class_">Testname</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(sex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="keyword">let</span> sex = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* sex 被限制在 catch &#123; &#125; 块的作用域中</span></span><br><span class="line"><span class="comment">    这个声明形同下面这个全局声明 */</span></span><br><span class="line">sex;</span><br><span class="line"><span class="comment">/* 总之一句话不能使用let进行条件式声明 */</span></span><br></pre></td></tr></table></figure>
<h4 id="const">const</h4>
<p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量尝试修改 const 声明的变量会导致运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">22</span>;</span><br><span class="line">age = <span class="number">17</span>; <span class="comment">//TypeError</span></span><br><span class="line"><span class="comment">//const 也不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;Kinsiy&quot;</span>; <span class="comment">//SyntaxError</span></span><br><span class="line"><span class="comment">//const 的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> sex = <span class="string">&quot;girl&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> sex = <span class="string">&quot;boy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sex); <span class="comment">//girl</span></span><br><span class="line"><span class="comment">/* const 声明的限制只适用与它指向的变量的引用 */</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>; <span class="comment">//没有问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别得</span></span><br><span class="line"><span class="comment">/* 对于for、for in 、 for of 循环 </span></span><br><span class="line"><span class="comment">    for in 和for of它们两个都是一种严格的迭代语句，对于对象中的每一个属性值，有一个指定的语句块被执行。</span></span><br><span class="line"><span class="comment">    也就是每一次循环，都会产生一个块级作用域来完成每个变量的行为</span></span><br><span class="line"><span class="comment">    然而for循环并不会遍历对象的属性，每一次循环都是在同个块级作用域中进行，使用const声明就会报错。</span></span><br><span class="line"><span class="comment">    所以在for in或者for of当中，推荐使用const来确保访问到的属性值不会被后续语句所改变。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="数据类型">数据类型</h3>
<h4 id="Undefined">Undefined</h4>
<p>Undefined 类型只有一个值，就是特殊值 undefined(假值)。当使用 var 或 let 声明了变量但没有初始化值时，就相当于给变量赋予了 undefined 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == undefinded); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">//ReferenceError，声明了变量但未赋值与未声明变量是不同的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//typeof 时变量声明与否均返回undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age); <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="Null">Null</h4>
<p>Null 类型同样只有一个值，即特殊值 null(假值)。逻辑上讲，null 值表示一个空对象指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">//&quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 值是有null值派生而来的，因此ECMA-262将他们定义为表面上相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任何时候，只要变量要保存对象，而当时又没有那个对象可保存,就要用null来填充该变量。这样可以保持null是空对象指针的语义，并进一步与undefined区分开来 */</span></span><br></pre></td></tr></table></figure>
<h4 id="Boolean-类型">Boolean 类型</h4>
<p>Boolean 有两个字面值：true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。<br><br>
Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。转换规则如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转换为 true 的值</th>
<th style="text-align:center">转化为 false 的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">String</td>
<td style="text-align:center">非空字符串</td>
<td style="text-align:center">“”(空字符串)</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">非零数值(包括无穷值)</td>
<td style="text-align:center">0、NaN</td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任意对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">N/A(不存在)</td>
<td style="text-align:center">undefined</td>
</tr>
</tbody>
</table>
<h4 id="Number-类型">Number 类型</h4>
<h5 id="浮点值">浮点值</h5>
<p>要定义浮点值，数值中必须包含小数点，且小数点后面必须至少有一个数字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 科学记数法</span></span><br><span class="line"><span class="comment">// 格式要求是一个数值(整数或浮点数)后跟一个大写或小写的e，再加上一个要乘的10的多少次幂</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.14e7</span>; <span class="comment">//等于31400000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值的范围</span></span><br><span class="line"><span class="comment">/*如果某个计算得到的数值结果超过了Javascript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity(无穷值)。任何无法表示的负数以-Infinity表示，任何无法表示的正数以Infinity表示。*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> + <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(result)); <span class="comment">//false, isFinite()确定一个值是不是有限大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NaN</span></span><br><span class="line"><span class="comment">/* 用于表示本来要反回数值的操作失败了(不是错误) ，任何涉及NaN的操作始终返回NaN */</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> / +<span class="number">0</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> / <span class="number">10</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">//Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> / -<span class="number">0</span>); <span class="comment">//-Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转换</span></span><br><span class="line"><span class="comment">/* 有3个函数可以将非数值转换为数值：Number()、parseInt()、parseFloat(); Number()为转型函数,可用于任何数据类型。后两个主要用于将字符串转换为数值 */</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="title class_">Number</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">//11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="title class_">Number</span>(<span class="string">&quot;true&quot;</span>); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234hi&quot;</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">let</span> num7 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//10</span></span><br><span class="line"><span class="keyword">let</span> num8 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>); <span class="comment">//175</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parseFloat() 只解析十进制值，不能指定底数</span></span><br><span class="line"><span class="keyword">let</span> num10 = <span class="built_in">parseFloat</span>(<span class="string">&quot;1234hi&quot;</span>); <span class="comment">//1234       按整数解析</span></span><br><span class="line"><span class="keyword">let</span> num11 = <span class="built_in">parseFloat</span>(<span class="string">&quot;22.4.5&quot;</span>); <span class="comment">//22.4        指解析到第一个小数点</span></span><br><span class="line"><span class="keyword">let</span> num12 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>Number()函数基于如下规则执行转换：</p>
<ul>
<li>布尔值，true 转换为 1，false 转换为 0。</li>
<li>数值，直接返回</li>
<li>null，返回 0</li>
<li>undefined，返回 NaN</li>
<li>字符串应用一下规则
<ul>
<li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。</li>
<li>如果字符串包含有效的浮点值格式如&quot;1.1&quot;,则会转换为相应的浮点值</li>
<li>如果字符串包含有效的十六进制格式如&quot;0xf&quot;,则会转换为与该十六进制对应的十进制数值</li>
<li>如果是空字符串，则返回 0</li>
<li>如果字符串包含除上述情况之外的其他字符，则返回 NaN</li>
</ul>
</li>
<li>对象，调用 valueof()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法,在按照字符串的规则转换。</li>
</ul>
<h4 id="String-类型">String 类型</h4>
<p>String (字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(&quot;)、单引号(')或反引号(`)标识。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字面量</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">制表</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center">\\</td>
<td style="text-align:center">反斜杠(\)</td>
</tr>
<tr>
<td style="text-align:center">\’</td>
<td style="text-align:center">单引号，在字符串以单引号标示时使用，例如’He said, \‘hey.\’’</td>
</tr>
<tr>
<td style="text-align:center">\&quot;</td>
<td style="text-align:center">双引号，在字符串以双引号标示时使用，例如&quot;He said, \“hey.\”&quot;</td>
</tr>
<tr>
<td style="text-align:center">\`</td>
<td style="text-align:center">反引号，在字符串以反引号标示时使用，例如`He said, \`hey.\``</td>
</tr>
<tr>
<td style="text-align:center">\xnn</td>
<td style="text-align:center">以十六进制编码 nn 标识的字符(其中 n 是十六进制数字 0~F)，例如\x41 等于&quot;A&quot;</td>
</tr>
<tr>
<td style="text-align:center">\unnn</td>
<td style="text-align:center">以十六进制编码 nnnn 标识的 Unicode 字符(其中 n 是十六进制数字 0~F)，例如\u03a3 等于希腊字符&quot;Σ&quot;</td>
</tr>
</tbody>
</table>
<p>ECMAScript 中的字符串是不可变的，意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始字符串，然后将包含新值得另一个字符串保存到该变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// toString()</span></span><br><span class="line"><span class="comment">/* toString()方法可见于数值、布尔值、对象、和字符串值。null和undefined值没有toString()方法 */</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">//&quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">//&quot;1010&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">8</span>)); <span class="comment">//&quot;12&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">10</span>)); <span class="comment">//&quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)); <span class="comment">//&quot;a&quot;</span></span><br><span class="line"><span class="comment">/* 不确定一个值是不是null或undefined，可以用String()转型函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字面量</span></span><br><span class="line"><span class="comment">/* 模板字面量可以保留换行字符，可以跨行定义字符串 */</span></span><br><span class="line"><span class="keyword">let</span> pageHtml = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;a herf=&quot;#&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;span&gt;Kinsiy&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pageHtml); <span class="comment">//输出保留制表符(空格)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&quot;五倍&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> resultStr = <span class="string">`<span class="subst">$&#123;value&#125;</span>的<span class="subst">$&#123;exponent&#125;</span>是<span class="subst">$&#123;value * <span class="number">5</span>&#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(resultStr); <span class="comment">//5的5倍是25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始字符串</span></span><br><span class="line"><span class="comment">/* 使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或Unicode字符)，而不是被转义后的字符表示。 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>); <span class="comment">//  ©</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>); <span class="comment">// \u00A9</span></span><br></pre></td></tr></table></figure>
<p>String()函数遵循如下规则：</p>
<ul>
<li>如果有 toString()方法，则调用该方法(不传参数)并返回结果</li>
<li>如果值是 null，返回&quot;null&quot;</li>
<li>如果值是 undefined，返回&quot;undefined&quot;</li>
</ul>
<h4 id="Symbol-类型">Symbol 类型</h4>
<p>Symbol(符号)是 EMCAScript 6 新增的数据类型。符号是原始值，且符号是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。<br>
<br>看不明白，暂时略过。</p>
<h4 id="Object-类型">Object 类型</h4>
<p>ECMAScript 中的对象其实就是一组数据和功能的集合。<br>
<br>每个 Object 实例都有如下属性和方法：</p>
<ul>
<li>constructor: 用于创建当前对象的函数</li>
<li>hasOwnProperty(propertyName): 用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串。</li>
<li>propertyIsEnumerable(propertyName): 用于判断给定的属性是否可以使用 for-in 语句枚举</li>
<li>toLocalString(): 返回对象的字符串表示, 该字符串反应对象所在的本地唤环境</li>
<li>toString(): 返回对象的字符串表示</li>
<li>valueof(): 返会对象对应的字符串、数值、布尔值表示。通常与 toString()的返回值相同。</li>
</ul>
<h3 id="操作符">操作符</h3>
<h4 id="一元操作符">一元操作符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">“+”</th>
<th style="text-align:center">“++”</th>
<th style="text-align:center">“-”</th>
<th style="text-align:center">“–”</th>
</tr>
</thead>
</table>
<h4 id="位操作符">位操作符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">符号</th>
<th style="text-align:center">规则(效果)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">按位非</td>
<td style="text-align:center">~</td>
<td style="text-align:center">返回数值的一补数(最终效果：对数值取反并减 1)</td>
</tr>
<tr>
<td style="text-align:center">按位与</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">两位均为 1，返回 1</td>
</tr>
<tr>
<td style="text-align:center">按位或</td>
<td style="text-align:center">|</td>
<td style="text-align:center">在至少一位是 1 是返回 1</td>
</tr>
<tr>
<td style="text-align:center">按位异或</td>
<td style="text-align:center">^</td>
<td style="text-align:center">只在一位是 1 是返回 1，两位都是 1 或 0 返回 0</td>
</tr>
<tr>
<td style="text-align:center">左移</td>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">按照指定的位数将数值的所有位向左移动</td>
</tr>
<tr>
<td style="text-align:center">有符号右移</td>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">将数值的所有 32 位都向右移，同时保留符号</td>
</tr>
<tr>
<td style="text-align:center">无符号右移</td>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">将数值的所有 32 位都向右移</td>
</tr>
</tbody>
</table>
<h4 id="布尔操作符">布尔操作符</h4>
<h5 id="逻辑非">逻辑非(!)</h5>
<p>逻辑非会遵循如下规则：</p>
<ul>
<li>如果操作数是对象，则返回 false</li>
<li>如果操作数是空字符串，返回 true</li>
<li>如果操作数是非空字符串，返回 false</li>
<li>如果操作数是数值 0，返回 true</li>
<li>如果操作数是非 0 数值(包括 Infinity)，返回 false</li>
<li>如果操作数是 null，返回 true</li>
<li>如果操作数是 NaN，返回 true</li>
<li>如果操作数数 undefined，返回 true</li>
</ul>
<h5 id="逻辑与">逻辑与(&amp;&amp;)</h5>
<p>逻辑与操作符可用于任何类型的操作数，不限与布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则。</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数</li>
<li>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象</li>
<li>如果两个操作数均是对象，则返回第二个操作数</li>
<li>如果有一个操作数是 null，则返回 null</li>
<li>如果有一个操作数是 NaN，则返回 NaN</li>
<li>如果有一个操作数是 undefined，则返回 undefined</li>
</ul>
<h5 id="逻辑或">逻辑或(||)</h5>
<p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数</li>
<li>如果第一个操作数求值为 false，则返回第二个操作数</li>
<li>如果两个操作数均是对象，则返回第一个操作数</li>
<li>如果两个操作数都是 null，则返回 null</li>
<li>如果两个操作数都是 NaN，则返回 NaN</li>
<li>如果两个操作数都是 undefined，则返回 undefined</li>
</ul>
<h4 id="乘性操作符">乘性操作符</h4>
<h5 id="乘法">乘法(*)</h5>
<ul>
<li>有任一操作数是 NaN，返回 NaN</li>
<li>Infinity * 0 ，返回 NaN</li>
<li>Infinity * x，依据 x 的正负返回 Infinity 或-Infinity</li>
<li>Infinity * Infinity，返回 Infinity</li>
<li>如果不是数值的操作数，则现在后台用 Number()将其转换为数值，再应用上述规则</li>
</ul>
<h5 id="除法">除法(/)</h5>
<ul>
<li>有任一操作数是 NaN，返回 NaN</li>
<li>Infinity / Infinity ，返回 NaN</li>
<li>x / 0 (x≠0)，依据 x 的正负返回 Infinity 或-Infinity</li>
<li>0 / 0，返回 NaN</li>
<li>Infinity / x，依据 x 的正负返回 Infinity 或-Infinity</li>
<li>如果不是数值的操作数，则现在后台用 Number()将其转换为数值，再应用上述规则</li>
</ul>
<h5 id="取模">取模(%)</h5>
<p>与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为</p>
<ul>
<li>如果操作数是数值，则执行常规除法运算，返回余数</li>
<li>如果被除数是无限值，除数是有限值，返回 NaN</li>
<li>如果被除数是有限值，除数是 0，则返回 NaN</li>
<li>Infinity % Infinity，返回 NaN</li>
<li>被除数是有限值，除数是无限值，返回被除数</li>
<li>如果不是数值的操作数，则现在后台用 Number()将其转换为数值，再应用上述规则</li>
</ul>
<h4 id="指数操作符">指数操作符</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">//9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">16</span> ** <span class="number">0.5</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h4 id="加性操作符">加性操作符</h4>
<h5 id="加法操作符">加法操作符</h5>
<ul>
<li>如果有任一操作数是 NaN，返回 NaN</li>
<li>Infinity + Infinity,返回 Infinity</li>
<li>-Infinity + -Infinity,返回-Infinity</li>
<li>-Infinity + Infinity,返回 NaN</li>
<li>+0 + +0，返回+0</li>
<li>-0 + +0，返回+0</li>
<li>-0 + -0，返回-0</li>
<li>若有一个操作数是字符串
<ul>
<li>两个操作数均为字符串，将第二个字符串拼接到第一个字符串后面</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接到一起</li>
</ul>
</li>
</ul>
<h5 id="减法操作符">减法操作符</h5>
<ul>
<li>如果有任一操作数是 NaN，返回 NaN</li>
<li>Infinity - Infinity,返回 NaN</li>
<li>Infinity - -Infinity,返回 Infinity</li>
<li>-Infinity - Infinity,返回-Infinity</li>
<li>+0 - +0，返回+0</li>
<li>+0 - -0，返回-0</li>
<li>-0 - -0，返回+0</li>
<li>若有一个操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后在根据前面的规则执行数学运算。</li>
<li>如果有任一操作数是对象，则调用其 valueof()方法取得表示他的数值。如果对象没有 valueof()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</li>
</ul>
<h4 id="关系操作符">关系操作符</h4>
<ul>
<li>如果操作符都是数值，则执行数值比较</li>
<li>如果操作数是字符串，则逐个比较字符串中对应字符的编码</li>
<li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较</li>
<li>如果有任一操作数是对象，则调用其 valueof()方法取得表示他的数值。如果对象没有 valueof()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</li>
<li>如果有任一操作数是布尔值，则将其转换为数值在执行比较</li>
<li>只要任一操作数为 NaN，均返会 false</li>
</ul>
<h4 id="相等操作符">相等操作符</h4>
<h5 id="等于-与不等于">等于(==)与不等于(!=)</h5>
<ul>
<li>null 与 undefined 不能转换为其他类型的值再进行比较</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">null == undefined</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">“NaN” == NaN</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">5 == NaN</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">NaN == NaN</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">NaN != NaN</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">false == 0</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">true == 1</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">true == 2</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">undefined == 0</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">null == 0</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">“5” == 5</td>
<td style="text-align:left">true</td>
</tr>
</tbody>
</table>
<h5 id="全等-和不全等">全等(===)和不全等(!==)</h5>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result_1 = <span class="string">&quot;55&quot;</span> == <span class="number">55</span>; <span class="comment">//true, 转换后相等</span></span><br><span class="line"><span class="keyword">let</span> result_2 = <span class="string">&quot;55&quot;</span> === <span class="number">55</span>; <span class="comment">//false, 因为数据类型不同</span></span><br></pre></td></tr></table></figure>
<h4 id="条件操作符">条件操作符</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// variable = boolean_expression ? true_value : false_value;</span></span><br><span class="line"><span class="keyword">let</span> max = num1 &gt; num2 ? num1 : num2;</span><br></pre></td></tr></table></figure>
<h4 id="赋值操作符">赋值操作符</h4>
<p><b>“=”</b></p>
<h4 id="逗号操作符">逗号操作符</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>,</span><br><span class="line">  num2 = <span class="number">2</span>,</span><br><span class="line">  num3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">//num = 0</span></span><br></pre></td></tr></table></figure>
<h3 id="语句-2">语句</h3>
<h4 id="if">if</h4>
<blockquote>
<p>if (condition) statement1 else statement2</p>
</blockquote>
<p>这里的条件(condition)可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 Boolean()函数将这个表达式转换为布尔值。</p>
<h4 id="do-while">do-while</h4>
<blockquote>
<p>do { statement } while (expression)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    i += <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;<span class="number">10</span>&gt;);</span><br></pre></td></tr></table></figure>
<h4 id="while">while</h4>
<blockquote>
<p>while (expression) statement</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>&gt;)&#123;</span><br><span class="line">    i += <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="for">for</h4>
<blockquote>
<p>for (initialization; expression; post-loop-expression) statement</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++&gt;)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-in">for-in</h4>
<p>for-in 语句是一种严格的迭代语句，<b>用于枚举对象中的非符号键属性</b></p>
<blockquote>
<p>for (property in expression) statement</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> proName <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(proName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ECMAScript 中对象的属性是无序的，因此 for-in 语句不能保证返回对象属性的顺序</p>
<h4 id="for-of">for-of</h4>
<p>for-of 语句是一种严格的迭代语句，<b>用于遍历可迭代对象的元素</b></p>
<blockquote>
<p>for (property of expression) statement</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>]) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for-of 会按照可迭代对象的 next()方法产生值得顺序迭代元素。</p>
<h4 id="标签-break-continue">标签 &amp; break &amp; continue</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="attr">outermost</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> outermost;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">//95</span></span><br></pre></td></tr></table></figure>
<h4 id="with">with</h4>
<p>不推荐使用<br><br>
使用场景是针对一个对象反复操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.<span class="property">hostname</span>;</span><br><span class="line"><span class="keyword">let</span> url = location.<span class="property">herf</span>;</span><br><span class="line"><span class="comment">// 上方代码等同于</span></span><br><span class="line"><span class="keyword">with</span> (location) &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">  <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch">switch</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    switch(expression)&#123;</span></span><br><span class="line"><span class="comment">        case value1:</span></span><br><span class="line"><span class="comment">            statement</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        case value2:</span></span><br><span class="line"><span class="comment">            statement</span></span><br><span class="line"><span class="comment">            break;</span></span><br><span class="line"><span class="comment">        default:</span></span><br><span class="line"><span class="comment">            statement</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">  <span class="comment">/* 跳过 */</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">35</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;25 或 35&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">45</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;45&quot;</span>);</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* switch语句可以用于所有数据类型，可以使用字符串甚至对象、条件的值不需要是常量，也可以是变量或表达式。 */</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(-∞，0)&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[0,10]&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(10,20]&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;(20,+∞)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>见 <a href="../../../../2021/03/14/Javascript-Function/">Javascript-Function</a></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>HTML-快速参考</title>
    <url>/HTML-Reference/</url>
    <content><![CDATA[<div class="note danger"><p>2020年 刚开始学习时的一个笔记, 非常简陋, 不具有任何参考价值, 参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">MDN. HTML元素参考</a></p>
</div>
<span id="more"></span>
<h2 id="HTML-链接">HTML 链接</h2>
<h3 id="target-属性">target 属性</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;mark_a&quot;</span>&gt;</span>Mark_A<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_blank</td>
<td style="text-align:center">在新窗口中打开被链接文档</td>
<td style="text-align:center">_top</td>
<td style="text-align:center">在整个窗口打开被链接文档</td>
</tr>
<tr>
<td style="text-align:center">_self</td>
<td style="text-align:center">默认，在相同框架中打开被链接文档</td>
<td style="text-align:center">framename</td>
<td style="text-align:center">在指定的框架中打开被链接文档</td>
</tr>
<tr>
<td style="text-align:center">_parent</td>
<td style="text-align:center">在父框架中打开被链接文档</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="电子邮件">电子邮件</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#mark_a&quot;</span>&gt;</span>跳转到Mark_A<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:solo@gmail.com?cc=kinsiy@qq.com&amp;bcc=someone@outlook.com&amp;subject=Hello%20word&amp;body=正文&quot;</span>&gt;</span>发送邮件！<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cc</td>
<td style="text-align:center">抄送</td>
<td style="text-align:center">bcc</td>
<td style="text-align:center">暗送</td>
<td style="text-align:center">subject</td>
<td style="text-align:center">主题</td>
<td style="text-align:center">body</td>
<td style="text-align:center">正文</td>
</tr>
</tbody>
</table>
<h3 id="图片链接">图片链接</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://kinsiy.github.io&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;kinsiy&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alt</td>
<td style="text-align:center">替换文本属性</td>
</tr>
<tr>
<td style="text-align:center">align</td>
<td style="text-align:center">bottom/middle/top 图像行内对齐方式 left/right 浮动图像到那一侧</td>
</tr>
</tbody>
</table>
<h3 id="图像映射">图像映射</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;girl.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;girl&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#grilmap&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;grilmap&quot;</span> <span class="attr">id</span>=<span class="string">&quot;grilmap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;100,150,10&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;baidu&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="ismap">ismap</h4>
<p>ismap 可将图片转换为图像映射。点击图片任意位置访问时在自动在 URL 中添加点击点坐标</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;girl.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">ismap</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="表格">表格</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">frame</span>=<span class="string">&quot;box&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>标题1，横跨两行<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>标题2，横跨两列<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 空格占位符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>数据格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">colspan</td>
<td style="text-align:center">标题横跨列</td>
<td style="text-align:center">rowspan</td>
<td style="text-align:center">标题横跨行</td>
</tr>
<tr>
<td style="text-align:center">cellpadding</td>
<td style="text-align:center">单元格边距</td>
<td style="text-align:center">cellspacing</td>
<td style="text-align:center">单元格间距</td>
</tr>
<tr>
<td style="text-align:center">align</td>
<td style="text-align:center">单元格内对齐</td>
<td style="text-align:center">border</td>
<td style="text-align:center">单元格边框宽度</td>
</tr>
</tbody>
</table>
<h3 id="frame">frame</h3>
<div class="note danger"><p>已被废弃, 参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table#%E5%B1%9E%E6%80%A7">MDN. Table Element</a></p>
</div>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">box</td>
<td style="text-align:center">四周</td>
<td style="text-align:center">above</td>
<td style="text-align:center">上边框</td>
<td style="text-align:center">below</td>
<td style="text-align:center">下边框</td>
<td style="text-align:center">hsides</td>
<td style="text-align:center">上下边框</td>
<td style="text-align:center">vsides</td>
<td style="text-align:center">左右边框</td>
</tr>
</tbody>
</table>
<h2 id="列表">列表</h2>
<h3 id="有序列表">有序列表</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>有序列表4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="无序列表">无序列表</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>无序列表4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义列表">自定义列表</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Java是一种非常强大的语言<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Python<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Python是一种脚本语言<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Javascript<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Javascript也是一种脚本语言<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="块-内联元素">块/内联元素</h2>
<p>大多数 HTML 元素被定义为块级元素或内联元素。<mark class="label primary">“块级元素”</mark>译为 <mark class="label info">block level element</mark>，<mark class="label primary">“内联元素”</mark>译为 <mark class="label info">inline element</mark>。块级元素在浏览器显示时，通常会以新行来开始（和结束）</p>
<h3 id="块元素">块元素</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 块元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>div元素是典型块级元素，它是可用于组合其他 HTML 元素的容器。&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。</p>
<p>&lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt; 元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。</p>
<h3 id="内联元素">内联元素</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span>/&gt;</span><span class="comment">&lt;!-- img 比较特殊 严格来说它并不是内联元素, 但也不是块元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内联元素在显示时通常不会以新行开始。</p>
<p>&lt;span&gt; 元素是典型内联元素，可用作文本的容器。&lt;span&gt; 元素也没有特定的含义。当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。</p>
<h2 id="表单">表单</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">legend</span>&gt;</span>Html边框测试<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;sex&quot;</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;name&quot;</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> /&gt;</span>Male</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span> <span class="attr">checked</span> /&gt;</span>Female</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">checked</span> /&gt;</span>男生</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> /&gt;</span>女生</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>大众<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optgroup</span> <span class="attr">label</span>=<span class="string">&quot;豪车&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>宝马<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> <span class="attr">selected</span>&gt;</span>奔驰<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">optgroup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>东风<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">值</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fieldset</td>
<td style="text-align:center">定义域</td>
<td style="text-align:center">optgroup</td>
<td style="text-align:center">定义选项组</td>
</tr>
<tr>
<td style="text-align:center">legend</td>
<td style="text-align:center">fieldset 元素定义标题。</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="框架">框架</h2>
<p>不能将 &lt;body&gt;&lt;/body&gt; 标签与 &lt;frameset&gt;&lt;/frameset&gt; 标签同时使用！不过，假如你添加包含一段文本的 &lt;noframes&gt; 标签，就必须将这段文字嵌套于 &lt;body&gt;&lt;/body&gt; 标签内。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">rows</span>=<span class="string">&quot;50%,50%&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_a.html&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">&quot;25%,75%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_b.html&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">&quot;frame_c.html&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">noframes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      您的浏览器无法处理框架！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">noframes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 内联框架 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;key.html&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;30%&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="格式化文档">格式化文档</h2>
<h3 id="文本格式化标签">文本格式化标签</h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;b&gt;</td>
<td style="text-align:center">粗体文字</td>
<td style="text-align:center">&lt;em&gt;</td>
<td style="text-align:center">着重文字</td>
<td style="text-align:center">&lt;small&gt;</td>
<td style="text-align:center">小号字</td>
<td style="text-align:center">&lt;sub&gt;</td>
<td style="text-align:center">下标字</td>
<td style="text-align:center">&lt;ins&gt;</td>
<td style="text-align:center">插入字</td>
</tr>
<tr>
<td style="text-align:center">&lt;big&gt;</td>
<td style="text-align:center">大号字</td>
<td style="text-align:center">&lt;i&gt;</td>
<td style="text-align:center">斜体字</td>
<td style="text-align:center">&lt;strong&gt;</td>
<td style="text-align:center">加重语气</td>
<td style="text-align:center">&lt;sup&gt;</td>
<td style="text-align:center">上标字</td>
<td style="text-align:center">&lt;del&gt;</td>
<td style="text-align:center">删除字</td>
</tr>
</tbody>
</table>
<h3 id="计算机输出标签">计算机输出标签</h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;code&gt;</td>
<td style="text-align:center">计算机代码</td>
<td style="text-align:center">&lt;kbd&gt;</td>
<td style="text-align:center">键盘码</td>
<td style="text-align:center">&lt;samp&gt;</td>
<td style="text-align:center">计算机代码样本</td>
</tr>
<tr>
<td style="text-align:center">&lt;tt&gt;</td>
<td style="text-align:center">打字机代码</td>
<td style="text-align:center">&lt;var&gt;</td>
<td style="text-align:center">变量</td>
<td style="text-align:center">&lt;pre&gt;</td>
<td style="text-align:center">预格式文本</td>
</tr>
</tbody>
</table>
<h3 id="引用与术语定义">引用与术语定义</h3>
<table>
<thead>
<tr>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;abbr&gt;</td>
<td style="text-align:center">缩写</td>
<td style="text-align:center">&lt;acronym&gt;</td>
<td style="text-align:center">首字母缩写</td>
<td style="text-align:center">&lt;address&gt;</td>
<td style="text-align:center">地址</td>
<td style="text-align:center">&lt;bdo&gt;</td>
<td style="text-align:center">文字方向</td>
</tr>
<tr>
<td style="text-align:center">&lt;blockquote&gt;</td>
<td style="text-align:center">长引用</td>
<td style="text-align:center">&lt;q&gt;</td>
<td style="text-align:center">短引用</td>
<td style="text-align:center">&lt;cite&gt;</td>
<td style="text-align:center">引用、引证</td>
<td style="text-align:center">&lt;dfn&gt;</td>
<td style="text-align:center">定义项目</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript-错误处理与调试</title>
    <url>/JavaScript-error/</url>
    <content><![CDATA[<h1>Error 对象</h1>
<h2 id="SyntaxError">SyntaxError</h2>
<p>语法不正确。这是因为代码不遵循语言规范。通常因为输入错误导致。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引号不匹配或未闭合</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Howdy&#x27;)</span></span><br></pre></td></tr></table></figure>
<h2 id="ReferenceError">ReferenceError</h2>
<p>变量不存在。这是因为变量未声明或不在作用域内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量未声明</span></span><br><span class="line"><span class="keyword">var</span> width = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> area = width * height;</span><br></pre></td></tr></table></figure>
<h2 id="TypeError">TypeError</h2>
<p>值为意外的数据类型。这通常是因为尝试使用不存在的对象或方法而引起的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法不存在</span></span><br><span class="line"><span class="keyword">var</span> box = &#123;&#125;;</span><br><span class="line">box.<span class="title class_">GetArea</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//DOM节点不存在</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;Name&quot;</span>);</span><br><span class="line">el.<span class="property">innerHTML</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="RangeError">RangeError</h2>
<p>数字在可接受范围之外。使用了可接受范围之外的数字来调用某个函数所致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无法创建长度为-1的数组</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">AnArray</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="URIError">URIError</h2>
<p>没有正确使用 URI 函数。如果 URI 没有对以下字符进行转义，就会导致此错误：/ ? &amp; # : ;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符未转义</span></span><br><span class="line"><span class="built_in">decodeURI</span>(<span class="string">&quot;http://bbc.com/news.php ? a=1&quot;</span>); <span class="comment">// URIError: URI error</span></span><br></pre></td></tr></table></figure>
<h2 id="EvalError">EvalError</h2>
<p>没有正确使用 eval()函数。eval()函数通过解释器来评估文本，并将其作为代码来执行。很少能看到这种类型的错误，因为通常浏览器会在发现 EvalError 时，抛出其他类型错误。</p>
<h2 id="Error">Error</h2>
<p>一般错误类型。一般错误对象是用来创建其他所有错误对象的模板(或原型)。</p>
<h2 id="NAN">NAN</h2>
<p>不是错误。如果使用一个非数字的值来执行数学运算的话，就会得到 NaN 这样的结果，这并不是错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不是数字</span></span><br><span class="line"><span class="keyword">var</span> total = <span class="number">3</span> * <span class="string">&quot;Ivy&quot;</span>;</span><br></pre></td></tr></table></figure>
<h1>console</h1>
<ul>
<li>console.log()</li>
<li><a href="http://console.info">console.info</a>() 用于一般信息</li>
<li>console.warn() 用于警告</li>
<li>console.error() 用于输出错误</li>
<li>console.group() 消息分组 用于输出一组相关数据</li>
<li>console.table() 如果浏览器支持的话可以使用此方法输出表格</li>
<li>console.assert() 根据条件输出</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//console.group()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">group</span>(<span class="string">&quot;Area calculations&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Width &quot;</span>, width);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;Height &quot;</span>, height);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(area);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">groupEnd</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.table()</span></span><br><span class="line"><span class="keyword">var</span> contacts = &#123;</span><br><span class="line">  <span class="title class_">London</span>: &#123;</span><br><span class="line">    <span class="title class_">Tel</span>: <span class="string">&quot;110&quot;</span>,</span><br><span class="line">    <span class="title class_">Country</span>: <span class="string">&quot;UK&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Syfeny</span>: &#123;</span><br><span class="line">    <span class="title class_">Tel</span>: <span class="string">&quot;120&quot;</span>,</span><br><span class="line">    <span class="title class_">Country</span>: <span class="string">&quot;CN&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">Kinsiy</span>: &#123;</span><br><span class="line">    <span class="title class_">Tel</span>: <span class="string">&quot;119&quot;</span>,</span><br><span class="line">    <span class="title class_">Country</span>: <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(contacts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.assert()</span></span><br><span class="line"><span class="keyword">var</span> width, height, area;</span><br><span class="line">width = $(<span class="string">&quot;#width&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">height = $(<span class="string">&quot;#height&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">area = width * height;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">assert</span>($.<span class="title function_">isNumeric</span>(area), <span class="string">&quot;用户输入非数字！&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1>debugger</h1>
<p>使用 debugger 关键字在代码中创建断点。打开开发者工具后，就会自动创建这个断点。可以将 debugger 关键字添加到条件语句中，在满足条件时触发断点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width, height, area;</span><br><span class="line">width = $(<span class="string">&quot;#width&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">height = $(<span class="string">&quot;#height&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">area = width * height;</span><br><span class="line"><span class="keyword">if</span> (area &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>try catch finally</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">response = <span class="string">&#x27; &#123;&quot;deal&quot;: &#123;[&quot;title&quot;: &quot;Javascript错误处理与调试&quot;,...&#x27;</span>        <span class="comment">// Json 串</span></span><br><span class="line"><span class="keyword">if</span> (response)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dealData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(response);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="keyword">var</span> errorMessage = e.<span class="property">name</span> + <span class="string">&quot; &quot;</span> + e.<span class="property">message</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(errorMessage);</span><br><span class="line">        feed.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;em&gt;加载deal数据出错！&lt;/em&gt;&quot;</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">creatElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        link.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;a herf = &#x27;dealerror.html&#x27;&gt;重新加载&lt;/a&gt;&quot;</span>；</span><br><span class="line">        feed.<span class="title function_">appendChild</span>(link);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1>抛出错误</h1>
<p>throw new Error(‘message’)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> height = <span class="string">&quot;Test&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateArea</span>(<span class="params">width, height</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> area = width * height;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(area)) &#123;</span><br><span class="line">      <span class="keyword">return</span> area;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;calculateArea() 入参无效！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">var</span> errorMessage = e.<span class="property">name</span> + <span class="string">&quot; &quot;</span> + e.<span class="property">message</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(erroeMessage);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;无法计算！&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-动画与图形-上</title>
    <url>/Javascript-Animation&amp;Graphics-1/</url>
    <content><![CDATA[<p>图形和动画已经日益成为浏览器中现代 Web 应用程序的必备功能，但实现起来仍然比较困难</p>
<h2 id="早期定时动画">早期定时动画</h2>
<p>以前，在 JavaScript 中创建动画基本上就是使用 setInterval()来控制动画的执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">updateAnimations</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">doAnimation1</span>();</span><br><span class="line">    <span class="title function_">doAnimation2</span>();</span><br><span class="line">    <span class="comment">// 其他任务</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">setInterval</span>(updateAnimations, <span class="number">100</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这种定时动画的问题在于无法准确知晓循环之间的延时。定时间隔必须足够短，这样才能让不同的动画类型都能平滑顺畅，但又要足够长，以便产生浏览器可以渲染出来的变化。一般计算机显示器的屏幕刷新率都是 60Hz，基本上意味着每秒需要重绘 60 次。大多数浏览器会限制重绘频率，使其不超出屏幕的刷新率，这是因为超过刷新率，用户也感知不到。</p>
<span id="more"></span>
<p>因此，实现平滑动画最佳的重绘间隔为 1000 毫秒/60，大约 17 毫秒。以这个速度重绘可以实现最平滑的动画，因为这已经是浏览器的极限了。如果同时运行多个动画，可能需要加以限流，以免 17 毫秒的重绘间隔过快，导致动画过早运行完。</p>
<p>虽然使用 setInterval()的定时动画比使用多个 setTimeout()实现循环效率更高，但也不是没有问题。无论 setInterval()还是 setTimeout()都是不能保证时间精度的。作为第二个参数的延时只能保证何时会把代码添加到浏览器的任务队列，不能保证添加到队列就会立即运行。如果队列前面还有其他任务，那么就要等这些任务执行完再执行。简单来讲，这里毫秒延时并不是说何时这些代码会执行，而只是说到时候会把回调加到任务队列。如果添加到队列后，主线程还被其他任务占用，比如正在处理用户操作，那么回调就不会马上执行。</p>
<h2 id="requestAnimationFrame">requestAnimationFrame</h2>
<p>requestAnimationFrame()方法接收一个参数，此参数是一个要在重绘屏幕前调用的函数。这个函数就是修改 DOM 样式以反映下一次重绘有什么变化的地方。为了实现动画循环，可以把多个 requestAnimationFrame()调用串联起来，就像以前使用 setTimeout()时一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> requestId</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>);</span><br><span class="line"> div.<span class="property">style</span>.<span class="property">width</span> = (<span class="built_in">parseInt</span>(div.<span class="property">style</span>.<span class="property">width</span>, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line"> <span class="keyword">if</span> (div.<span class="property">style</span>.<span class="property">left</span> != <span class="string">&quot;100%&quot;</span>) &#123;</span><br><span class="line"> requestId = <span class="title function_">requestAnimationFrame</span>(updateProgress);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestId = <span class="title function_">requestAnimationFrame</span>(updateProgress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值 requestId 可用来取消回调</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">cancelAnimationFrame</span>(requestId);</span><br></pre></td></tr></table></figure>
<p>传给 requestAnimationFrame()的函数实际上可以接收一个参数，此参数是一个 DOMHighResTimeStamp 的实（比如 performance.now()返回的值），表示下次重绘的时间</p>
<h3 id="结构化动画">结构化动画</h3>
<p>在 requestAnimationFrame 基础上创建一个更通用的动画函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">&#123; timing, draw, duration &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> start = performance.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">time</span>) &#123;</span><br><span class="line">    <span class="comment">// timeFraction 从 0 增加到 1</span></span><br><span class="line">    <span class="keyword">let</span> timeFraction = (time - start) / duration;</span><br><span class="line">    <span class="keyword">if</span> (timeFraction &gt; <span class="number">1</span>) timeFraction = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前动画状态</span></span><br><span class="line">    <span class="keyword">let</span> progress = <span class="title function_">timing</span>(timeFraction);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">draw</span>(progress); <span class="comment">// 绘制</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeFraction &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>animate 函数接受 3 个描述动画的基本参数：</p>
<ul>
<li>
<p>duration：动画总时间，比如 1000。</p>
</li>
<li>
<p>timing(timeFraction)：时序函数，类似 CSS 属性 transition-timing-function，传入一个已过去的时间与总时间之比的小数（0 代表开始，1 代表结束），返回动画完成度（类似 Bezier 曲线中的 y）。<a href="https://cubic-bezier.com/#.17,.67,.83,.67">时序函数对比</a></p>
</li>
<li>
<p>draw(progress)：获取动画完成状态并绘制的函数。值 progress = 0 表示开始动画状态，progress = 1 表示结束状态。这是实际绘制动画的函数</p>
</li>
</ul>
<p>更多信息参考这里 <a href="https://zh.javascript.info/js-animation#jie-gou-hua-dong-hua">javascript 动画</a></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript-动画与图形-下</title>
    <url>/Javascript-Animation&amp;Graphics-2/</url>
    <content><![CDATA[<p>Canvas API 提供了一个通过 JavaScript 和 HTML 的&lt;canvas&gt;元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。</p>
<p>Canvas API 主要聚焦于 2D 图形。而同样使用&lt;canvas&gt;元素的 WebGL API 则用于绘制硬件加速的 2D 和 3D 图形</p>
<span id="more"></span>
<h2 id="基本的画布功能">基本的画布功能</h2>
<p>创建&lt;canvas&gt;元素时至少要设置其 width 和 height 属性，这样才能告诉浏览器在多大面积上绘图。出现在开始和结束标签之间的内容是后备数据，会在浏览器不支持&lt;canvas&gt;元素时显示</p>
<p>与其他元素一样，width 和 height 属性也可以在 DOM 节点上设置，因此可以随时修改。整个元 素还可以通过 CSS 添加样式，并且元素在添加样式或实际绘制内容前是不可见的</p>
<p>可以使用 toDataURL()方法导出元素上的图像。这个方法接收一个参数：要生成图像 的 MIME 类型（与用来创建图形的上下文无关）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  &lt;canvas id=&quot;drawing&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;A drawing of something.&lt;/canvas&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">  <span class="comment">// 取得图像的数据 URI</span></span><br><span class="line">  <span class="keyword">let</span> imgURI = drawing.<span class="title function_">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 显示图片</span></span><br><span class="line">  <span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  image.<span class="property">src</span> = imgURI;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2D-绘图上下文">2D 绘图上下文</h2>
<p>2D 绘图上下文提供了绘制 2D 图形的方法，包括矩形、弧形和路径。2D 上下文的坐标原点(0, 0)在&lt;canvas&gt;元素的左上角。所有坐标值都相对于该点计算，因此 x 坐标向右增长，y 坐标向下增长。默认情况下，width 和 height 表示两个方向上像素的最大值</p>
<h3 id="填充与描边">填充与描边</h3>
<p>2D 上下文有两个基本绘制操作：填充和描边。填充以指定样式（颜色、渐变或图像）自动填充形状，而描边只为图形边界着色。大多数 2D 上下文操作有填充和描边的变体，显示效果取决于两个属性：fillStyle 和 strokeStyle。</p>
<p>这两个属性可以是字符串、渐变对象或图案对象，默认值都为&quot;#000000&quot;。字符串表示颜色值，可以是 CSS 支持的任意格式：名称、十六进制代码、rgb、rgba、hsl 或 hsla。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">  context.<span class="property">strokeStyle</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制矩形">绘制矩形</h3>
<p>矩形是唯一一个可以直接在 2D 绘图上下文中绘制的形状。与绘制矩形相关的方法有 3 个：fillRect()、strokeRect()和 clearRect()。这些方法都接收 4 个参数：矩形 x 坐标、矩形 y 坐标、矩形宽度和矩形高度。这几个参数的单位都是像素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fillRect()方法用于以指定颜色在画布上绘制并填充矩形。填充的颜色使用 fillStyle 属性指定</span></span><br><span class="line">  <span class="comment">// 绘制红色矩形</span></span><br><span class="line">  context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">  context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// strokeRect()方法使用通过 strokeStyle 属性指定的颜色绘制矩形轮廓</span></span><br><span class="line">  <span class="comment">// 绘制半透明蓝色轮廓的矩形</span></span><br><span class="line">  context.<span class="property">strokeStyle</span> = <span class="string">&quot;rgba(0,0,255,0.5)&quot;</span>;</span><br><span class="line">  context.<span class="title function_">strokeRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 clearRect()方法可以擦除画布中某个区域。该方法用于把绘图上下文中的某个区域变透明。</span></span><br><span class="line">  <span class="comment">// 在前两个矩形重叠的区域擦除一个矩形区域</span></span><br><span class="line">  context.<span class="title function_">clearRect</span>(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制路径">绘制路径</h3>
<p>2D 绘图上下文支持很多在画布上绘制路径的方法。通过路径可以创建复杂的形状和线条。要绘制路径，必须首先调用 beginPath()方法以表示要开始绘制新路径。然后，再调用下列方法来绘制路径</p>
<ul>
<li>arc(x, y, radius, startAngle, endAngle, counterclockwise): 以坐标(x ,y)为圆心，以 radius 为半径绘制一条弧线，起始角度为 startAngle，结束角度为 endAngle(都是弧度)。最后一个参数 counterclockwise 表示是否逆时针计算其实角度和结束角度(默认为顺时针)</li>
<li>arcTo(x1, y1, x2, y2, radius): 以给定半径 radius，经由(x1, y1)绘制一条从上一点到(x2, y2)的弧线</li>
<li>bezierCurveTo(c1x, c1y, c2x, c2y, x, y): 以(c1x, c1y)和(c2x, c2y)为控制点，绘制一条从上一点到(x, y)的弧线(三次贝塞尔曲线)</li>
<li>lineTo(x, y): 绘制一条从上一点到(x, y)的直线</li>
<li>moveTo(x, y): 不绘制线条，只把绘制光标移动到(x, y)</li>
<li>quadraticCurveTo(cx, cy, x, y): 以(cx, cy)为控制点，绘制一条从上一点到(x, y)的弧线(二次贝塞尔曲线)</li>
<li>rect(x, y, width, height): 以给定宽度和高度在坐标点(x, y)绘制一个矩形。这个方法与 strokeRect()和 fillRect()的区别在于，它创建的是一条路径，而不是独立的图形</li>
</ul>
<p>创建路径之后，可以使用 closePath()方法绘制一条返回起点的线。如果路径已经完成，则既可 以指定 fillStyle 属性并调用 fill()方法来填充路径，也可以指定 strokeStyle 属性并调用 stroke()方法来描画路径，还可以调用 clip()方法基于已有路径创建一个新剪切区域</p>
<p>路径是 2D 上下文的主要绘制机制，为绘制结果提供了很多控制。因为路径经常被使用，所以也有 一个 isPointInPath()方法，接收 x 轴和 y 轴坐标作为参数。这个方法用于确定指定的点是否在路径 上，可以在关闭路径前随时调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建路径</span></span><br><span class="line"> context.<span class="title function_">beginPath</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 绘制外圆</span></span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 绘制内圆</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">194</span>, <span class="number">100</span>);</span><br><span class="line"> context.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">94</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 绘制分针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 绘制时针</span></span><br><span class="line"> context.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"> context.<span class="title function_">lineTo</span>(<span class="number">35</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 描画路径</span></span><br><span class="line"> context.<span class="title function_">stroke</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断指点的点是否在路径上</span></span><br><span class="line"> <span class="keyword">if</span> (context.<span class="title function_">isPointInPath</span>(<span class="number">100</span>, <span class="number">100</span>)) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Point (100, 100) is in the path.&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绘制文本">绘制文本</h3>
<p>文本和图像混合也是常见的绘制需求，因此 2D 绘图上下文还提供了绘制文本的方法，即 fillText() 和 strokeText()。这两个方法都接收 4 个参数：要绘制的字符串、x 坐标、y 坐标和可选的最大像素 宽度。而且，这两个方法最终绘制的结果都取决于以下 3 个属性</p>
<ul>
<li>font: 以 CSS 语法指定的字体样式、大小、字体族等，比如&quot;10px Arial&quot;</li>
<li>textAlign: 指定文本的对齐方式，可能的值包括&quot;start&quot;、“end”、“left”、“right&quot;和&quot;center”。</li>
<li>textBaseLine: 指定文本的基线，可能的值包括&quot;top&quot;、“hanging”、“middle”、“alphabetic”、“ideological&quot;和&quot;bottom”</li>
</ul>
<p>这些属性都有相应的默认值，因此没必要每次绘制文本时都设置它们。fillText()方法使用 fillStyle 属性绘制文本，而 strokeText()方法使用 strokeStyle 属性。通常，fillText()方法是使用最多的，因为它模拟了在网页中渲染文本</p>
<p>2D 上下文提供了用于辅助确定文本大小的 measureText()方法。这个方法接收一个参数，即要绘制的文本，然后返回一个 TextMetrics 对象。这个返回的对象目前只有一个属性 width，不过将来应该会增加更多度量指标。</p>
<p>measureText()方法使用 font、textAlign 和 textBaseline 属性当前的值计算绘制指定文本后的大小。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fontSize = <span class="number">100</span>;</span><br><span class="line">context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (context.<span class="title function_">measureText</span>(<span class="string">&quot;Hello world!&quot;</span>).<span class="property">width</span> &gt; <span class="number">140</span>) &#123;</span><br><span class="line">  fontSize--;</span><br><span class="line">  context.<span class="property">font</span> = fontSize + <span class="string">&quot;px Arial&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;Hello world!&quot;</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">context.<span class="title function_">fillText</span>(<span class="string">&quot;Font size is &quot;</span> + fontSize + <span class="string">&quot;px&quot;</span>, <span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h3 id="变换">变换</h3>
<p>上下文变换可以操作绘制在画布上的图像。2D 绘图上下文支持所有常见的绘制变换。在创建绘制上下文时，会以默认值初始化变换矩阵，从而让绘制操作如实应用到绘制结果上。对绘制上下文应用变换，可以导致以不同的变换矩阵应用绘制操作，从而产生不同的结果</p>
<ul>
<li>
<p>rotate(angle)：围绕<strong>原点</strong>把图像旋转 angle 弧度。</p>
</li>
<li>
<p>scale(scaleX, scaleY)：通过在 x 轴乘以 scaleX、在 y 轴乘以 scaleY 来缩放图像。scaleX 和 scaleY 的默认值都是 1.0。</p>
</li>
<li>
<p>translate(x, y)：把原点移动到(x, y)。执行这个操作后，坐标(0, 0)就会变成(x, y)。</p>
</li>
<li>
<p>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：像下面这样通过矩阵乘法直接修改矩阵。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><msub><mn>1</mn><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><msub><mn>1</mn><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>x</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><msub><mn>2</mn><mn>1</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>m</mi><msub><mn>2</mn><mn>2</mn></msub></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>y</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{matrix}
   m1_1 &amp; m1_2 &amp; dx \\
   m2_1 &amp; m2_2 &amp; dy \\
   0 &amp; 0 &amp; 1
\end{matrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6000000000000005em;vertical-align:-1.5500000000000007em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：把矩阵重置为默认值，再以传入的参数调用 transform()</p>
</li>
</ul>
<p>所有这些变换，包括 fillStyle 和 strokeStyle 属性，会一直保留在上下文中，直到再次修改它们。虽然没有办法明确地将所有值都重置为默认值，但有两个方法可以帮我们跟踪变化。如果想着什么时候再回到当前的属性和变换状态，可以调用 save()方法。调用这个方法后，所有这一时刻的设置会被放到一个暂存栈中。保存之后，可以继续修改上下文。而在需要恢复之前的上下文时，可以调用 restore()方法。这个方法会从暂存栈中取出并恢复之前保存的设置。多次调用 save()方法可以在暂存栈中存储多套设置，然后通过 restore()可以系统地恢复</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">context.<span class="title function_">save</span>();</span><br><span class="line"></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#00ff00&quot;</span>;</span><br><span class="line">context.<span class="title function_">translate</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">context.<span class="title function_">save</span>();</span><br><span class="line"></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#0000ff&quot;</span>;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制蓝色矩形</span></span><br><span class="line"></span><br><span class="line">context.<span class="title function_">restore</span>();</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(100, 100)绘制绿色矩形</span></span><br><span class="line"></span><br><span class="line">context.<span class="title function_">restore</span>();</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>); <span class="comment">// 在(0, 0)绘制红色矩形</span></span><br></pre></td></tr></table></figure>
<h3 id="绘制图像">绘制图像</h3>
<p>2D 绘图上下文内置支持操作图像。如果想把现有图像绘制到画布上，可以使用 drawImage()方法。这个方法可以接收 3 组不同的参数，并产生不同的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取了文本中的第一个图像，然后在画布上的坐标(10, 10)处将它绘制了出来</span></span><br><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像会缩放到 20 像素宽、30 像素高</span></span><br><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">50</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  要绘制的图像、源图像 x 坐标、源图像 y 坐标、源图像宽度、源图像高度、目标区域 x 坐标、目标区域 y 坐标、目标区域宽度和目标区域高度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">context.<span class="title function_">drawImage</span>(image, <span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">40</span>, <span class="number">60</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  原始图像中只有一部分会绘制到画布上。</span></span><br><span class="line"><span class="comment">  这一部分从(0, 10)开始，50 像素宽、50 像素高。</span></span><br><span class="line"><span class="comment">  而绘制到画布上时，会从(0, 100)开始，变成 40 像素宽、60 像素高</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="阴影">阴影</h3>
<p>2D 上下文可以根据以下属性的值自动为已有形状或路径生成阴影。</p>
<ul>
<li>shadowColor：CSS 颜色值，表示要绘制的阴影颜色，默认为黑色。</li>
<li>shadowOffsetX：阴影相对于形状或路径的 x 坐标的偏移量，默认为 0。</li>
<li>shadowOffsetY：阴影相对于形状或路径的 y 坐标的偏移量，默认为 0。</li>
<li>shadowBlur：像素，表示阴影的模糊量。默认值为 0，表示不模糊</li>
</ul>
<h3 id="渐变">渐变</h3>
<p>渐变通过 CanvasGradient 的实例表示，在 2D 上下文中创建和修改都非常简单。要创建一个新的 线性渐变，可以调用上下文的 createLinearGradient()方法。这个方法接收 4 个参数：起点 x 坐标、 起点 y 坐标、终点 x 坐标和终点 y 坐标。调用之后，该方法会以指定大小创建一个新的 CanvasGradient 对象并返回实例</p>
<p>有了 gradient 对象后，接下来要使用 addColorStop()方法为渐变指定色标。这个方法接收两 个参数：色标位置和 CSS 颜色字符串。色标位置通过 0 ～ 1 范围内的值表示，0 是第一种颜色，1 是最后 一种颜色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.<span class="title function_">createLinearGradient</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>径向渐变（或放射性渐变）要使用 createRadialGradient()方法来创建。这个方法接收 6 个参数，分别对应两个圆形圆心的坐标和半径。前 3 个参数指定起点圆形中心的 x、y 坐标和半径，后 3 个参数指定终点圆形中心的 x、y 坐标和半径。在创建径向渐变时，可以把两个圆形想象成一个圆柱体的两个圆形表面。把一个表面定义得小一点，另一个定义得大一点，就会得到一个圆锥体。然后，通过移动两个圆形的圆心，就可以旋转这个圆锥体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gradient = context.<span class="title function_">createRadialGradient</span>(<span class="number">55</span>, <span class="number">55</span>, <span class="number">10</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">30</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 绘制渐变矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h3 id="图案">图案</h3>
<p>图案是用于填充和描画图形的重复图像。要创建新图案，可以调用 createPattern()方法并传入两个参数：一个 HTML &lt;img&gt;元素和一个表示该如何重复图像的字符串。第二个参数的值与 CSS 的 background-repeat 属性是一样的，包括&quot;repeat&quot;、“repeat-x”、“repeat-y&quot;和&quot;no-repeat”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">et image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>],</span><br><span class="line"> pattern = context.<span class="title function_">createPattern</span>(image, <span class="string">&quot;repeat&quot;</span>);</span><br><span class="line"><span class="comment">// 绘制矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = pattern;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">150</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<h3 id="图像数据">图像数据</h3>
<p>2D 上下文中比较强大的一种能力是可以使用 getImageData()方法获取原始图像数据。这个方法 接收 4 个参数：要取得数据中第一个像素的左上角坐标和要取得的像素宽度及高度</p>
<p>返回的对象是一个 ImageData 的实例。每个 ImageData 对象都包含 3 个属性：width、height 和 data，其中，data 属性是包含图像的原始像素信息的数组。每个像素在 data 数组中都由 4 个值表 示，分别代表红、绿、蓝和透明度值。换句话说，第一个像素的信息包含在第 0 到第 3 个值中</p>
<p>过更改图像数据可以创建一个简单的灰阶过滤器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drawing = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;drawing&quot;</span>);</span><br><span class="line"><span class="comment">// 确保浏览器支持&lt;canvas&gt;</span></span><br><span class="line"><span class="keyword">if</span> (drawing.<span class="property">getContext</span>) &#123;</span><br><span class="line"> <span class="keyword">let</span> context = drawing.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>),</span><br><span class="line"> image = <span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>],</span><br><span class="line"> imageData, data,</span><br><span class="line"> i, len, average,</span><br><span class="line"> red, green, blue, alpha;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 绘制图像</span></span><br><span class="line"> context.<span class="title function_">drawImage</span>(image, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 取得图像数据</span></span><br><span class="line"> imageData = context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, image.<span class="property">width</span>, image.<span class="property">height</span>);</span><br><span class="line"> data = imageData.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>, len=data.<span class="property">length</span>; i &lt; len; i+=<span class="number">4</span>) &#123;</span><br><span class="line"> red = data[i];</span><br><span class="line"> green = data[i+<span class="number">1</span>];</span><br><span class="line"> blue = data[i+<span class="number">2</span>];</span><br><span class="line"> alpha = data[i+<span class="number">3</span>];</span><br><span class="line"> <span class="comment">// 取得 RGB 平均值</span></span><br><span class="line"> average = <span class="title class_">Math</span>.<span class="title function_">floor</span>((red + green + blue) / <span class="number">3</span>);</span><br><span class="line"> <span class="comment">// 设置颜色，不管透明度</span></span><br><span class="line"> data[i] = average;</span><br><span class="line"> data[i+<span class="number">1</span>] = average;</span><br><span class="line"> data[i+<span class="number">2</span>] = average;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将修改后的数据写回 ImageData 并应用到画布上显示出来</span></span><br><span class="line"> imageData.<span class="property">data</span> = data;</span><br><span class="line"> context.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合成">合成</h3>
<p>2D 上下文中绘制的所有内容都会应用两个属性：globalAlpha 和 globalComposition Operation，其中，globalAlpha 属性是一个范围在 0~1 的值（包括 0 和 1），用于指定所有绘制内容的透明度，默认值为 0。如果所有后来的绘制都需要使用同样的透明度，那么可以将 globalAlpha 设置为适当的值，执行绘制，然后再把 globalAlpha 设置为 0</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制红色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;#ff0000&quot;</span>;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改全局透明度</span></span><br><span class="line">context.<span class="property">globalAlpha</span> = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制蓝色矩形</span></span><br><span class="line">context.<span class="property">fillStyle</span> = <span class="string">&quot;rgba(0,0,255,1)&quot;</span>;</span><br><span class="line">context.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置</span></span><br><span class="line">context.<span class="property">globalAlpha</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>globalCompositionOperation 属性表示新绘制的形状如何与上下文中已有的形状融合。这个属性是一个字符串，可以取下列值</p>
<ul>
<li>source-over：默认值，新图形绘制在原有图形上面。</li>
<li>source-in：新图形只绘制出与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li>source-out：新图形只绘制出不与原有图形重叠的部分，画布上其余部分全部透明。</li>
<li>source-atop：新图形只绘制出与原有图形重叠的部分，原有图形不受影响。</li>
<li>destination-over：新图形绘制在原有图形下面，重叠部分只有原图形透明像素下的部分可见。</li>
<li>destination-in：新图形绘制在原有图形下面，画布上只剩下二者重叠的部分，其余部分完全透明。</li>
<li>destination-out：新图形与原有图形重叠的部分完全透明，原图形其余部分不受影响。</li>
<li>destination-atop：新图形绘制在原有图形下面，原有图形与新图形不重叠的部分完全透明。</li>
<li>lighter：新图形与原有图形重叠部分的像素值相加，使该部分变亮。</li>
<li>copy：新图形将擦除并完全取代原有图形。</li>
<li>xor：新图形与原有图形重叠部分的像素执行“异或”计</li>
</ul>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript-Array</title>
    <url>/Javascript-Array/</url>
    <content><![CDATA[<blockquote>
<p>数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式</p>
<p>——MDN. Array</p>
</blockquote>
<span id="more"></span>
<h2 id="数组基础">数组基础</h2>
<h3 id="创建数组">创建数组</h3>
<p>创建数组时可以给构造函数传入一个值，如果这个值是数值，会创建一个长度为指定数值的数组。如果这个值是其他类型的，会创建一个只包含该特定值的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用Array构造函数 */</span></span><br><span class="line"><span class="keyword">let</span> colors_1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">20</span>); <span class="comment">// 创建一个初始length为20的数组</span></span><br><span class="line"><span class="keyword">let</span> colors_2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用数组字面量 */</span></span><br><span class="line"><span class="keyword">let</span> colors_3 = [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态方法from()、of()</span></span><br><span class="line"><span class="comment">    from()用于将类数组结构转换为数组实例</span></span><br><span class="line"><span class="comment">    of()用于将一组参数转换为数组实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;Kinsiy&quot;</span>)); <span class="comment">// [&quot;K&quot;,&quot;i&quot;,&quot;n&quot;,&quot;s&quot;,&quot;i&quot;,&quot;y&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">3</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">5</span>).<span class="title function_">add</span>(<span class="number">6</span>).<span class="title function_">add</span>(<span class="number">8</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(m)); <span class="comment">// [[1,3], [2,4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(s)); <span class="comment">// [5, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅复制</span></span><br><span class="line"><span class="keyword">const</span> arr_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr_2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_2); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1 === arr_2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换arguments 对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArgsArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArgsArray</span>(<span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// [8, 9, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()可以接收第二个可选的映射函数参数。</span></span><br><span class="line"><span class="comment">// 还可以接收第三个可选参数, 用于指定映射函数中this的值。(在剪头函数中不适用)</span></span><br><span class="line"><span class="keyword">const</span> arr_3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr_4 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr_3, <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x ** <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> arr_5 = <span class="title class_">Array</span>.<span class="title function_">from</span>(</span><br><span class="line">  arr_3,</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x ** <span class="variable language_">this</span>.<span class="property">exponent</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">exponent</span>: <span class="number">3</span> &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_3); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_4); <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_5); <span class="comment">// [1, 8, 27, 64]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Array.of() 可以把一组参数转换为数组 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="string">&quot;K&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;f&quot;</span>)); <span class="comment">// [&quot;K&quot;,&quot;i&quot;,&quot;n&quot;,&quot;s&quot;,&quot;i&quot;,&quot;f&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>)); <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组空位">数组空位</h3>
<p>使用数组字面量初始化数组时，可以使用一串逗号来创建空位(hole).ECMAScript 会将逗号之间相应的索引位置的值当成空位。ES6 新增方法普遍将这些空位当成存在的元素，只不过值是 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">5</span>, , , , <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(options)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(val === <span class="literal">undefined</span>); <span class="comment">// false true true true false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 undefined 值替代</p>
<h3 id="数组索引">数组索引</h3>
<p>数组中最后一个元素的索引始终是 length-1，因此下一个新增槽位的索引就是 length。每次在数组最后一个元素后面新增一项，数组的 length 属性都会自动更新。注意 length 不是只读的，可以通过修改 length 的值删除数组元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr_1 = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">88</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1); <span class="comment">// [5,7,9,3,15,88]</span></span><br><span class="line"></span><br><span class="line">arr_1.<span class="property">length</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1); <span class="comment">// [5,7,9,3,15]</span></span><br><span class="line"></span><br><span class="line">arr_1[arr_1.<span class="property">length</span>] = <span class="number">99</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1); <span class="comment">// [5,7,9,3,15,99]</span></span><br></pre></td></tr></table></figure>
<h3 id="检测数组">检测数组</h3>
<p>通用方法 Array.isArray()。在之有一个网页(只有一个全局作用域)的情况下，可以使用 instanceof。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">    <span class="comment">// doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="API">API</h2>
<h3 id="Array-prototype-keys">Array.prototype.keys()</h3>
<p>返回数组索引的<strong>迭代器</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr_1 = [<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Javascript&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr_1Key = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr_1.<span class="title function_">keys</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1Key); <span class="comment">// [0,1,2,3,4]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-values">Array.prototype.values()</h3>
<p>返回数组元素的<strong>迭代器</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr_1Values = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr_1.<span class="title function_">values</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1Values); <span class="comment">// [&quot;Java&quot;,&quot;Javascript&quot;,&quot;Python&quot;,&quot;C&quot;,&quot;C++&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-entries">Array.prototype.entries()</h3>
<p>返回索引/值的<strong>迭代器</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr_1Entries = <span class="title class_">Array</span>.<span class="title function_">from</span>(arr_1.<span class="title function_">entries</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1Entries); <span class="comment">// [[0,&quot;Java&quot;], [1,&quot;Javascript&quot;], [2,&quot;Python&quot;], [3,&quot;C&quot;], [4,&quot;C++&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [i, e] <span class="keyword">of</span> arr_1.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`i: <span class="subst">$&#123;i&#125;</span>    e: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i: 0    e: Java</span></span><br><span class="line"><span class="comment">// i: 1    e: Javascript</span></span><br><span class="line"><span class="comment">// i: 2    e: Python</span></span><br><span class="line"><span class="comment">// i: 3    e: C</span></span><br><span class="line"><span class="comment">// i: 4    e: C++</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-fill">Array.prototype.fill()</h3>
<mark class="label primary">fill()</mark> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。返回修改后的数组
<div class="note info"><p>arr.fill(value, [start=0], [end=array.length])</p>
</div>
<p><strong>value(*):</strong>  用来填充数组元素的值</p>
<p><strong>[start=0](number):</strong>  起始索引，如果是负数，将从末尾开始计算</p>
<p><strong>[end=array.length](number):</strong>  终止索引(不包含)，如果是负数，将从末尾开始计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">8</span>, <span class="number">2</span>, -<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 8, 8, 0, 0]</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>); <span class="comment">// 反向索引，忽略</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes); <span class="comment">// [0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-copyWithin">Array.prototype.copyWithin()</h3>
<mark class="label primary">copyWithin()</mark>会按照指定范围浅复制数组中的部分内容，然后将他们插入到指定索引开始的位置，并返回修改后的数组。
<div class="note info"><p>arr.copyWithin(target, [start=0], [end=array.length]])</p>
</div>
<p><strong>target(number):</strong> 复制序列到该位置，如果是负数，将从末尾开始计算。</p>
<p>如果 <mark class="label primary">target</mark> 大于等于 <mark class="label primary">arr.length</mark>，将会不发生拷贝。如果 <mark class="label primary">target</mark> 在 <mark class="label primary">start</mark> 之后，复制的序列将被修改以符合 <mark class="label primary">arr.length</mark></p>
<p><strong>[start=0](number):</strong> 复制起始索引，如果是负数，将从末尾开始计算</p>
<p><strong>[end=array.length](number):</strong> 终止索引(不包含)，如果是负数，将从末尾开始计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inst,</span><br><span class="line">  reset = <span class="function">() =&gt;</span> (inst = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">inst.<span class="title function_">copyWithin</span>(<span class="number">4</span>); <span class="comment">// 从inst中复制从0开始的内容插入到索引为4开始的位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inst); <span class="comment">// [9, 8, 7, 6, 9]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"></span><br><span class="line">inst.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 从inst 中复制从1开始的内容插入到从索引0开始的位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inst); <span class="comment">// [8, 7, 6, 5, 5]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"></span><br><span class="line">inst.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">0</span>, -<span class="number">3</span>); <span class="comment">// 从inst中复制从0开始到索引1结束的内容到索引2开始的位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inst); <span class="comment">// [9, 8, 9, 8, 5]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-join">Array.prototype.join()</h3>
<mark class="label primary">join()</mark> 方法将一个数组（或一个[类数组对象](https://developer.mozilla.org/zh-CN_docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects)）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符
<div class="note info"><p>arr.join([separator])</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;^&quot;</span>)); <span class="comment">// red^blue^pink^yellow</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-push">Array.prototype.push()</h3>
<mark class="label primary">push()</mark>方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。
<div class="note info"><p>arr.push(element1, …, elementN)</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [];</span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: pink,yellow      count: 2</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-pop">Array.prototype.pop()</h3>
<mark class="label primary">pop()</mark>方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。
<div class="note info"><p>arr.pop()</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">count = colors.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: pink      count: yellow</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-shift">Array.prototype.shift()</h3>
<mark class="label primary">shift()</mark>方法删除数组的第一项并返回它，然后数组长度减一
<div class="note info"><p>arr.shift()</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [];</span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;pink&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;bule&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: pink,black,bule      count: 3</span></span><br><span class="line"></span><br><span class="line">count = colors.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: black,bule      count: pink</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-unshift">Array.prototype.unshift()</h3>
<mark class="label primary">unshift()</mark>在数组开头添加任意多个值，然后返回新的数组长度, 使用unshift()和pop()可以在相反方向上模拟队列
<div class="note info"><p>arr.unshift(element1, …, elementN)</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: yellow,green,black,bule      count: 4</span></span><br><span class="line"></span><br><span class="line">count = colors.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>      count: <span class="subst">$&#123;count&#125;</span>`</span>); <span class="comment">// colors: yellow,green,black      count: bule</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-reverse">Array.prototype.reverse()</h3>
<mark class="label primary">reverse()</mark> 方法将数组中元素的位置颠倒，并返回调用它的数组的引用
<div class="note info"><p>arr.reverse()</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr_1 = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">12</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1.<span class="title function_">reverse</span>()); <span class="comment">// [12, 4, 1, 6, 5, 7]     仅是反向，不会比较</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-sort">Array.prototype.sort()</h3>
<div class="note info"><p>arr.sort([compareFunction])</p>
</div>
<mark class="label primary">sort()</mark> 方法用[原地算法](https://en.wikipedia.org/wiki/In-place_algorithm)对数组的元素进行排序，并返回调用它的数组的引用。sort()会把数组转换为字符串再进行比较，在比较数值时不合适为此sort()可以接收一个比较方法比较函数接收两个参数，如果value_1 < value_2，返回负值，value_1 = value_2，返回0，value_1 > value_2, 返回正值。若需降序，交换正负值即可
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr_1 = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">12</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1.<span class="title function_">sort</span>()); <span class="comment">// [1, 12, 4, 5, 6, 7]     默认转字符串后按升序排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value_1, value_2</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> value_1 &lt; <span class="attr">value_2</span>:</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> value_1 &gt; <span class="attr">value_2</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1.<span class="title function_">sort</span>(compare)); <span class="comment">// [1, 4, 5, 6, 7, 12]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-concat">Array.prototype.concat()</h3>
<mark class="label primary">concat()</mark> 方法可以在现有数组全部元素基础上创建一个新数组。
<div class="note info"><p>var new_array = old_array.concat([value])</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors_1 = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;green&quot;</span>, <span class="string">&quot;black&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors_2 = colors_1.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, newColors);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors_1); <span class="comment">// [&quot;red&quot;, &quot;pink&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="comment">// 默认打平数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors_2); <span class="comment">// [&quot;red&quot;, &quot;pink&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> colors_3 = colors_1.<span class="title function_">concat</span>(<span class="string">&quot;purple&quot;</span>, newColors);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors_3); <span class="comment">// [&quot;red&quot;, &quot;pink&quot;, &quot;blue&quot;, &quot;purple&quot;, [&quot;green&quot;,&quot;black&quot;]]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-slice">Array.prototype.slice()</h3>
<mark class="label primary">slice()</mark>用于数组切片，接收一个或两个参数：切片的开始索引与结束索引。支持负索引，不包含结束索引元素
<div class="note info"><p>arr.slice([start=0], [end=array.length])</p>
</div>
<p><strong>[start=0](number):</strong> 起始索引，如果是负数，将从末尾开始计算</p>
<p><strong>[end=array.length](number):</strong> 终止索引(不包含)，如果是负数，将从末尾开始计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors_1 = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors_2 = colors_1.<span class="title function_">slice</span>(<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors_2); <span class="comment">// [&quot;pink&quot;, &quot;black&quot;, &quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-splice">Array.prototype.splice()</h3>
<mark class="label primary">splice()</mark>的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。
<ul>
<li><b>删除。</b> 需要给 splice() 传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0,2)会删除前两个元素。</li>
<li><b>插入。</b> 需要给 splice() 传 3 个参数： 开始位置，0(要删除的元素数量)和要插入的元素，可以在数组中删除指定的位置插入元素。第三个元素之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2,0,“pink”,“purple”)会从数组位置 2 开始插入字符串&quot;pink&quot;和&quot;purple&quot;</li>
<li><b>替换。</b> splice()在删除元素的同时可以在指定位置插入新元素，同样需要传入 3 个参数: 开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定要跟删除的元素数量一致。比如，splice(2, 1, “red”, “green”)会在位置 2 删除一个元素，然后从该位置开始向数组中插入&quot;red&quot;和&quot;green&quot;</li>
</ul>
<div class="note info"><p>array.splice(start[, deleteCount[, item1[, item2[, …]]]])</p>
</div>
<p><strong>start[Number]:</strong> 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于<mark class="label primary">array.length-n</mark>）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。</p>
<p><strong>deleteCount[Number]:</strong> 整数，表示要移除的数组元素的个数。</p>
<p><strong>item1, item2, …:</strong> 要添加进数组的元素,从<mark class="label primary">start</mark> 位置开始。如果不指定，则 <mark class="label primary">splice()</mark> 将只删除数组元素</p>
<p>返回由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">let</span> result = colors.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>     result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// colors: pink,yellow,blue,purple     result: red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">result = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;black&quot;</span>, <span class="string">&quot;greed&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>     result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// colors: pink,black,greed,yellow,blue,purple     result:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">result = colors.<span class="title function_">splice</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;white&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`colors: <span class="subst">$&#123;colors&#125;</span>     result: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// colors: pink,black,greed,yellow,orange,white,purple     result: blue</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-indexOf">Array.prototype.indexOf()</h3>
<mark class="label primary">indexOf()</mark>方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。
<div class="note info"><p>arr.indexOf(value, [fromIndex=0])</p>
</div>
<p><strong>value (*):</strong> 要查找的元素</p>
<p><strong>[fromIndex=0] (number):</strong> 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">indexOf</span>(<span class="number">4</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">indexOf</span>(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> otherPeople = [person];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">indexOf</span>(person)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherPeople.<span class="title function_">indexOf</span>(person)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-lastIndexOf">Array.prototype.lastIndexOf()</h3>
<mark class="label primary">lastIndexOf()</mark> 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 <mark class="label primary">fromIndex</mark> 处开始。
<div class="note info"><p>arr.lastIndexOf(value, [fromIndex=arr.length-1])</p>
</div>
<p><strong>value (*):</strong> 要查找的元素</p>
<p><strong>[fromIndex=arr.length-1] (number):</strong> 从此位置开始逆向查找. 如果为负值，将其视为从数组末尾向前的偏移</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-includes">Array.prototype.includes()</h3>
<mark class="label primary">includes()</mark>返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等(===)比较，也就是说两者必须严格相等。
<div class="note info"><p>arr.includes(valueToFind, [fromIndex=0])</p>
</div>
<p><strong>valueToFind(*):</strong> 需要查找的元素值</p>
<p><strong>[fromIndex=0](Number):</strong> 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> otherPeople = [person];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">indexOf</span>(person)); <span class="comment">// -1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherPeople.<span class="title function_">indexOf</span>(person)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">includes</span>(person)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherPeople.<span class="title function_">includes</span>(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="find-findIndex">find() &amp; findIndex()</h3>
<p>ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。<br>
断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示匹配。<br>
find()和 findIndex()方法使用了断言函数。这两个方法都是从数组的最小索引开始，find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也可都可以接收第二个可选的参数用于指定断言函数内部 this 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Restituo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">e, i, arr</span>) =&gt;</span> e.<span class="property">age</span> &gt; <span class="number">20</span>)); <span class="comment">// &#123;name: &quot;Restituo&quot;, age: 22&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">e, i, arr</span>) =&gt;</span> e.<span class="property">age</span> &gt; <span class="number">20</span>)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到匹配项后，这两个方法都不在继续搜索</span></span><br><span class="line"><span class="keyword">const</span> arr_1 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr_1.<span class="title function_">find</span>(<span class="function">(<span class="params">e, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line">  <span class="keyword">return</span> e === <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="every-filter-forEach-map-some">every() &amp; filter() &amp; forEach() &amp; map() &amp; some()</h3>
<p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象。传个每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。</p>
<ul>
<li><b>every():</b> 对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。</li>
<li><b>filter():</b> 对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。</li>
<li><b>forEach():</b> 对数组每一项都运行传入的函数，没有返回值</li>
<li><b>map():</b> 对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组</li>
<li><b>some():</b> 对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。</li>
</ul>
<p>这些方法都不改变调用他们的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="keyword">let</span> result = num.<span class="title function_">every</span>(<span class="function">(<span class="params">e, i, a</span>) =&gt;</span> e &gt; <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">result = num.<span class="title function_">some</span>(<span class="function">(<span class="params">e, i, a</span>) =&gt;</span> e &gt; <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">result = num.<span class="title function_">filter</span>(<span class="function">(<span class="params">e, i, a</span>) =&gt;</span> e &gt; <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">result = num.<span class="title function_">map</span>(<span class="function">(<span class="params">e, i, a</span>) =&gt;</span> e ** <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br><span class="line"></span><br><span class="line">num.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e, i, a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`i: <span class="subst">$&#123;i&#125;</span>    e: <span class="subst">$&#123;e&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// i: 0    e: 1</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// i: 8    e: 9</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-reduce">Array.prototype.reduce()</h3>
<p>ECMAScript 为数组提供两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()从第一项归并到最后一项,reduceRight()反之。</p>
<p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 reduce()和 reduceRight()的函数接收四个参数：上一个归并值、当前值、当前值得索引、和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个函数传入可选的第二个参数(作为归并起点值)，则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">sum = values.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur, -<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><p>第二个值不是索引值，并不是说从索引处开始归并，而是归并初始值。比如要求和，是在求和前先加这个初始值。</p>
</div>
<h3 id="Object-prototype-valueof">Object.prototype.valueof()</h3>
<mark class="label primary">valueof()</mark>返回数组本身。
<div class="note info"><p>obj.valueOf()</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">valueOf</span>()); <span class="comment">// [&quot;red&quot;,&quot;blue&quot;,&quot;pink&quot;,&quot;yellow&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-prototype-toString">Object.prototype.toString()</h3>
<mark class="label primary">toString()</mark>返回由数组中每个值得等效字符串拼接而成的一个逗号分隔的字符串。
<div class="note info"><p>obj.toString()</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;pink&quot;</span>, <span class="string">&quot;yellow&quot;</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">toString</span>()); <span class="comment">// red,bule,pink,yellow</span></span><br><span class="line"><span class="title function_">alert</span>(colors); <span class="comment">// red,bule,pink,yellow     alert()期待字符串，后台调用toString()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = &#123;</span><br><span class="line">  <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_2 = &#123;</span><br><span class="line">  <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Type57&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people = [person_1, person_2];</span><br><span class="line"><span class="title function_">alert</span>(people); <span class="comment">// Kinsiy Type57</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">toString</span>()); <span class="comment">// Kinsiy Type57</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">toLocaleString</span>()); <span class="comment">// Kinsiy Restituo</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-Security-Headers</title>
    <url>/HTTP-security-headers/</url>
    <content><![CDATA[<h2 id="Content-Security-Policy-CSP">Content Security Policy (CSP)</h2>
<blockquote>
<p>内容安全策略  (<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">XSS (en-US)</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p>
<p>CSP 被设计成完全向后兼容（除CSP2 在向后兼容有明确提及的不一致; 更多细节查看<a href="https://www.w3.org/TR/CSP2">这里</a>）。不支持CSP的浏览器也能与实现了CSP的服务器正常合作，反之亦然：不支持 CSP 的浏览器只会忽略它，如常运行，默认为网页内容使用标准的同源策略。如果网站不提供 CSP 头部，浏览器也使用标准的<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">同源策略</a>。</p>
<p><strong>为使CSP可用, 你需要配置你的网络服务器返回  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><mark class="label primary">Content-Security-Policy</mark></a> HTTP头部</strong></p>
<p>( 有时你会看到一些关于<mark class="label primary">X-Content-Security-Policy</mark>头部的提法, 那是旧版本，你无须再如此指定它)。</p>
<p><strong>除此之外, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta"><mark class="label primary">&lt;meta&gt;</mark></a>元素也可以被用来配置该策略</strong></p>
<p>——MDN. 内容安全策略( CSP ).</p>
</blockquote>
<span id="more"></span>
<h3 id="语法及指令">语法及指令</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27;; img-src https://*; child-src &#x27;none&#x27;;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一个策略由一系列策略指令组成，每个策略指令都描述了一个针对某个特定类型资源以及生效范围的策略。</li>
<li>default-src 是 CSP 指令，多个指令之间使用英文分号分割。</li>
<li>self 是指令值，多个指令值用英文空格分割</li>
</ul>
<p>具体语法及指令及其意义可以参考这里 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><mark class="label info">MDN. Content-Security-Policy.</mark> </a></p>
<p>更多详细配置方案可以参考这里 <a href="https://web.dev/security-headers/"><mark class="label info">web.dev Security headers quick reference</mark></a></p>
<h3 id="strict-CSP">strict CSP</h3>
<p>可以使用以下两种方式启用严格CSP</p>
<ul>
<li>如果HTML在服务端渲染，选用 <mark class="label primary">nonce-based strict CSP</mark></li>
<li>如果HTML必须静态提供或缓存，例如单页面富应用，选用 <mark class="label primary">hash-based strict CSP</mark></li>
</ul>
<h4 id="nonce-based">nonce-based</h4>
<div class="note warning"><p>nonce 是一个只使用一次的随机数。nonce-based strict CSP 只在能为每次响应生成不同的nonce的情况下是安全的。如果做不到选用hash-based strict CSP</p>
</div>
<p>服务器配置</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>:</span><br><span class="line">  script-src &#x27;nonce-&#123;RANDOM1&#125;&#x27; &#x27;strict-dynamic&#x27; https: &#x27;unsafe-inline&#x27;;</span><br><span class="line">  object-src &#x27;none&#x27;;</span><br><span class="line">  base-uri &#x27;none&#x27;;</span><br></pre></td></tr></table></figure>
<p>HTML文件中，需要为所有&lt;script&gt;标签添加相同值 <mark class="label primary">{RANDOM1}</mark> 字符串的nonce属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">&quot;&#123;RANDOM1&#125;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/script1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">&quot;&#123;RANDOM1&#125;&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// Inline scripts can be used with the &#123;% label primary@nonce %&#125; attribute.</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="hash-based">hash-based</h4>
<p>服务器配置</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>:</span><br><span class="line">  script-src &#x27;sha256-&#123;HASH1&#125;&#x27; &#x27;sha256-&#123;HASH2&#125;&#x27; &#x27;strict-dynamic&#x27; https: &#x27;unsafe-inline&#x27;;</span><br><span class="line">  object-src &#x27;none&#x27;;</span><br><span class="line">  base-uri &#x27;none&#x27;;</span><br></pre></td></tr></table></figure>
<p>HTML文件中，需要把所有的js文件写在&lt;script&gt;标签中(inline)，因为大多数浏览器都不支持对外部引用脚本进行哈希</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">...<span class="comment">// your script1, inlined</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">...<span class="comment">// your script2, inlined</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以动态引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> scripts = [ <span class="string">&#x27;https://example.org/foo.js&#x27;</span>, <span class="string">&#x27;https://example.org/bar.js&#x27;</span>];</span></span><br><span class="line"><span class="language-javascript">scripts.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">scriptUrl</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  s.<span class="property">src</span> = scriptUrl;</span></span><br><span class="line"><span class="language-javascript">  s.<span class="property">async</span> = <span class="literal">false</span>; <span class="comment">// to preserve execution order</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(s);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="HTTP-Public-Key-Pinning-HPKP">HTTP Public Key Pinning (HPKP)</h2>
<blockquote>
<p>HTTP 公钥锁定（HPKP）是一种安全功能，它告诉 Web 客户端将特定加密公钥与某个 Web 服务器相关联，以降低使用伪造证书进行 MITM 攻击的风险。</p>
<p>为确保 TLS 会话中使用的服务器公钥的真实性，此公钥将包装到 X.509 证书中，该证书通常由证书颁发机构（CA）签名。诸如浏览器之类的 Web 客户端信任许多这些 CA，它们都可以为任意域名创建证书。如果攻击者能够攻击单个 CA，则他们可以对各种 TLS 连接执行 MITM 攻击。 HPKP 可以通过告知客户端哪个公钥属于某个 Web 服务器来规避 HTTPS 协议的这种威胁。</p>
<p>HPKP 是首次使用信任（TOFU）技术。 Web 服务器第一次通过特殊的 HTTP 标头告诉客户端哪些公钥属于它，客户端会在给定的时间段内存储此信息。当客户端再次访问服务器时，它希望证书链中至少有一个证书包含一个公钥，其指纹已通过 HPKP 已知。如果服务器提供未知的公钥，则客户端应向用户发出警告。</p>
<p>——HTTP Public Key Pinning (HPKP)</p>
</blockquote>
<h3 id="语法">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Public-Key-Pins</span><span class="punctuation">: </span>pin-sha256=&quot;&lt;pin-value&gt;&quot;;</span><br><span class="line">                 max-age=&lt;expire-time&gt;;</span><br><span class="line">                 includeSubDomains;</span><br><span class="line">                 report-uri=&quot;&lt;uri&gt;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<ul>
<li>pin-sha256：即证书指纹，允许出现多次，实际上应用最少指定两个</li>
<li>max-age：过期时间</li>
<li>includeSubdomains：是否包含子域</li>
<li>report-uri：验证失败时上报的地址</li>
</ul>
<h2 id="HTTP-Strict-Transport-Security-HSTS">HTTP Strict Transport Security(HSTS)</h2>
<blockquote>
<p>HTTP Strict Transport Security (通常简称为 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HSTS"><mark class="label info">HSTS</mark></a> )是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是 HTTP。</p>
<p>——MDN. HTTP Strict Transport Security.</p>
</blockquote>
<h3 id="语法-2">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;; includeSubDomains</span><br><span class="line"><span class="attribute">Strict-Transport-Security</span><span class="punctuation">: </span>max-age=&lt;expire-time&gt;; preload</span><br></pre></td></tr></table></figure>
<h3 id="指令-2">指令</h3>
<ul>
<li>
<p>max-age=&lt;expire-time&gt;</p>
<p>设置在浏览器收到这个请求后的&lt;expire-time&gt;秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。</p>
</li>
<li>
<p>includeSubDomains 可选</p>
<p>如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。</p>
</li>
<li>
<p>preload  可选</p>
<p>查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security#%E9%A2%84%E5%8A%A0%E8%BD%BD_hsts">预加载 HSTS</a> 获得详情。不是标准的一部分。</p>
</li>
</ul>
<h3 id="预加载-HSTS">预加载 HSTS</h3>
<p>谷歌维护着一个 <a href="https://hstspreload.appspot.com/">HSTS 预加载服务</a>。按照如下指示成功提交你的域名后，浏览器将会永不使用非安全的方式连接到你的域名。虽然该服务是由谷歌提供的，但所有浏览器都有使用这份列表的意向（或者已经在用了）。但是，这不是 HSTS 标准的一部分，也不该被当作正式的内容。</p>
<ul>
<li>Chrome &amp; Chromium 的 HSTS 预加载列表： <a href="https://www.chromium.org/hsts">https://www.chromium.org/hsts</a></li>
<li>Firefox 的 HSTS 预加载列表：<a href="https://hg.mozilla.org/mozilla-central/raw-file/tip/security/manager/ssl/nsSTSPreloadList.inc">nsSTSPreloadList.inc</a></li>
</ul>
<h2 id="Referrer-Policy">Referrer-Policy</h2>
<blockquote>
<p><strong><mark class="label primary">Referrer-Policy</mark></strong> 首部用来监管哪些访问来源信息——会在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><mark class="label primary">Referer</mark></a> 中发送——应该被包含在生成的请求当中</p>
<p>——MDN. Referrer-Policy.</p>
</blockquote>
<h3 id="语法-3">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>no-referrer</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>no-referrer-when-downgrade</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>origin</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>origin-when-cross-origin</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>same-origin</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>strict-origin</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>strict-origin-when-cross-origin</span><br><span class="line"><span class="attribute">Referrer-Policy</span><span class="punctuation">: </span>unsafe-url</span><br></pre></td></tr></table></figure>
<h3 id="指令-3">指令</h3>
<ul>
<li>no-referrer：不允许被记录。</li>
<li>origin：只记录 origin，即域名。</li>
<li>strict-origin：只有在 HTTPS -&gt; HTTPS 之间才会被记录下来。</li>
<li>strict-origin-when-cross-origin：同源请求会发送完整的 URL；HTTPS-&gt;HTTPS，发送源；降级下不发送此首部。</li>
<li>no-referrer-when-downgrade(default)：同 strict-origin。</li>
<li>origin-when-cross-origin：对于同源的请求，会发送完整的 URL 作为引用地址，但是对于非同源请求仅发送文件的源。</li>
<li>same-origin：对于同源请求会发送完整 URL，非同源请求则不发送 referer。</li>
<li>unsafe-url：无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。（可能会泄漏敏感信息）。</li>
</ul>
<h3 id="集成至HTML">集成至HTML</h3>
<p>你也可以在 HTML 内设置 referrer 策略。例如，你可以用一个 name 为 referrer 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta"><mark class="label info">&lt;meta&gt;</mark></a>  元素为整个文档设置 referrer 策略。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;origin&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者用&lt;a&gt;、&lt;area&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;script&gt;或者&lt;link&gt;元素上的 <mark class="label primary">referrerpolicy</mark> 属性为其设置独立的请求策略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com&quot; referrerpolicy=&quot;origin&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>另外也可以在&lt;a&gt;、&lt;area&gt;、&lt;link&gt;元素上将 <mark class="label primary">rel</mark> 属性设置为 <mark class="label primary">noreferrer</mark>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://example.com&quot; rel=&quot;noreferrer&quot;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="X-Content-Type-Options">X-Content-Type-Options</h2>
<blockquote>
<p>X-Content-Type-Options HTTP 消息头相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对  MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行为，换句话说，也就是意味着网站管理员确定自己的设置没有问题</p>
<p>——MDN. X-Content-Type-Options.</p>
</blockquote>
<h3 id="语法-4">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">X-Content-Type-Options</span><span class="punctuation">: </span>nosniff</span><br></pre></td></tr></table></figure>
<h3 id="指令-4">指令</h3>
<mark class="label primary">nosniff</mark>
<p>下面两种情况的请求将被阻止：</p>
<ul>
<li>请求类型是<mark class="label info">style</mark> 但是 MIME 类型不是 <mark class="label info">text/css</mark></li>
<li>请求类型是<mark class="label info">script</mark> 但是 MIME 类型不是 <a href="https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type"><mark class="label info">JavaScript MIME 类型</mark></a>。</li>
</ul>
<h2 id="X-Frame-Options">X-Frame-Options</h2>
<blockquote>
<p>The X-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 或者 &lt;object&gt; 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 clickjacking 攻击</p>
<p>The added security is only provided if the user accessing the document is using a browser supporting X-Frame-Options.</p>
<mark class="label info">Content-Security-Policy</mark>HTTP 头中的 frame-ancestors 指令会替代这个非标准的 header。CSP 的 frame-ancestors 会在 Gecko 4.0 中支持，但是并不会被所有浏览器支持。然而 X-Frame-Options 是个已广泛支持的非官方标准，可以和 CSP 结合使用
<p>——MDN. X-Frame-Options.</p>
</blockquote>
<h3 id="语法-5">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">X-Frame-Options</span><span class="punctuation">: </span>deny</span><br><span class="line"><span class="attribute">X-Frame-Options</span><span class="punctuation">: </span>sameorigin</span><br><span class="line"><span class="attribute">X-Frame-Options</span><span class="punctuation">: </span>allow-from https://example.com/</span><br></pre></td></tr></table></figure>
<h3 id="指令-5">指令</h3>
<ul>
<li>deny: 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</li>
<li>sameorigin: 表示该页面可以在相同域名页面的 frame 中展示。</li>
<li>allow-from uri: 表示该页面可以在指定来源的 frame 中展示。</li>
</ul>
<div class="note warning"><p>设置 meta 标签是无效的！例如 <mark class="label danger">&lt;meta http-equiv=X-Frame-Options content=deny&gt;</mark> 没有任何效果。配置方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options"><mark class="label info">MDN. X-Frame-Options.</mark></a></p>
</div>
<h2 id="X-XSS-Protection">X-XSS-Protection</h2>
<blockquote>
<p>HTTP <strong><mark class="label info">X-XSS-Protection</mark></strong> 响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting">XSS (en-US)</a>)时，浏览器将停止加载页面。若网站设置了良好的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy"><mark class="label info">Content-Security-Policy</mark></a> 来禁用内联 JavaScript (<mark class="label info">'unsafe-inline'</mark>)，现代浏览器不太需要这些保护， 但其仍然可以为尚不支持 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/CSP">CSP</a> 的旧版浏览器的用户提供保护</p>
<p>——MDN. X-XSS-Protection.</p>
</blockquote>
<h3 id="语法-6">语法</h3>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">X-XSS-Protection</span><span class="punctuation">: </span>0</span><br><span class="line"><span class="attribute">X-XSS-Protection</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">X-XSS-Protection</span><span class="punctuation">: </span>1; mode=block</span><br><span class="line"><span class="attribute">X-XSS-Protection</span><span class="punctuation">: </span>1; report=&lt;reporting-uri&gt;</span><br></pre></td></tr></table></figure>
<h3 id="指令-6">指令</h3>
<ul>
<li>0： 禁止XSS过滤</li>
<li>1： 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</li>
<li>1; mode=block：启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载</li>
<li>1; report=&lt;reporting-URI&gt; (Chromium only)：启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri">report-uri (en-US)</a>指令的功能发送违规报告</li>
</ul>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://web.dev/security-headers/">web.dev. Security headers quick reference</a></p>
<p>[2]<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers">MDN. HTTP-Headers</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP-Header</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-BOM-2</title>
    <url>/Javascript-BOM-2/</url>
    <content><![CDATA[<h2 id="location-对象">location 对象</h2>
<p>location 对象是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。这个对象独特的地方在于，它既是 window 的属性，也是 document 的属性。<br>
假设当前加载的 URL 是 <a href="http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents">http://foouser:barpassword@www.wrox.com:80/WileyCDA/?q=javascript#contents</a>, location 对象的内容如下表所示。</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">location.hash</td>
<td style="text-align:left">#contents</td>
<td style="text-align:left">URL 散列值(井号后跟零个或多个字符)，如果没有则为空字符串</td>
</tr>
<tr>
<td style="text-align:left">location.host</td>
<td style="text-align:left"><a href="http://www.wrox.com:80">www.wrox.com:80</a></td>
<td style="text-align:left">服务器名及端口号</td>
</tr>
<tr>
<td style="text-align:left">location.hostname</td>
<td style="text-align:left"><a href="http://www.wrox.com">www.wrox.com</a></td>
<td style="text-align:left">服务器名</td>
</tr>
<tr>
<td style="text-align:left">location.href</td>
<td style="text-align:left"><a href="http://www.wrox.com:80/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td>
<td style="text-align:left">当前加载页面的完整 URL。location 的 toString()方法返回这个值</td>
</tr>
<tr>
<td style="text-align:left">location.pathname</td>
<td style="text-align:left">/WileyCDA/</td>
<td style="text-align:left">URL 中的路径和(或)文件名</td>
</tr>
<tr>
<td style="text-align:left">location.port</td>
<td style="text-align:left">80</td>
<td style="text-align:left">请求的端口。如果 URL 中没有端口，则返回空字符串</td>
</tr>
<tr>
<td style="text-align:left">location.protocol</td>
<td style="text-align:left">http:</td>
<td style="text-align:left">页面使用的协议。通常是&quot;http:“或&quot;https:”</td>
</tr>
<tr>
<td style="text-align:left">location.search</td>
<td style="text-align:left">?q=javascript</td>
<td style="text-align:left">URL 的查询字符串。这个字符串通常以问号开头</td>
</tr>
<tr>
<td style="text-align:left">location.username</td>
<td style="text-align:left">foouser</td>
<td style="text-align:left">域名前指定的用户名</td>
</tr>
<tr>
<td style="text-align:left">location.password</td>
<td style="text-align:left">barpassword</td>
<td style="text-align:left">域名前指定的密码</td>
</tr>
<tr>
<td style="text-align:left">location.origin</td>
<td style="text-align:left"><a href="http://www.wrox.com">http://www.wrox.com</a></td>
<td style="text-align:left">URL 的源地址。只读</td>
</tr>
</tbody>
</table>
<h3 id="查询字符串">查询字符串</h3>
<p>location 的多数信息都可以通过上面的属性获取。但是 URL 中的查询字符串并不容易使用。虽然 location.search 返回了从问号直到 URL 末尾的所有内容，但没有办法逐个访问每个查询参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getQueryStringArgs = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 取得没有开头问号的查询字符串</span></span><br><span class="line">  <span class="keyword">let</span> qs = location.<span class="property">search</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>) : <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">// 保存数据的对象</span></span><br><span class="line">  args = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把每个参数添加到args对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> qs.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>).<span class="title function_">map</span>(<span class="function">(<span class="params">kv</span>) =&gt;</span> kv.<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]),</span><br><span class="line">      value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (name.<span class="property">length</span>) &#123;</span><br><span class="line">      args[name] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="URLSearchParams">URLSearchParams</h4>
<p>URLSearchParams 提供一组标准 API 方法，通过它们可以检查和修改查询字符串。给 URLSearchParams 构造函数传入一个查询字符串，就可以创建一个实例。这个实例上暴露了 get()、set()和 delete()等方法，可以对查询字符串执行相应操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// qs = name=kinsiy&amp;age=24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> qs = location.<span class="property">search</span>;</span><br><span class="line"><span class="keyword">let</span> searchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(qs);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">has</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">get</span>(<span class="string">&quot;age&quot;</span>)); <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line">searchParams.<span class="title function_">set</span>(<span class="string">&quot;lover&quot;</span>, <span class="string">&quot;someone&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(searchParams.<span class="title function_">toString</span>()); <span class="comment">// name=kinsiy&amp;age=24&amp;lover=someone</span></span><br><span class="line"><span class="comment">// 能够迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> param <span class="keyword">of</span> searchParams) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(param); <span class="comment">// [&quot;name&quot;, &quot;kinsiy&quot;] [&quot;age&quot;, &quot;24&quot;] [&quot;lover&quot;, &quot;someone&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作地址">操作地址</h3>
<p>可以通过 location 对象修改浏览器的地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 效果相同</span></span><br><span class="line">location.<span class="title function_">assign</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>修改 location 对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname 和 port 属性被设置为新值之后都会修改当前 URL。除了 hash 之外，只要修改 location 的一个属性，就会导致页面重新加载新 URL。</p>
<p>如果不希望增加历史记录，可以使用 replace()方法。这个方法接收一个 URL 参数，但重新加载后不会增加历史记录。调用 replace()之后，用户不能回到前一页。</p>
<p>最后一个修改地址的方法是 reload()，它能重新加载当前显示的页面。调用 reload()而不传参数，页面会以最有效的方式重新加载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.<span class="title function_">reload</span>(); <span class="comment">// 重新加载，可能是从缓存加载</span></span><br><span class="line">location.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 重新加载，从服务器加载</span></span><br></pre></td></tr></table></figure>
<h2 id="navigator-对象">navigator 对象</h2>
<p>navigator 对象的属性通常用于确定浏览器的类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性/方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">activeVrDisplays</td>
<td style="text-align:left">返回数组，包含 ispresenting 属性为 true 的 VRDisplay 实例</td>
</tr>
<tr>
<td style="text-align:left">appCodeName</td>
<td style="text-align:left">即使在非 Mozilla 浏览器中也会返回&quot;Mozilla&quot;</td>
</tr>
<tr>
<td style="text-align:left">appName</td>
<td style="text-align:left">浏览器全名</td>
</tr>
<tr>
<td style="text-align:left">appVersion</td>
<td style="text-align:left">浏览器版本。通常与实际的浏览器版本不一致</td>
</tr>
<tr>
<td style="text-align:left">battery</td>
<td style="text-align:left">返回暴露 Batter Status API 的 BatteryManager 对象</td>
</tr>
<tr>
<td style="text-align:left">buildId</td>
<td style="text-align:left">浏览器的构建编号</td>
</tr>
<tr>
<td style="text-align:left">connection</td>
<td style="text-align:left">返回暴露 Network Information API 的 NetworkInformation 对象</td>
</tr>
<tr>
<td style="text-align:left">cookieEnabled</td>
<td style="text-align:left">返回布尔值，表示是否启用了 cookie</td>
</tr>
<tr>
<td style="text-align:left">credentials</td>
<td style="text-align:left">返回暴露 Credentials Management API 的 CredentialsContainer 对象</td>
</tr>
<tr>
<td style="text-align:left">deviceMemory</td>
<td style="text-align:left">返回单位为 GB 的设备内存容量</td>
</tr>
<tr>
<td style="text-align:left">doNotTrack</td>
<td style="text-align:left">返回用户&quot;不跟踪&quot;(do-not-track)设置</td>
</tr>
<tr>
<td style="text-align:left">geolocation</td>
<td style="text-align:left">返回暴露 Geolocation API 的 Geolcation 对象</td>
</tr>
<tr>
<td style="text-align:left">getVRDisplays()</td>
<td style="text-align:left">返回数组，包含可用的每个 VRDisplay 实例</td>
</tr>
<tr>
<td style="text-align:left">getUserMedia()</td>
<td style="text-align:left">返回与可用媒体设备硬件关联的流</td>
</tr>
<tr>
<td style="text-align:left">hardwareConcurrency</td>
<td style="text-align:left">返回设备的处理器核心数量</td>
</tr>
<tr>
<td style="text-align:left">javaEnabled</td>
<td style="text-align:left">返回布尔值，表示浏览器是否启用了 Java</td>
</tr>
<tr>
<td style="text-align:left">language</td>
<td style="text-align:left">返回浏览器的主语言</td>
</tr>
<tr>
<td style="text-align:left">languages</td>
<td style="text-align:left">返回浏览器偏好的语言数组</td>
</tr>
<tr>
<td style="text-align:left">locks</td>
<td style="text-align:left">返回暴露 Web Locks API 的 LockManager 对象</td>
</tr>
<tr>
<td style="text-align:left">mediaCapabilities</td>
<td style="text-align:left">返回暴露 Media Capabilities API 的 MediaCapabilities 对象</td>
</tr>
<tr>
<td style="text-align:left">mediaDevices</td>
<td style="text-align:left">返回可用的媒体设备</td>
</tr>
<tr>
<td style="text-align:left">maxTouchPoints</td>
<td style="text-align:left">返回设备触摸屏支持的最大触点数</td>
</tr>
<tr>
<td style="text-align:left">mimeTypes</td>
<td style="text-align:left">返回浏览器中注册的 MIME 类型数组</td>
</tr>
<tr>
<td style="text-align:left">onLine</td>
<td style="text-align:left">返回布尔值，表示浏览器是否联网</td>
</tr>
<tr>
<td style="text-align:left">oscpu</td>
<td style="text-align:left">返回浏览器运行设备的操作系统和(或)CPU</td>
</tr>
<tr>
<td style="text-align:left">permissions</td>
<td style="text-align:left">返回暴露 Permissions API 的 Permissions 对象</td>
</tr>
<tr>
<td style="text-align:left">platform</td>
<td style="text-align:left">返回浏览器运行的操作平台、</td>
</tr>
<tr>
<td style="text-align:left">plugins</td>
<td style="text-align:left">返回浏览器安装的插件数组</td>
</tr>
<tr>
<td style="text-align:left">product</td>
<td style="text-align:left">返回产品名称(通常是&quot;Geoko&quot;)</td>
</tr>
<tr>
<td style="text-align:left">productSub</td>
<td style="text-align:left">返回产品的额外信息(通常是 Geoko 的版本)</td>
</tr>
<tr>
<td style="text-align:left">registerProtocolHandler()</td>
<td style="text-align:left">将一个网站注册为特定协议的处理程序</td>
</tr>
<tr>
<td style="text-align:left">requestMediaKeySystemAccess()</td>
<td style="text-align:left">返回一个期约，解决为 MediaKeySystemAccess 对象</td>
</tr>
<tr>
<td style="text-align:left">sendBeacon()</td>
<td style="text-align:left">异步传输一些小数据</td>
</tr>
<tr>
<td style="text-align:left">serviceWorker</td>
<td style="text-align:left">返回用来与 ServiceWorker 实例交互的 ServiceWorkerContainer</td>
</tr>
<tr>
<td style="text-align:left">share()</td>
<td style="text-align:left">返回当前平台的原生共享机制</td>
</tr>
<tr>
<td style="text-align:left">storage</td>
<td style="text-align:left">返回暴露 Storage API 的 StorageManager 对象</td>
</tr>
<tr>
<td style="text-align:left">userAgent</td>
<td style="text-align:left">返回浏览器的用户代理字符串</td>
</tr>
<tr>
<td style="text-align:left">vendor</td>
<td style="text-align:left">返回浏览器的厂商名称</td>
</tr>
<tr>
<td style="text-align:left">vendorSub</td>
<td style="text-align:left">返回浏览器厂商的更多信息</td>
</tr>
<tr>
<td style="text-align:left">vibrate()</td>
<td style="text-align:left">触发设备振动</td>
</tr>
<tr>
<td style="text-align:left">webdriver()</td>
<td style="text-align:left">返回浏览器当前是否被自动化程序控制</td>
</tr>
</tbody>
</table>
<h3 id="插件检测">插件检测</h3>
<p>plugins 数组的每一项都包含如下属性</p>
<ul>
<li>name: 插件名称</li>
<li>description：插件介绍</li>
<li>filename: 插件的文件名</li>
<li>length: 由当前插件处理的 MIME 类型数量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hasPlugin = <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  name = name.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> plugin <span class="keyword">of</span> <span class="variable language_">window</span>.<span class="property">navigator</span>.<span class="property">plugins</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (plugin.<span class="property">name</span>.<span class="title function_">toLowerCase</span>().<span class="title function_">indexOf</span>(name) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测QuickTime</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPlugin</span>(<span class="string">&quot;QuickTime&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="注册处理程序">注册处理程序</h3>
<p>现代浏览器支持 navigator 上的(在 HTML5 中定义的)registerProtocolHandler()方法。可以借助这个方法将 web 应用程序注册为像桌面应用程序一样的默认应用程序。<br>
要使用 registerProtocolHandler()方法，必须传入 3 个参数：要处理的协议(如&quot;mailto&quot;或&quot;ftp&quot;)、处理该协议的 URL，以及应用程序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.<span class="title function_">registerProtocolHandler</span>(<span class="string">&quot;mailto&quot;</span>, <span class="string">&quot;http://www.somedailclient.com?cmd=%s&quot;</span>, <span class="string">&quot;Some Mail Client&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="screen-对象">screen 对象</h2>
<p>这个对象中保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">availHeight</td>
<td style="text-align:left">屏幕像素高度减去系统组件高度(只读)</td>
</tr>
<tr>
<td style="text-align:left">availLeft</td>
<td style="text-align:left">没有被系统组件占用的屏幕的最左侧像素(只读)</td>
</tr>
<tr>
<td style="text-align:left">availTop</td>
<td style="text-align:left">没有被系统组件占用的屏幕的最顶端像素(只读)</td>
</tr>
<tr>
<td style="text-align:left">availWidth</td>
<td style="text-align:left">屏幕像素宽度减去系统组件高度(只读)</td>
</tr>
<tr>
<td style="text-align:left">colorDepth</td>
<td style="text-align:left">表示屏幕颜色的位数；多数系统是 32(只读)</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:left">屏幕像素高度</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:left">当前屏幕左边的像素距离</td>
</tr>
<tr>
<td style="text-align:left">pixelDepth</td>
<td style="text-align:left">屏幕的位深(只读)</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:left">当前屏幕顶端的像素距离</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:left">屏幕像素宽度</td>
</tr>
<tr>
<td style="text-align:left">orientation</td>
<td style="text-align:left">返回 Screen Orientation API 中屏幕的朝向</td>
</tr>
</tbody>
</table>
<h2 id="history-对象">history 对象</h2>
<p>history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性。所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退</p>
<h3 id="导航">导航</h3>
<p>go()方法可以在用户历史记录中沿任何方向导航，可以前进也可以后退。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一页</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">1</span>);</span><br><span class="line">history.<span class="title function_">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进一页</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">1</span>);</span><br><span class="line">history.<span class="title function_">forward</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导航到最近的页面，可能后退也可能前进。若无匹配项，则什么也不做</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="string">&quot;wrox.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>history 对象还有一个 length 属性，表示历史记录中有多个条目。对于窗口或标签页加载的第一个页面，history.length 等于 1.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (history.<span class="property">length</span> == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 这是用户窗口的第一个页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="历史状态管理">历史状态管理</h3>
<p>略</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-BOM-1</title>
    <url>/Javascript-BOM-1/</url>
    <content><![CDATA[<h2 id="window-对象">window 对象</h2>
<p>BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是 ECMAscript 中的 Global 对象，另一个是就是浏览器窗口的 Javascript 接口。这意味着网页中定义的所用对象、变量和函数都以 window 作为其 Global 对象，都可以访问其上定义的 parseInt()等全局方法</p>
<h3 id="Global-作用域">Global 作用域</h3>
<p>因为 window 对象被复用为 ECMAScript 的 Global 对象，所有通过 var 声明的所有全局变量和函数都会变成 window 对象的属性和方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局 var 声明</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">sayAge</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局 let 声明</span></span><br><span class="line"><span class="keyword">let</span> age_1 = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sayAge_1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age_1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayAge_1</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayAge_1</span>(); <span class="comment">// Uncaught TypeError: window.sayAge_1 is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问未声明的变量会抛出错误，但是可以在window对象上查询是否存在未声明的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue; <span class="comment">// Uncaught ReferenceError: oldValue is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherNewValue = <span class="variable language_">window</span>.<span class="property">anotherOldValue</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherNewValue); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="窗口关系">窗口关系</h2>
<p>top 对象始终指向最上层(最外层)窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。如果当前窗口是最上层窗口，则 parent 等于 top(都等于 window)。最上层的 window 如果不是通过 window.open()打开的，那么其 name 属性就不会包含值。<br>
还有一个 self 对象，它是终极 window 对象，始终会指向 window。实际上，self 和 window 就是同一个对象。之所以还要暴露 self，就是为了和 top、paren 保持一致。</p>
<h3 id="窗口位置与像素比">窗口位置与像素比</h3>
<p>window 对象的位置可以通过不同的属性和方法来确定。现代浏览器提供了 screenLeft 和 screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置，返回值的单位事 CSS 像素。可以使用 moveTo()和 moveBy()方法移动窗口。这两个方法都接收两个参数，其中 moveTo()接收要移动到的新位置的绝对坐标 x 和 y;而 moveBy()则接收相对当前位置在两个方向上移动的像素数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依浏览器而定。以下方法可能会被部分或全部禁用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把窗口移到左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把窗口向下移动100个像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">moveBy</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="窗口大小">窗口大小</h3>
<p>在不同浏览器中确定浏览器窗口大小没有想象中那么容易。所有现代浏览器都支持 4 个属性：innerWidth、innerHeight、outerWidth 和 outerHeight、outerWidth 和 outerHeight 返回浏览器窗口自身的大小(不管是在最外层 window 上使用还是在窗格&lt;frame&gt;中使用)。innerWidth 和 innerHeight 返回浏览器窗口中页面视口的大小(不包含浏览器边框和工具栏)<br>
document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回页面视口的宽度和高度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">  pageHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>) &#123;</span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pageWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">    pageHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pageWidth, <span class="string">&quot; &quot;</span>, pageHeight); <span class="comment">// 690 &quot; &quot; 875</span></span><br></pre></td></tr></table></figure>
<p>可以使用 resizeTo()和 resizeBy()方法调整窗口大小。这两个方法都接收两个参数，resizeTo()接收新的宽度和高度值，而 resizeBy()接受宽度和高度各要缩放多少。与移动窗口的方法一样，缩放窗口的方法可能会被浏览器禁用，而且在某些浏览器中默认是禁用的。同样，缩放窗口的方法只能应用到最上层的 window 对象。</p>
<h3 id="视口位置">视口位置</h3>
<p>浏览器窗口尺寸通常无法满足完整显示整个页面，为此用户可以通过滚动在有限的视口中查看文档。度量文档相对于视口滚动距离的属性有两对，返回相等的值：window.pageXoffset/window.scrollX 和 window.pageYoffset/window.scrollY。<br>
可以使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。这 3 个方法都接收表示相对<b>视口距离</b>的 x 和 y 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于当前视口向下滚动100像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于当前视口向右滚动40像素</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollBy</span>(<span class="number">40</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动到页面左上角</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动到距离屏幕左边及顶边各100像素的位置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平滑滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">  <span class="attr">left</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">top</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="导航与打开新窗口">导航与打开新窗口</h3>
<p>window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。这个方法接收 4 个参数：要加载的 URL、目标窗口、特性字符串和表示新窗口在浏览器历史中是否替代当前加载页面的布尔值。通常，调用这个方法时只传前 3 个参数，最后一个参数只有在不打开新窗口时才会使用。<br>
如果 window.open()的第二个参数是一个已经存在的窗口或窗格(frame)的名字，则会在对应窗口或窗格中打开 URL。</p>
<h4 id="弹出窗口">弹出窗口</h4>
<p>如果 window.open()的第二个参数不是已有窗口，则会打开一个新窗口或标签页。第三个参数，即特性字符串，用于指定新窗口的配置。如果没有传第三个参数，则新窗口(或标签页)会带有所有默认的浏览器特性(工具栏、地址栏、状态栏等都是默认配置)。如果打开的不是新窗口，则忽略第三个参数。<br>
特性字符串是一个逗号分隔的设置字符串，用于指定新窗口包含的特性。下表列出了一些选项</p>
<table>
<thead>
<tr>
<th style="text-align:left">设置</th>
<th style="text-align:center">值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">fullscreen</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示窗口是否最大化。仅限 IE 支持</td>
</tr>
<tr>
<td style="text-align:left">height</td>
<td style="text-align:center">数值</td>
<td style="text-align:left">新窗口高度。这个值不能小于 100</td>
</tr>
<tr>
<td style="text-align:left">left</td>
<td style="text-align:center">数值</td>
<td style="text-align:left">新窗口的 x 轴坐标。这个值不能是负值</td>
</tr>
<tr>
<td style="text-align:left">location</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否显示地址栏。不同浏览器的默认值也不一样。在设置为&quot;no&quot;时，地址栏可能隐藏或禁用(取决于浏览器)</td>
</tr>
<tr>
<td style="text-align:left">Menubar</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否显示菜单栏。默认为&quot;no&quot;</td>
</tr>
<tr>
<td style="text-align:left">resizeable</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否可以拖动改变新窗口大小。默认为&quot;no&quot;</td>
</tr>
<tr>
<td style="text-align:left">scrollbars</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否可以在内容过长时滚动。默认为&quot;no&quot;</td>
</tr>
<tr>
<td style="text-align:left">status</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否显示状态栏。不同浏览器的默认值不一样</td>
</tr>
<tr>
<td style="text-align:left">toolbar</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:left">表示是否显示工具栏。默认为&quot;no&quot;</td>
</tr>
<tr>
<td style="text-align:left">top</td>
<td style="text-align:center">数值</td>
<td style="text-align:left">新窗口的 y 轴坐标。这个值不能是负值</td>
</tr>
<tr>
<td style="text-align:left">width</td>
<td style="text-align:center">数值</td>
<td style="text-align:left">新窗口的宽度。这个值不能小于 100</td>
</tr>
</tbody>
</table>
<p>window.open()方法返回一个对新建窗口的引用。这个对象与普通 window 对象没有区别。只是为了控制新窗口提供了方便。例如某些浏览器默认不允许缩放或移动主窗口，但可能允许缩放或移动通过 window.open()创建的窗口。跟使用任何 window 对象一样，可以使用这个对象操纵新打开的窗口。<br>
还可以使用 close()方法来关闭新打开的窗口。<span style="text-decoration: line-through;">这个方法只能用于 window.open()创建的弹出窗口。</span>在 chrome 控制台试了下，可以直接关闭。<br>
新创建窗口的 window 对象有一个属性 opener，指向打开它的窗口。这个属性只在弹出窗口的最上层 window 对象(top)有定义，是指向调用 window.open()打开它的窗口或窗格的指针。</p>
<h4 id="安全限制">安全限制</h4>
<p>从 IE7 开始，地址栏不能隐藏，而且弹窗默认是不能移动或缩放的。Firefox 1 禁用了隐藏状态栏的功能，因此无论 window.open()的特性字符串是什么，都不会隐藏弹窗的状态栏。Firefox 3 强制弹窗始终显示地址栏。Opera 只会在主窗口中打开新窗口，但不允许他们出现在系统对话框的位置。此外，浏览器会在用户操作下才允许创建弹窗。</p>
<h4 id="弹窗屏蔽程序">弹窗屏蔽程序</h4>
<p>所有现代浏览器都内置了屏蔽弹窗的程序，因此大多数意料之外的弹窗都会被屏蔽。在浏览器屏蔽弹窗时，可能会发生一些事。如果浏览器内置的弹窗屏蔽程序组织了弹窗，那么 window.open()很可能会返回 null。在浏览器扩展或其他程序屏蔽弹窗时，window.open()通常会抛出错误。要准确检测弹窗是否被屏蔽，除了检测 window.open()的返回值，还有把它用 try/catch 包装起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> blocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> baiduWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;http://www.baidu.com&quot;</span>, <span class="string">&quot;_blank&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (baiduWin == <span class="literal">null</span>) &#123;</span><br><span class="line">    blocked = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  blocked = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (blocked) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;弹窗被屏蔽了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器">定时器</h3>
<p>Javascript 在浏览器中是单线程执行的，但允许使用定时器指定在某个时间之后或每隔一段时间就执行相应的代码。setTimeout()用于指定在一定时间后执行某些代码，而 setInterval()用于指定每隔一段时间执行某些代码。<br>
setTimeOut()方法通常接受两个参数：要执行的代码和在执行回调函数前等待的时间(ms)。第一个参数可以是包含 Javascript 代买的字符串(类似于传给 eval()的字符串)或者一个函数，第二个参数是要等待的毫秒数。<br>
setTimeout()的第二个参数只是告诉 Javascript 引擎在指定的毫秒数过后把任务添加到这个队列。如果队列是空的，则会立即执行该代码。如果队列不是空的，则代码必须等待前面的任务执行完了才能执行。<br>
调用 setTimeout()时，会返回一个表示该超时排期的数值 ID。这个超时 ID 是被排期执行代码的唯一标识符，可用于取消该任务。要取消等待中的排期任务，可以调用 clearTimeout()方法并传入超时 ID。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Kinsiy&quot;</span>), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">clearTimeout</span>(timeoutId);</span><br></pre></td></tr></table></figure>
<p>setInterval()与 setTimeout()的使用方法类似，只不过指定的任务会每隔指定时间就执行一次，直到取消循环定时或者页面卸载。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>, intervalId = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">10</span></span><br><span class="line"> <span class="keyword">let</span> incrementNumber = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   num++</span><br><span class="line">   <span class="comment">// 如果达到最大值，则取消所有未执行的任务</span></span><br><span class="line">   <span class="keyword">if</span>(num == max)&#123;</span><br><span class="line">     <span class="built_in">clearInterval</span>(intervalId)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> intervalId = <span class="built_in">setInterval</span>(incrementNumber,<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num_1 = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> max_1 = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> incrementNumber_1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  num_1++</span><br><span class="line">  <span class="comment">// 如果还没有达到最大值，再设置一个超时任务</span></span><br><span class="line">  <span class="keyword">if</span>(num_1 &lt; max_1&gt;)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(incrementNumber_1,<span class="number">500</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(incrementNumber_1,<span class="number">500</span>)</span><br></pre></td></tr></table></figure>
<h4 id="系统对话框">系统对话框</h4>
<p>使用 alert()、confir()和 promt()方法，可以让浏览器调用系统对话框向用户显示消息。这些对话框与浏览器中显示的网页无关，而且也不包含 HTML。他们的外观由操作系统或者浏览器决定。无法使用 CSS 设置。此外，这些对话框都是同步的模态对话框，即在他们显示的时候，代码会停止执行，在它们消失以后，代码才会恢复执行。</p>
<p>alert()接收一个要显示给用户的字符串。与 console.log()可以接收任意数量的参数且能一次性打印这些参数不同，alert()只接收一个参数。调用 alert()时，传入的字符串会显示在一个系统对话框中。对话框只有一个 OK 按钮。如果传给 alert()的参数不是一个原始字符串，则会调用这个值得 ttoString()方法将其转换为字符串。</p>
<p>第二种对话框叫确认框。通过调用 confirm()来显示。确认框跟警告框类似，都会向用户显示消息。但不同之处在不，确认框有两个按钮：“Cancel&quot;和&quot;OK”。用户通过单击不同的按钮表明接下来执行什么操作。要知道用户单击了 OK 按钮还是 Cancel 按钮，可以判断 confirm()方法的返回值：true 表示单击了 OK 按钮，false 表示单击了 Cancel()按钮或者单击某一角上的 X 图标关闭了确认框。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">confirm</span>(<span class="string">&quot;Are you sure?&quot;</span>)) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m so glad you&#x27;re sure!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;I&#x27;m sorry to hear you&#x27;re not sure.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种对话框是提示框，通过调用 prompt()方法来显示。提示框的用途是提示用户输入信息。除了 OK 和 Cancel 按钮，提示框还会显示一个文本框，让用户输入内容。prompt()方法接收两个参数：要显示给用户的文本，以及文本框的默认值(可以是空字符串)。如果用户单击了 OK 按钮，则 prompt()会返回文本框中的值。如果用户单击了 Cancel 按钮，或者对话框被关闭，则 prompt()会返回 null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title function_">prompt</span>(<span class="string">&quot;What is your name?&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Welcome, &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Javascript 还可以显示另外两种对话框：find()和 print()。这两种对话框都是异步显示。用户在浏览器菜单上选择&quot;查找&quot;和&quot;打印&quot;时显示的就是这两种对话框。通过在 window 对象上调用 find()和 print()可以显示它们。（chrome find()调不出来）</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-CORS</title>
    <url>/Javascript-CORS/</url>
    <content><![CDATA[<h2 id="跨域资源共享-CORS">跨域资源共享(CORS)</h2>
<p>跨源请求 —— 那些发送到其他域（即使是子域）、协议或端口的请求 —— 需要来自远程端的特殊 header</p>
<p>跨域资源共享(CORS，Cross-Origin Resource Sharing)定义了浏览器与服务器如果实现跨域通信。CORS 背后的基本思路就是使用自定义的 HTTP 头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败</p>
<p>有两种类型的跨域请求：</p>
<ul>
<li>简单的请求</li>
<li>所有其他请求</li>
</ul>
<span id="more"></span>
<h3 id="简单的请求">简单的请求</h3>
<p>一个简单的请求是指满足以下两个条件的请求：</p>
<ul>
<li>简单的方法：GET，POST 或 HEAD</li>
<li>简单的 header——仅允许自定义下列 header
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type 的值为 application/x-www-from-urlencoded, multipart/from-data 或 text/plain</li>
</ul>
</li>
</ul>
<p>任何其他请求都被认为是&quot;非简单请求&quot;</p>
<p>本质区别在于，可以使用&lt;from&gt;或&lt;script&gt;经行&quot;简单请求&quot;，而无需任何其他特殊方法。</p>
<p>实际区别在于，简单请求会使用 <mark class="label primary">Origin</mark> header 并立即发送，而对于其他请求，浏览器会发出初步的“预检”请求，以请求许可</p>
<h3 id="用于简单请求的-CORS">用于简单请求的 CORS</h3>
<p>如果一个请求是跨源的，浏览器会始终向其添加 Origin header; Origin 包含了确切的源（domain/protocol/port），没有路径。</p>
<p>Origin: <mark class="label primary">http://www.nczonline.net</mark></p>
<p>如果服务器决定响应请求，那么应该发送 Access-Control-Allow-Origin 头部，包含相同的源；或者如果资源是公开的，那么就包含&quot;*&quot;。比如：</p>
<p>Access-Control-Allow-Origin: <mark class="label primary">http://www.nczonline.net</mark></p>
<p>如果没有这个头部，或者有但源不匹配，则表明不会响应浏览器请求。否则，服务器就会处理这个请求。注意，无论请求还是响应都不会包含 cookie 信息。</p>
<p>浏览器在这里扮演被信任的中间人的角色：</p>
<ul>
<li>它确保发送的跨源请求带有正确的 Origin</li>
<li>它检查响应中的许可 Access-Control-Allow-Origin， 如果存在，则允许 Javascript 访问响应，否则将失败并报错</li>
</ul>
<p><img data-src="https://zh.javascript.info/article/fetch-crossorigin/xhr-another-domain.svg" alt=""></p>
<h4 id="Response-header">Response header</h4>
<p>对于跨域请求，默认情况下，Javascript 只能访问&quot;简单&quot;response header：</p>
<ul>
<li>Cache-control</li>
<li>Content-language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pargma</li>
</ul>
<p>访问任何其他 response header 都将导致 error</p>
<p>要授予 Javascript 对任何其他 response header 的访问权限，服务器必须发送<mark class="label primary">Access-Control-Expose-Headers</mark> header。它包含一个以逗号分隔的应该被设置为可访问的非简单 header 名称列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span> <span class="variable constant_">OK</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>:text/html; charset=<span class="variable constant_">UTF</span>-<span class="number">8</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Length</span>: <span class="number">12345</span></span><br><span class="line"><span class="variable constant_">API</span>-<span class="title class_">Key</span>: 2c9de507f2c54aa1</span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">https</span>:<span class="comment">//javascript.info</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="title class_">Content</span>-<span class="title class_">Length</span>,<span class="variable constant_">API</span>-<span class="title class_">Key</span></span><br></pre></td></tr></table></figure>
<h3 id="非简单-请求">&quot;非简单&quot;请求</h3>
<p>我们可以使用任何 HTTP 方法：不仅仅是 <mark class="label primary">GET/POST</mark>，也可以是 <mark class="label primary">PATCH</mark>，<mark class="label primary">DELETE</mark> 及其他</p>
<p>之前，没有人能够设想网页能发出这样的请求。因此，可能仍然存在有些 Web 服务将非标准方法视为一个信号：“这不是浏览器”。它们可以在检查访问权限时将其考虑在内。</p>
<p>因此，为了避免误解，任何“非标准”请求 —— 浏览器不会立即发出在过去无法完成的这类请求。即在它发送这类请求前，会先发送“预检（preflight）”请求来请求许可。</p>
<p>预检请求使用 <mark class="label primary">OPTIONS</mark> 方法，它没有 body，但是有两个 header：</p>
<ul>
<li>Access-Control-Request-Method： header 带有简单请求的方法</li>
<li>Access-Control-Request-Headers:：header 提供一个以逗号分隔的非简单 HTTP header 列表</li>
</ul>
<p>如果服务器同意处理请求，那么他会进行响应，此响应的状态码应该为 200，没有 body，具有 header：</p>
<ul>
<li>Access-Control-Allow-Origin: 必须为经行请求的源或 &quot; * &quot;。才能允许此请求</li>
<li>Access-Control-Allow-Methods: 必须具有允许的方法</li>
<li>Access-Control-Allow-Headers: 必须具有一个允许的 header 列表</li>
<li>另外，header <mark class="label primary">Access-Control-Max-Age</mark> 可以指定缓存此权限的秒数。因此，浏览器不是必须为满足给定权限的后续请求发送预检</li>
</ul>
<p><img data-src="https://zh.javascript.info/article/fetch-crossorigin/xhr-preflight.svg" alt=""></p>
<div class="note warning"><h4 id="注意">注意</h4>
<p>预检请求发生在<mark class="label danger">“幕后”</mark>，它对 JavaScript 不可见。JavaScript 仅获取对主请求的响应，如果没有服务器许可，则获得一个 error。</p>
</div>
<h2 id="代替性跨源技术">代替性跨源技术</h2>
<h3 id="图片探测-使用表单">图片探测/使用表单</h3>
<p>使用表单，提交一个&lt;from&gt;到&lt;iframe&gt;以停留在当前页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 表单目标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">name</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 表单可以由 JavaScript 动态生成并提交 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">target</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://another.com/…&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>图片探测是与服务器之间简单、跨域、单向的通信</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">onload</span> = img.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;Http://www.example.com/test?name=Nicholas&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这两种方式都无法读取响应</p>
<h3 id="JSONP">JSONP</h3>
<p>使用 &lt;script&gt; 标签。&lt;script&gt; 可以具有任何域的 src，例如 &lt;script src=“<mark class="label primary">http://another.com/</mark>…”&gt;。也可以执行来自任何网站的 &lt;script&gt;。</p>
<p>如果一个网站，例如 <a href="http://another.com">another.com</a> 试图公开这种访问方式的数据，则会使用所谓的 “JSONP (JSON with padding)” 协议。</p>
<p>假设在我们的网站，需要以这种方式从 <mark class="label primary">http://another.com</mark> 网站获取数据，例如天气：</p>
<ol>
<li>
<p>首先，我们先声明一个全局函数来接收数据，例如 gotWeather</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 声明处理天气数据的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gotWeather</span>(<span class="params">&#123; temperature, humidity &#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`temperature: <span class="subst">$&#123;temperature&#125;</span>, humidity: <span class="subst">$&#123;humidity&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后我们创建一个特性（attribute）为 src=“<mark class="label primary">http://another.com/weather.json?callback=gotWeather</mark>” 的 &lt;script&gt; 标签，使用我们的函数名作为它的 callback URL-参数。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">`http://another.com/weather.json?callback=gotWeather`</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(script);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>远程服务器 <a href="http://another.com">another.com</a> 动态生成一个脚本，该脚本调用 gotWeather(…)，发送它想让我们接收的数据。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们期望来自服务器的回答看起来像这样：</span></span><br><span class="line"><span class="title function_">gotWeather</span>(&#123;</span><br><span class="line">  <span class="attr">temperature</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">humidity</span>: <span class="number">78</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当远程脚本加载并执行时，<mark class="label info">gotWeather</mark>函数将运行，并且因为它是我们的函数，我们就有了需要的数据</p>
</li>
</ol>
<p>JSONP 由于其简单易用，在开发者中非常流行。相比于图片探测，使用 JSONP 可以直接访问响应， 实现浏览器与服务器的双向通信。不过 JSONP 也有一些缺点</p>
<p>首先 JSONP 是从不同的域拉取可执行代码。如果这个域并不可信，则可能在响应中加入恶意内容。此时除了完全删除 JSONP 没有其他办法。在使用不受控的 Web 服务时，一定要保证是可以信任的。</p>
<p>第二个缺点是不好确定 JSONP 请求是否失败。虽然 HTML5 规定了&lt;script&gt;元素的 onerror 事件处理程序，但还没有被任何浏览器实现。为此，开发者经常使用计时器来决定是否放弃等待响应。这种方式并不准确，毕竟不同用户的网络连接速度和带宽是不一样的</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://zh.javascript.info/fetch-crossorigin">Javascript.info. Fetch: 跨源请求.</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript - Classes</title>
    <url>/Javascript-Classes/</url>
    <content><![CDATA[<h2 id="类定义">类定义</h2>
<p>与函数类型相似，定义类也有两种主要方式：类声明和类表达式。这两种方式都使用 class 关键字加大括号。与函数表达式类似，类表达式在它们被求值前也不能引用。</p>
<p>不过，与函数定义不同的是:</p>
<ul>
<li>虽然函数声明可以提升，但类定义不能。</li>
<li>函数受函数作用域限制，而类受块作用域限制。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: Cannot access &#x27;ClassDeclaration&#x27; before initialization</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// class ClassDeclaration &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">FunctionDeclaration</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">ClassDeclaration</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FunctionDeclaration</span>); <span class="comment">// ƒ FunctionDeclaration() &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">ClassDeclaration</span>); <span class="comment">// ReferenceError: ClassDeclaration is not defined</span></span><br></pre></td></tr></table></figure>
<h3 id="类的构成">类的构成</h3>
<p>类可以包含构造函数方法、实例方法、获取函数、设置函数、和静态类方法。但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">class</span> <span class="title class_">PersonName</span> &#123;</span><br><span class="line">  <span class="title function_">identify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>, <span class="title class_">PersonName</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">identify</span>(); <span class="comment">// PersonName PersonName</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name</span>); <span class="comment">// PersonName</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">PersonName</span>); <span class="comment">// ReferenceError: PersonName is not defined</span></span><br></pre></td></tr></table></figure>
<h2 id="类构造函数">类构造函数</h2>
<p>constructor 关键字用于在类定义块内部创建类的构造函数。方法名 constructor 会告诉解释器在使用 new 操作符创建类的新实例时，应该调用这个函数。构造函数不是必须的，不定义构造函数相当于将构造函数定义为空函数。</p>
<h3 id="实例化">实例化</h3>
<p>使用 new 操作符实例化 Person 的操作等于使用 new 调用其构造函数。唯一可感知的不同之处就是，Javascript 解释器知道使用 new 和类意味着应该使用 constructor 函数进行实例化。使用 new 调用类的构造函数会执行如下操作。</p>
<ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。</li>
<li>构造函数内部的 this 被赋值为这个新对象(即 this 指向新对象)</li>
<li>执行构造函数的代码(给新对象添加属性)</li>
<li>如果构造函数返回非空对象，则返回改对象；否则，返回刚创建的新对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;person ctor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetable</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">// person ctor</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Vegetable</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c.<span class="property">color</span>); <span class="comment">// orange</span></span><br></pre></td></tr></table></figure>
<p>类实例化时传入的参数会用作构造函数的参数。如果不需要参数，则类名后面的括号也是可选的。</p>
<p>默认情况下，类构造函数会在执行之后返回 this 对象。构造函数返回的对象会被用作实例化的对象，如果没用引用新创建的 this 对象，那么这个对象会被销毁。不过，如果返回的不是 this 对象，而是其他对象，那么这个对象不会通过 instanceof 操作符监测出跟类有关联，因为这个对象的原型指针没有被修改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">override</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">foo</span> = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (override) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// Person &#123;foo: &quot;foo&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// &#123;bar: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<div class="note primary"><h4 id="类构造函数与构造函数的主要区别">类构造函数与构造函数的主要区别</h4>
<p>调用类构造函数必须使用new操作符。而普通构造函数如果不使用new调用，那么就会以全局的this(通常是window)作为内部对象。调用类构造函数时如果忘了使用new则会抛出错误</p>
<p>类构造函数没有什么特殊之处，实例化之后，它会成为普通的实例方法，但作为类构造函数，仍然要使用new调用</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p1.<span class="title function_">constructor</span>(<span class="params"></span>); <span class="comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> p1.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="把类当成特殊函数">把类当成特殊函数</h3>
<p>ECMAScript 中没有正式的类这个类型。从各方面来看，ECMAScript 类就是一种特殊函数。声明一个类后，通过 typeof 操作符检测类标识符，表面他是一个函数。类标签符有 prototype 属性，而这个原型也有一个 constructor 属性指向类自身。</p>
<p>在类的上下文中，类本身在使用 new 调用时就会被当成构造函数。重点在于，类中定义的 constructor 方法不会被当成构造函数，在对它使用 instanceof 操作符会返回 false。但是，如果在创建实例时直接将类构造函数当成普通构造函数来使用，那么 instanceof 操作符的返回值会反转。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p_2 = <span class="keyword">new</span> <span class="title class_">Person</span>.<span class="title function_">constructor</span>(<span class="params"></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_2.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>.<span class="property">constructor</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>类可以像其他对象或函数引用一样把类作为参数传递。与立即调用函数表达式相似，类也可以立即实例化。</p>
<h2 id="实例、原型和类成员">实例、原型和类成员</h2>
<p>类的语法可以非常方便地定义应该存在于实例上的成员，应该存在于原型上的成员，以及应该存在于类本身的成员。</p>
<h3 id="实例成员">实例成员</h3>
<p>每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nickNames</span> = [<span class="string">&quot;King&quot;</span>, <span class="string">&quot;Queen&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> p_2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p_1.<span class="title function_">sayName</span>(); <span class="comment">// String &#123;&quot;Kinsiy&quot;&#125;</span></span><br><span class="line">p_2.<span class="title function_">sayName</span>(); <span class="comment">// String &#123;&quot;Kinsiy&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1.<span class="property">name</span> === p_2.<span class="property">name</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1.<span class="property">sayName</span> === p_2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_1.<span class="property">nickNames</span> === p_2.<span class="property">nickNames</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">p_1.<span class="property">name</span> = p_1.<span class="property">nickNames</span>[<span class="number">0</span>];</span><br><span class="line">p_2.<span class="property">name</span> = p_2.<span class="property">nickNames</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">p_1.<span class="title function_">sayName</span>(); <span class="comment">// King</span></span><br><span class="line">p_2.<span class="title function_">sayName</span>(); <span class="comment">// Queen</span></span><br></pre></td></tr></table></figure>
<h3 id="原型方法与访问器">原型方法与访问器</h3>
<p>为了在实例间共享方法，类定义语法把类块中定义的方法作为原型方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;instance&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;prototype&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">locate</span>(); <span class="comment">// instance</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>(); <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据.</p>
<p>类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键</p>
<p>类也支持获取和设置访问器。语法与行为跟普通对象一样</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name_</span> = newName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name_</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p_2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">p_2.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p_2.<span class="property">name</span>); <span class="comment">// Kinsiy</span></span><br></pre></td></tr></table></figure>
<h3 id="静态类方法">静态类方法</h3>
<p>可以在类上定义静态方法。这些方法通常用于执行不特定与实例的操作，也不要求存在类的实例。与原型成员类似，每个类只能有一个静态成员。静态类方法非常适合作为实例工厂</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age_</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age_</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">create</span>()); <span class="comment">// Person &#123;age_: 50&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="非函数原型和类成员">非函数原型和类成员</h3>
<p>虽然类定义并不显式支持在原型或类上添加成员数据，但在类定义外部，可以手动添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;Person.greeting&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类上定义数据成员。无法通过this引用</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">greeting</span> = <span class="string">&quot;My name is&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在原型上定义数据成员</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">me.<span class="title function_">sayName</span>(); <span class="comment">// My name is Kinsiy</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代器与生成器方法">迭代器与生成器方法</h3>
<p>类定义语法支持在原型和类本身上定义生成器方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nicknames</span>= [<span class="string">&quot;Kinsiy&quot;</span>,<span class="string">&quot;Restituo&quot;</span>,<span class="string">&quot;Type57&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在原型上定义生成器方法</span></span><br><span class="line">  *<span class="title function_">createNicknameIterator</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Kinsiy&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;King&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Queen&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在类上定义生成器方法</span></span><br><span class="line">  <span class="keyword">static</span> *<span class="title function_">createJobIterator</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Butcher&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Baker&quot;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Killer&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加一个默认的迭代器，把类实例变成可迭代对象</span></span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">    <span class="keyword">yield</span> *<span class="variable language_">this</span>.<span class="property">nicknames</span>.<span class="title function_">entries</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> p)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &quot;Kinsiy&quot;] [1, &quot;Restituo&quot;] [2, &quot;Type57&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<p>ECMAScript 新增特性中最出色的一个就是原生支持了类继承机制。虽然类继承使用的是新语法，但背后依旧使用的是原型链。</p>
<h3 id="继承基础">继承基础</h3>
<p>ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数(保持向后兼容)</p>
<p>类和原型上定义的方法都会带到派生类。this 的值会反映调用相应方法的实例或者类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">identifyPrototype</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">identifyClass</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(id, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> <span class="title class_">Vehicle</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bus</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Vehicle</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">v.<span class="title function_">identifyPrototype</span>(<span class="string">&quot;vehicle&quot;</span>); <span class="comment">// vehicle Vehicle &#123;&#125;</span></span><br><span class="line">b.<span class="title function_">identifyPrototype</span>(<span class="string">&quot;bus&quot;</span>); <span class="comment">// bus Bus &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vehicle</span>.<span class="title function_">identifyClass</span>(<span class="string">&quot;Vehicle&quot;</span>); <span class="comment">// Vehicle class Vehicle...</span></span><br><span class="line"><span class="title class_">Bus</span>.<span class="title function_">identifyClass</span>(<span class="string">&quot;Bus&quot;</span>); <span class="comment">// Bus class Bus extends Vehicle &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数、HomeObject-和-Super">构造函数、HomeObject 和 Super()</h3>
<p>派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。在类构造函数中使用 super 可以调用父类构造函数。</p>
<p>ES6 给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在 Javascript 引擎内部访问，super 始终定义为[[HomeObject]]的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// super只能在派生类构造函数和静态方法中使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">super</span>);</span><br><span class="line">    <span class="comment">// SyntaxError: &#x27;super&#x27; keyword unexpected here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用super()会调用父类构造函数，并将返回的实例赋值给this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_ inherited__">C</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> C);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title function_">D</span>(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">v</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flag</span> = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> <span class="keyword">extends</span> <span class="title class_ inherited__">E</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">subV</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(subV);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">F</span>(<span class="string">&quot;Kinsiy&quot;</span>)); <span class="comment">// F &#123;flag: &quot;Kinsiy&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有定义派生类的构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span> <span class="keyword">extends</span> <span class="title class_ inherited__">E</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">G</span>(<span class="string">&quot;Type57&quot;</span>)); <span class="comment">// G &#123;flag: &quot;Type57&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类构造函数中，不能在调用super()之前引用this</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span> <span class="keyword">extends</span> <span class="title class_ inherited__">E</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">H</span>(); <span class="comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在派生类中显示定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">I</span> <span class="keyword">extends</span> <span class="title class_ inherited__">E</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 这个对象不会通过 instanceof 操作符监测出跟类有关联</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="keyword">new</span> <span class="title function_">I</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i <span class="keyword">instanceof</span> I); <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure>
<h3 id="抽象基类">抽象基类</h3>
<p>有时候可能需要爱定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然 ECMAScript 没有专门支持这种类的语法，但通过 new.target 也容易实现。</p>
<p>new.target 保存通过 new 关键字调用的类或函数。另外在抽象基类构造函数中进行检查，可以要求派生类必须定义某个方法。因为原型方法在调用类构造函数之前就已经存在了，所以可以通过 this 关键字来检查相应的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>); <span class="comment">// class Bus extends Vehicle &#123;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Vehicle 不能被实例化！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">foo</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Vehicle 派生类必须实现foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Biclcye</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>(); <span class="comment">// Error: Vehicle 不能被实例化！</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Biclcye</span>(); <span class="comment">// Error: Vehicle 派生类必须实现foo()</span></span><br></pre></td></tr></table></figure>
<h3 id="继承内置类型">继承内置类型</h3>
<p>ES6 类为继承内置引用类型提供顺畅的机制，开发者可以方便地扩展内置类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">  <span class="comment">// 洗牌算法</span></span><br><span class="line">  <span class="title function_">shuffle</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i + <span class="number">1</span>));</span><br><span class="line">      [<span class="variable language_">this</span>[i], <span class="variable language_">this</span>[j]] = [<span class="variable language_">this</span>[j], <span class="variable language_">this</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">SuperArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// SuperArray(5) [1, 2, 3, 4, 5]</span></span><br><span class="line">a.<span class="title function_">shuffle</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// SuperArray(5) [2, 3, 5, 4, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些内置类型的方法会返回新实例。默认情况下，返回的实例类型与原型实例的类型是一致的</span></span><br><span class="line"><span class="comment">// 如果想覆盖这个默认行为，则可以覆盖Symbol.species访问器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a_1 = a.<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a_1); <span class="comment">// SuperArray(3) [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a_1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperArray_1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SuperArray</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="title class_">Symbol</span>.<span class="property">species</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">SuperArray</span>_1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> b_1 = b.<span class="title function_">filter</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> !!(x % <span class="number">2</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b_1); <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b_1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b_1 <span class="keyword">instanceof</span> <span class="title class_">SuperArray</span>_1); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b_1 <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="类混入">类混入</h3>
<p>把不同类的行为集中到一个类是一种常见的 Javascript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这种行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">FooMixin</span> = (<span class="params">SuperClass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BarMixin</span> = (<span class="params">SuperClass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">BzaMixin</span> = (<span class="params">SuperClass</span>) =&gt; <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;baz&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mix</span>(<span class="params">Baseclass,...Mixins</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Mixins</span>.<span class="title function_">reduce</span>(<span class="function">(<span class="params">accumulator, current</span>) =&gt;</span> <span class="title function_">current</span>(accumulator),<span class="title class_">Baseclass</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">mix</span>(<span class="title class_">Vehicle</span>,<span class="title class_">FooMixin</span>,<span class="title class_">BarMixin</span>,<span class="title class_">BzaMixin</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bus</span></span><br><span class="line">b.<span class="title function_">foo</span>();  <span class="comment">// foo</span></span><br><span class="line">b.<span class="title function_">bar</span>();  <span class="comment">// bar</span></span><br><span class="line">b.<span class="title function_">baz</span>();  <span class="comment">// baz</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Classes</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-DOM-1</title>
    <url>/Javascript-DOM-1/</url>
    <content><![CDATA[<h2 id="节点层级">节点层级</h2>
<p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每种类型对应着文档中不同的信息和(或)标记，也有自己不同的特性、数据和方法，而且与其他类型有某种关系。这些关系构成了层级，让标记可以表示为一个以特定节点为根的树形结构。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello word!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>document 节点表示每个文档的根节点。在这里，根节点的唯一子节点是&lt;html&gt;元素,我们称之为文档元素(documentElement)。文档元素是最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 Html 页面中，文档元素始终是&lt;html&gt;元素。</p>
<h3 id="Node-类型">Node 类型</h3>
<p>DOMLevel 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。</p>
<h4 id="nodeName-与-nodeValue">nodeName 与 nodeValue</h4>
<p>nodeName 与 nodeValue 保存着有关节点的信息。这两个属性的值完全取决于节点类型。对元素而言，nodeName 始终等于元素的标签名，而 nodeValue 则始终为 null。</p>
<h4 id="节点关系">节点关系</h4>
<p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。<br>
每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。NodeList 是一个类数组对象，用于存储可以按位置存取的有序节点。注意，NodeList 并不是 Array 的实例，但可以使用中括号访问它的值，而且它也有 length 属性。NodeList 是实时的活动对象，而不是第一次访问时所获得内容的快照。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstChild = someNode.<span class="property">childNodes</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> secondChild = soNode.<span class="property">childNodes</span>.<span class="title function_">item</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> count = someNode.<span class="property">childNodes</span>.<span class="property">length</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Node.jpg" alt=""><br>
利用这些关系指针，几乎可以访问到文档树中的任何节点。还可以使用 hasChildNodes()方法检测节点是否存在子节点，如果这个方法返回 true 说明节点有一个或多个子节点。</p>
<h4 id="操纵节点">操纵节点</h4>
<ol>
<li><b>appendChild()</b><br>
用于在 childNodes 列表末尾添加节点。添加新节点会更新相关的关系指针，包活父节点和之前的最后一个子节点。appendChild()方法返回新添加的节点。如果把文档中已经存在的节点传给 appendChild()，则这个节点会从之前的位置被转移到新位置。</li>
<li><b>insertBefore()</b><br>
如果想把节点放到 childNodes 中的特定位置而不是末尾，则可以使用 insertBefore()方法。这个方法接收两个参数：要插入的节点和参照节点。调用这个方法后，要插入的节点会变成参照节点的前一个同胞节点，并被返回。如果参照节点是 null，则 insertBefore()与 appendChild()效果相同。</li>
<li><b>replaceChild()</b><br>
replaceChild()方法接收两个参数：要插入的节点和要替换的节点。要替换的节点会被返回并从文档树中完全移除，要插入的节点会取而代之。</li>
<li>其他方法<br>
<b>cloneNode()</b>,会返回与调用它的节点一模一样的节点。cloneNode()还接收一个布尔值参数表示是否深复制。在传入 true 参数时，会进行深复制，即复制节点及其整个字 DOM 树。如果传入 false，则只会复制调用该方法的节点。复制返回的节点属于文档所有，但尚未指定父节点，可称为孤儿节点(orphan)<br>
<b>normalize()</b>，处理文档子树中的文本节点。在节点上调用 normalize()方法会检测这个节点的所有后代，从中搜索不包含文本的文本节点已经互为同胞关系的文本节点，如果发现空文本节点，则将其删除；如果两个同胞节点是相邻的，则将其合并为一个文本节点。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设someNode有多个子节点</span></span><br><span class="line"><span class="keyword">let</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedNode === someNode.<span class="property">firstChild</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedNode === someNode.<span class="property">lastChild</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> returnNode_1 = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>); <span class="comment">// 在第一个节点前插入一个新节点</span></span><br><span class="line"><span class="keyword">let</span> returnNode_1 = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span> - <span class="number">2</span>]); <span class="comment">// 替换倒数第二个节点</span></span><br></pre></td></tr></table></figure>
<h3 id="Document-类型">Document 类型</h3>
<p>Document 类型是 Javascript 中表示文档节点的类型。在浏览器中，文档对象是 HTMLDocument 的实例(HTMLDocument 继承 Document)，表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象</p>
<h4 id="文档子节点">文档子节点</h4>
<p>DOM 规范规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingInstruction 或 Comment 类型，也提供了两个访问子节点的快捷方式。第一个是 documentElement 属性，始终指向 HTML 页面中的&lt;html&gt;元素。第二个是 body 属性，直接指向&lt;body&gt;元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="property">body</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(html.<span class="property">nodeName</span>); <span class="comment">// HTML</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(body.<span class="property">nodeName</span>);  <span class="comment">// BODY</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="文档信息">文档信息</h4>
<p>title 属性，包含&lt;title&gt;元素中的文档，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。不过，修改 title 属性并不会改变&lt;title&gt;元素<br>
URL 属性包含当前页面的完整 URL，domain 包含页面的域名，而 referrer 包含链接到当前页面的那个页面的 URL。如果当前页面没有来源，则 referrer 属性包含空字符串。所有这些信息都可以在请求的 HTTP 头部信息中获取，只是在 Javascript 中通过这几个属性暴露出来而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="variable language_">document</span>.<span class="property">URL</span>;</span><br><span class="line"><span class="keyword">let</span> domain = <span class="variable language_">document</span>.<span class="property">domain</span>;</span><br><span class="line"><span class="keyword">let</span> referrer = <span class="variable language_">document</span>.<span class="property">referrer</span>;</span><br></pre></td></tr></table></figure>
<h4 id="定位元素">定位元素</h4>
<p>使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。</p>
<ol>
<li>getElementById()<br>
方法接收一个参数，即要获取元素的 ID，如果找到了则返回这个元素，如果没找到则返回 null。参数 ID 必须跟在页面中的 id 属性值完全匹配，包括大小写。如果页面中存在多个具有多个相同的 ID 的元素，则 getElementById()返回在文档中出现的第一个元素。</li>
<li>getElementByTagName()<br>
方法接收一个参数，即要获取元素的标签名，返回包含零个或多个元素的 NodeList</li>
<li>getElementByName()<br>
顾名思义，这个方法会返回具有给定 name 属性的所有元素。</li>
</ol>
<h4 id="特殊集合">特殊集合</h4>
<ul>
<li>document.anchors 包含文档中所有带 name 属性的&lt;a&gt;元素</li>
<li>document.froms 包含文档中所有&lt;from&gt;元素</li>
<li>document.images 包含文档中所有&lt;img&gt;元素</li>
<li>document.links 包含文档中所有带 href 属性的&lt;a&gt;元素</li>
</ul>
<h3 id="Element-类型">Element 类型</h3>
<p>Elemenet 表示 XML 或 HTML 元素，对外暴露出访问元素标签名</p>
<h4 id="HTML-元素">HTML 元素</h4>
<p>所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。另外，HTMLElement 直接继承 Element 并增加了一些属性。每个属性都对应下列属性之一，他们是所有 HTML 元素都有的标准属性</p>
<ul>
<li>id，元素在文档中的唯一标识符</li>
<li>title，包含元素的额外信息，通常以提示条形式展示</li>
<li>lang，元素内容的语言代码</li>
<li>dir，语言的书写方向</li>
<li>className，相当于 class 属性，用于指定元素的 CSS 类</li>
</ul>
<h4 id="取得属性">取得属性</h4>
<p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。</p>
<ul>
<li>getAttribute()</li>
<li>setAttribute()</li>
<li>removeAttribute()</li>
</ul>
<p>顾名思义，这几个方法不用多说。稍微需要注意的是，通过对象形式为元素添加自定义属性是不会让它变成元素的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.<span class="property">myColor</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(div.<span class="title function_">getAttribute</span>(<span class="string">&quot;myColor&quot;</span>)); <span class="comment">// null (IE除外)</span></span><br></pre></td></tr></table></figure>
<h4 id="attributes-属性">attributes 属性</h4>
<p>Element 类型是唯一使用 attributes 属性的 DOM 节点类型。attribute 属性包含一个 NamedNodeMap 实例，是一个类似 NodeList 的&quot;实时&quot;集合。元素的每个属性都表示为一个 Attr 节点，并保存在这个 NamedNodeMap 对象中。NamedNodeMap 对象包含下列方法：</p>
<ul>
<li>getNamedItem(name),返回 nodeName 属性等于 name 的节点</li>
<li>removeNamedItem(name),删除 nodeName 属性等于 name 的节点</li>
<li>setNamedItem(node),向列表中添加 node 节点，以其 nodeName 为索引</li>
<li>item(pos),返回索引位置 pos 处的节点</li>
</ul>
<p>一般不怎么用，getAttribute()、setAttribute()、removeAttribute()这三个使用起来更简便，attributes 属性最有用的场景是需要迭代元素上所有属性的时候。</p>
<h4 id="创建元素">创建元素</h4>
<p>可以使用 document.createElement()方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档(包括 XHTML)是区分大小写的<br>
创建的元素没有添加到文档树中，不会影响到浏览器显示，要把元素添加到文档树中，可以使用 appendChild()、insertBefore()或 replaceChild()。</p>
<h4 id="元素后代">元素后代</h4>
<p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。childNodes 属性包含所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现明显不同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在解析以上代码是，&lt;ul&gt;元素会包含 7 个子元素，其中 3 个事&lt;li&gt;元素，还有 4 个 Text 节点(表示&lt;li&gt;元素周围的空格)。如果把元素之间的空格删掉，则所有浏览器都会返回相同数量的子节点</p>
<h3 id="其他类型">其他类型</h3>
<p>Text 类型 &amp;&amp; Comment 类型 &amp;&amp; CDATASection 类型<br>
DocumentType 类型 &amp;&amp; DocumentFragment 类型 &amp;&amp; Attr 类型<br>
略 🤣</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-DOM-2</title>
    <url>/Javascript-DOM-2/</url>
    <content><![CDATA[<h2 id="DOM-编程">DOM 编程</h2>
<h3 id="动态脚本">动态脚本</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&quot;foo.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>
<p>在上面最后一行把&lt;script&gt;元素添加到页面之前，是不会开始下载外部文件的。</p>
<span id="more"></span>
<h3 id="动态样式">动态样式</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">link.<span class="property">type</span> = <span class="string">&quot;text/css&quot;</span>;</span><br><span class="line">link.<span class="property">href</span> = <span class="string">&quot;styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">head.<span class="title function_">appendChild</span>(link);</span><br></pre></td></tr></table></figure>
<p>通过外部文件加载样式是一个异步过程。因此，样式的加载和正执行的 Javascript 代码并没有先后顺序。一般来说也不需要知道样式什么时候加载完成</p>
<h3 id="操作表格">操作表格</h3>
<p>可以使用类似前面的方法操作表格，但是涉及大量的标签，包括表行、表元、表题等。为了方便创建表格，HTMLDOM 给&lt;table&gt;、&lt;tbody&gt;和&lt;tr&gt;元素添加了一些属性和方法。</p>
<p>&lt;table&gt;元素添加了以下属性和方法</p>
<ul>
<li>caption，指向&lt;caption&gt;元素的指针(如果存在)</li>
<li>tBodies, 包含&lt;tbody&gt;元素的 HTMLCollection</li>
<li>tFood，指向&lt;tfoot&gt;元素(如果存在)</li>
<li>tHead，指向&lt;tHead&gt;元素(如果存在)</li>
<li>rows，包含表示所有行的 HTMLCollection</li>
<li>createTHead(),创建&lt;thead&gt;元素，放到表格中，返回引用</li>
<li>createTFoot(),创建&lt;tfoot&gt;元素，放到表格中，返回引用</li>
<li>createCaption(),创建&lt;caption&gt;元素，放到表格中，返回引用</li>
<li>deleteTHead(),删除&lt;thead&gt;元素</li>
<li>deleteTFoot(),删除&lt;tfoot&gt;元素</li>
<li>deleteTCaption(),删除&lt;caption&gt;元素</li>
<li>deleteRow(pos),删除给定位置的行</li>
<li>insertRow(pos),在行集合中给定位置插入一行</li>
</ul>
<p>&lt;tbody&gt;元素添加了以下属性和方法</p>
<ul>
<li>rows, 包含&lt;tbody&gt;元素中所有行的 HTMLCOllection</li>
<li>deleteRow(pos), 删除给定位置的行</li>
<li>insertRow(pos), 在行集合中给定位置插入一行，返回该行的引用</li>
</ul>
<p>&lt;tr&gt;元素添加了以下属性和方法</p>
<ul>
<li>cells, 包含&lt;tr&gt;元素所有表元的 HTMLCollection</li>
<li>deleteCell(pos), 删除给定位置的表元</li>
<li>insertCell(pos), 在表元集合给定位置插入一个表元，返回该该表元的引用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建表格</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&quot;100%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表体</span></span><br><span class="line"><span class="keyword">let</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;tbody&quot;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,1&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">0</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二行</span></span><br><span class="line">tbody.<span class="title function_">insertRow</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">0</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">0</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 1,2&quot;</span>));</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="title function_">insertCell</span>(<span class="number">1</span>);</span><br><span class="line">tbody.<span class="property">rows</span>[<span class="number">1</span>].<span class="property">cells</span>[<span class="number">1</span>].<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Cell 2,2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把表格添加到文档主体</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure>
<h3 id="使用-NodeList">使用 NodeList</h3>
<p>理解 NodeList 对象和相关的 NameNodeMap、HTMLCollection，是理解 DOM 编程的关键。这 3 个集合类型都是&quot;实时的&quot;，意味着文档结构的变换会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = divs.<span class="property">length</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，最好限制操作 NodeList 的次数，因为每次查询都会搜索整个文档，所有最好把查询到的 NodeList 缓存起来。</p>
<h2 id="MutationObserver-接口">MutationObserver 接口</h2>
<p>MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档，DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p>
<h3 id="基本用法">基本用法</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">MutationRecord</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&lt;body&gt; 属性发生改变&quot;</span>, <span class="title class_">MutationRecord</span>));</span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;改变 body 类&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 body 类</span></span><br><span class="line"><span class="comment">// &lt;body&gt; 属性发生改变 [MutationRecord]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 disconnect()方法提前终止回调</span></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">className</span> = <span class="string">&quot;bar&quot;</span>; <span class="comment">// 不会有日志输出</span></span><br></pre></td></tr></table></figure>
<p>每个回调都会收到一个 MutationRecord 实例的数组。MutationRecord 实例包含的信息包括发生了什么变化，以及 DOM 的那一部分受到了影响。因为回调之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 MutationRecord 实例的数组。</p>
<h3 id="后续">后续</h3>
<p>略 🤣</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript - DOM扩展</title>
    <url>/Javascript-DOM-extend/</url>
    <content><![CDATA[<p>尽管DOM API 已经相当不错，但仍然不断有标准或专有的扩展出现，已支持更多功能。</p>
<h2 id="Selector-API">Selector API</h2>
<p>JavaScript 库中最流行的一种能力就是根据 CSS 选择符的模式匹配 DOM 元素。比如，jQuery 就完全 以 CSS 选择符查询 DOM 获取元素引用，而不是使用 getElementById()和 getElementsByTagName()。</p>
<p>Selectors API（参见 W3C 网站上的 Selectors API Level 1）是 W3C 推荐标准，规定了浏览器原生支 持的 CSS 查询 API。支持这一特性的所有 JavaScript 库都会实现一个基本的 CSS 解析器，然后使用已有 的 DOM 方法搜索文档并匹配目标节点。虽然库开发者在不断改进其性能，但 JavaScript 代码能做到的 毕竟有限。通过浏览器原生支持这个 API，解析和遍历 DOM 树可以通过底层编译语言实现，性能也有 了数量级的提升。</p>
<p>Selectors API Level 1 的核心是两个方法：querySelector()和 querySelectorAll()。在兼容浏 览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。</p>
<p>Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 matches()、find()和 findAll()。不过，目前还没有浏览器实现或宣称实现 find()和 findAll()。</p>
<h3 id="querySelector">querySelector()</h3>
<p>querySelector()方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配 项则返回 null。下面是一些例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得&lt;body&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> body = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;body&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#myDiv&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类名为&quot;selected&quot;的第一个元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得类名为&quot;button&quot;的图片</span></span><br><span class="line"><span class="keyword">let</span> img = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img.button&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>在 Document 上使用 querySelector()方法时，会从文档元素开始搜索；在 Element 上使用 querySelector()方法时，则只会从当前元素的后代中查询。</p>
<p>用于查询模式的 CSS 选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符， 则 querySelector()方法会抛出错误。</p>
<h3 id="querySelectorAll">querySelectorAll()</h3>
<p>querySelectorAll()方法跟 querySelector()一样，也接收一个用于查询的参数，但它会返回 所有匹配的节点，而不止一个。<strong>这个方法返回的是一个 NodeList 的静态实例</strong>。</p>
<p>再强调一次，querySelectorAll()返回的 NodeList 实例一个属性和方法都不缺，但它是一 个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 NodeList 对象可能造成的性能问题。</p>
<p>以有效 CSS 选择符调用 querySelectorAll()都会返回 NodeList，无论匹配多少个元素都可以。 如果没有匹配项，则返回空的 NodeList 实例。 与 querySelector()一样，querySelectorAll()也可以在 Document、DocumentFragment 和 Element 类型上使用。下面是几个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> ems = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">querySelectorAll</span>(<span class="string">&quot;em&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有类名中包含&quot;selected&quot;的元素</span></span><br><span class="line"><span class="keyword">let</span> selecteds = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;.selected&quot;</span>); </span><br><span class="line"><span class="comment">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span><br><span class="line"><span class="keyword">let</span> strongs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>); </span><br></pre></td></tr></table></figure>
<p>返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strongElements = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p strong&quot;</span>); </span><br><span class="line"><span class="comment">// 以下 3 个循环的效果一样</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> strong <span class="keyword">of</span> strongElements) &#123; </span><br><span class="line"> strong.<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> strongElements.<span class="title function_">item</span>(i).<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strongElements.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> strongElements[i].<span class="property">className</span> = <span class="string">&quot;important&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>querySelector()方法一样，如果选择符有语法错误或碰到不支持的选择符，则 querySelectorAll()方法会抛出错误。</p>
<h3 id="mathes">mathes()</h3>
<p>matches()方法（在规范草案中称为 matchesSelector()）接收一个 CSS 选择符参数，如果元素 匹配则该选择符返回 true，否则返回 false。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">matches</span>(<span class="string">&quot;body.page1&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// true </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>使用这个方法可以方便地检测某个元素会不会被 querySelector()或 querySelectorAll()方 法返回。</p>
<h2 id="HTML5-影响DOM节点部分">HTML5(影响DOM节点部分)</h2>
<p>HTML5 代表着与以前的 HTML 截然不同的方向。在所有以前的 HTML 规范中，从未出现过描述 JavaScript 接口的情形，HTML 就是一个纯标记语言。JavaScript 绑定的事，一概交给 DOM 规范去定义。 然而，HTML5 规范却包含了与标记相关的大量 JavaScript API 定义。其中有的 API 与 DOM 重合， 定义了浏览器应该提供的 DOM 扩展。</p>
<h3 id="CSS类扩展">CSS类扩展</h3>
<h4 id="getElementsByClassName">getElementsByClassName()</h4>
<p>getElementsByClassName()是 HTML5 新增的最受欢迎的一个方法，暴露在 document 对象和 所有 HTML 元素上。这个方法脱胎于基于原有 DOM 特性实现该功能的 JavaScript 库，提供了性能高好 的原生实现。</p>
<p>getElementsByClassName()方法接收一个参数，即包含一个或多个类名的字符串，返回类名中 包含相应类的元素的 NodeList。如果提供了多个类名，则顺序无关紧要。下面是几个示例:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得所有类名中包含&quot;username&quot;和&quot;current&quot;元素</span></span><br><span class="line"><span class="comment">// 这两个类名的顺序无关紧要</span></span><br><span class="line"><span class="keyword">let</span> allCurrentUsernames = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;username current&quot;</span>); </span><br><span class="line"><span class="comment">// 取得 ID 为&quot;myDiv&quot;的元素子树中所有包含&quot;selected&quot;类的元素</span></span><br><span class="line"><span class="keyword">let</span> selected = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;selected&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>如果要给包含特定类（而不是特定 ID 或标签）的元素添加事件处理程序，使用这个方法会很方便。 不过要记住，因为返回值是 NodeList，所以使用这个方法会遇到跟使用 getElementsByTagName()和其他返回 NodeList 对象的 DOM 方法同样的问题。</p>
<h4 id="classList-属性">classList 属性</h4>
<p>要操作类名，可以通过 className 属性实现添加、删除和替换。但 className 是一个字符串， 所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。以下面的 HTML 代码为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bd user disabled&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>这个&lt;div&gt;元素有 3 个类名。要想删除其中一个，就得先把 className 拆开，删除不想要的那个， 再把包含剩余类的字符串设置回去。比如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要删除&quot;user&quot;类</span></span><br><span class="line"><span class="keyword">let</span> targetClass = <span class="string">&quot;user&quot;</span>; </span><br><span class="line"><span class="comment">// 把类名拆成数组</span></span><br><span class="line"><span class="keyword">let</span> classNames = div.<span class="property">className</span>.<span class="title function_">split</span>(<span class="regexp">/\s+/</span>); </span><br><span class="line"><span class="comment">// 找到要删除类名的索引</span></span><br><span class="line"><span class="keyword">let</span> idx = classNames.<span class="title function_">indexOf</span>(targetClass); </span><br><span class="line"><span class="comment">// 如果有则删除</span></span><br><span class="line"><span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123; </span><br><span class="line"> classNames.<span class="title function_">splice</span>(i,<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 重新设置类名</span></span><br><span class="line">div.<span class="property">className</span> = classNames.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>); </span><br></pre></td></tr></table></figure>
<p>HTML5 通过给所有元素增加 classList 属性为这些操作提供了更简单也更安全的实现方式。 classList 是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList 也有 length 属性表示自己包含多少项，也可以通过 item()或中括号取得个别的元素。此外， DOMTokenList 还增加了以下方法。</p>
<ul>
<li>add(value)，向类名列表中添加指定的字符串值value。如果这个值已经存在，则什么也不做。</li>
<li>contains(value)，返回布尔值，表示给定的value是否存在</li>
<li>remove(value)，从类名列表中删除指定的字符串值value。</li>
<li>toggle(value)，如果类名列表中已经存在指定的value，则删除；如果不存在，则添加。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除&quot;disabled&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;disabled&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加&quot;current&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;current&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换&quot;user&quot;类</span></span><br><span class="line">div.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&quot;user&quot;</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测类名 </span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;bd&quot;</span>) &amp;&amp; !div.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&quot;disabled&quot;</span>))&#123; </span><br><span class="line"> <span class="comment">// 执行操作</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">// 迭代类名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">class</span> <span class="title class_">of</span> div.<span class="property">classList</span>)&#123; </span><br><span class="line"> <span class="title function_">doStuff</span>(<span class="keyword">class</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="焦点管理">焦点管理</h3>
<p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 document.activeElement，始终包含当前拥 有焦点的 DOM 元素。页面加载时，可以通过用户输入（按 Tab 键或代码中使用 focus()方法）让某个 元素自动获得焦点。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">activeElement</span> === button); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，document.activeElement 在页面刚加载完之后会设置为 document.body。而在 页面完全加载之前，document.activeElement 的值为 null。</p>
<p>其次是 document.hasFocus()方法，该方法返回布尔值，表示文档是否拥有焦点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>); </span><br><span class="line">button.<span class="title function_">focus</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()); <span class="comment">// true </span></span><br></pre></td></tr></table></figure>
<h3 id="HTMLDoucument扩展">HTMLDoucument扩展</h3>
<h4 id="readyState属性">readyState属性</h4>
<p>readyState 是 IE4 最早添加到 document 对象上的属性，后来其他浏览器也都依葫芦画瓢地支持 这个属性。最终，HTML5 将这个属性写进了标准。document.readyState 属性有两个可能的值：</p>
<ul>
<li>loading，表示文档正在加载</li>
<li>complete，表示文档加载完成</li>
</ul>
<p>实际开发中，最好是把 document.readState 当成一个指示器，以判断文档是否加载完毕。在这 个属性得到广泛支持以前，通常要依赖 onload 事件处理程序设置一个标记，表示文档加载完了。这个 属性的基本用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;complete&quot;</span>)&#123;  <span class="comment">// 执行操作 &#125; </span></span><br></pre></td></tr></table></figure>
<h4 id="compatMode-属性">compatMode 属性</h4>
<p>自从 IE6 提供了以标准或混杂模式渲染页面的能力之后，检测页面渲染模式成为一个必要的需求。 IE 为 document 添加了 compatMode 属性，这个属性唯一的任务是指示浏览器当前处于什么渲染模式。 如下面的例子所示，标准模式下 document.compatMode 的值是&quot;CSS1Compat&quot;，而在混杂模式下， document.compatMode 的值是&quot;BackCompat&quot;：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;CSS1Compat&quot;</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Standards mode&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Quirks mode&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>HTML5 最终也把 compatMode 属性的实现标准化了</p>
<h4 id="head-属性">head 属性</h4>
<p>作为对 document.body（指向文档的元素）的补充，HTML5 增加了 document.head 属 性，指向文档的元素。可以像下面这样直接取得元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> head = <span class="variable language_">document</span>.<span class="property">head</span></span><br></pre></td></tr></table></figure>
<h3 id="字符集属性">字符集属性</h3>
<p>HTML5 增加了几个与文档字符集有关的新属性。其中，characterSet 属性表示文档实际使用的 字符集，也可以用来指定新字符集。这个属性的默认值是&quot;UTF-16&quot;，但可以通过元素或响应头， 以及新增的 characterSeet 属性来修改。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">characterSet</span>); <span class="comment">// &quot;UTF-16&quot; </span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">characterSet</span> = <span class="string">&quot;UTF-8&quot;</span>; </span><br></pre></td></tr></table></figure>
<h3 id="自定义数据属性">自定义数据属性</h3>
<p>HTML5 允许给元素指定非标准的属性，但要使用前缀 data-以便告诉浏览器，这些属性既不包含 与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，data-后 面跟什么都可以。</p>
<p>义了自定义数据属性后，可以通过元素的 dataset 属性来访问。dataset 属性是一个 DOMStringMap 的实例，包含一组键/值对映射。元素的每个 data-name 属性在 dataset 中都可以通 过 data-后面的字符串作为键来访问（例如，属性 data-myname、data-myName 可以通过 myname 访 问，但要注意 data-my-name、data-My-Name 要通过 myName 来访问）。下面是一个使用自定义数据 属性的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本例中使用的方法仅用于示范</span></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 取得自定义数据属性的值</span></span><br><span class="line"><span class="keyword">let</span> appId = div.<span class="property">dataset</span>.<span class="property">appId</span>; </span><br><span class="line"><span class="keyword">let</span> myName = div.<span class="property">dataset</span>.<span class="property">myname</span>; </span><br><span class="line"><span class="comment">// 设置自定义数据属性的值</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">appId</span> = <span class="number">23456</span>; </span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">myname</span> = <span class="string">&quot;Michael&quot;</span>; </span><br><span class="line"><span class="comment">// 有&quot;myname&quot;吗？</span></span><br><span class="line"><span class="keyword">if</span> (div.<span class="property">dataset</span>.<span class="property">myname</span>)&#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;div.dataset.myname&#125;</span>`</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="插入标记">插入标记</h3>
<p>DOM 虽然已经为操纵节点提供了很多 API，但向文档中一次性插入大量 HTML 时还是比较麻烦。 相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个 HTML 字符串要简单（快速） 得多。HTML5 已经通过以下 DOM 扩展将这种能力标准化了.</p>
<h4 id="innerHTML">innerHTML</h4>
<p>在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。 而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。 比如下面的 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对于这里的&lt;div&gt;元素而言，其 innerHTML 属性会返回以下字符串：--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a <span class="tag">&lt;<span class="name">strong</span>&gt;</span>paragraph<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> with a list following it.<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>实际返回的文本内容会因浏览器而不同。IE 和 Opera 会把所有元素标签转换为大写，而 Safari、 Chrome 和 Firefox 则会按照文档源代码的格式返回，包含空格和缩进。因此不要指望不同浏览器的 innerHTML 会返回完全一样的值</p>
<p>在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。 因为所赋的值默认为 HTML，所以其中的所有标签都会以浏览器处理 HTML 的方式转换为元素（同样， 转换结果也会因浏览器不同而不同）。如果赋值中不包含任何 HTML 标签，则直接生成一个文本节点</p>
<p>在所有现代浏览器中，通过 innerHTML 插入的&lt;script&gt;标签是不会执行的。</p>
<h4 id="outerHTML">outerHTML</h4>
<p>读取 outerHTML 属性时，会返回调用它的元素（及所有后代元素）的 HTML 字符串。在写入 outerHTML 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;div id=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;d&quot;&gt;This is a div.&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> d = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;d&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">firstChild</span>.<span class="property">nodeName</span>);</span><br><span class="line"><span class="comment">// logs &quot;div&quot;</span></span><br><span class="line"></span><br><span class="line">d.<span class="property">outerHTML</span> = <span class="string">&quot;&lt;p&gt;This paragraph replaced the original div.&lt;/p&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">firstChild</span>.<span class="property">nodeName</span>);</span><br><span class="line"><span class="comment">// logs &quot;P&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #d div不再是文档树的一部分，新段替换了它。</span></span><br><span class="line"><span class="comment">    (不在页面中显示,但仍然在内存中) </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="内存与性能问题">内存与性能问题</h4>
<p>使用本节介绍的方法替换子节点可能在浏览器（特别是 IE）中导致内存问题。比如，如果被移除的 子树元素中之前有关联的事件处理程序或其他 JavaScript 对象（作为元素的属性），那它们之间的绑定关 系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 innerHTML、 outerHTML 和 insertAdjacentHTML()之前，最好手动删除要被替换的元素上关联的事件处理程序和 JavaScript 对象。</p>
<p>使用这些属性当然有其方便之处，特别是 innerHTML。一般来讲，插入大量的新 HTML 使用 innerHTML 比使用多次 DOM 操作创建节点再插入来得更便捷。这是因为 HTML 解析器会解析设置给 innerHTML（或 outerHTML）的值。解析器在浏览器中是底层代码（通常是 C++代码），比 JavaScript 快得多。不过，HTML 解析器的构建与解构也不是没有代价，因此最好限制使用 innerHTML 和 outerHTML 的次数</p>
<h4 id="跨站点脚本">跨站点脚本</h4>
<p>尽管 innerHTML 不会执行自己创建的&lt;script&gt;标签，但仍然向恶意用户暴露了很大的攻击面，因为通过它可以毫不费力地创建元素并执行 onclick 之类的属性。</p>
<p>如果页面中要使用用户提供的信息，则不建议使用 innerHTML。与使用 innerHTML 获得的方便相比，防止 XSS 攻击更让人头疼。此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。</p>
<h3 id="scrollIntoView">scrollIntoView()</h3>
<p>DOM 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5 选择了标准化 scrollIntoView()。</p>
<p>scrollIntoView()方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元 素进入视口。这个方法的参数如下：</p>
<ul>
<li>
<p>alignToTop 是一个布尔值</p>
<ul>
<li>true: 窗口滚动后元素的顶部与视口顶部对齐</li>
<li>false：窗口滚动后元素的底部与视口底部对齐</li>
</ul>
</li>
<li>
<p>scrollIntoViewOption 是一个选项对象</p>
<ul>
<li>behavior：定义过渡动画，可取的值为&quot;smooth&quot;和&quot;auto&quot;，默认为&quot;auto&quot;</li>
<li>block: 定义垂直方向的对齐，可取的值为&quot;start&quot;、“center”、“end&quot;和&quot;nearest”，默认为&quot;start&quot;</li>
<li>inline: 定义水平方向的对齐，可取的值为&quot;start&quot;、“center”、“end&quot;和&quot;nearest”，默认为&quot;nearest&quot;</li>
</ul>
</li>
<li>
<p>不传参数等同于alignToTop为True</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(); </span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(<span class="literal">true</span>); </span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;); </span><br><span class="line"><span class="comment">// 尝试将元素平滑地滚入视口</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>(&#123;<span class="attr">behavior</span>: <span class="string">&#x27;smooth&#x27;</span>, <span class="attr">block</span>: <span class="string">&#x27;start&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览 器将元素滚动到可见位置</p>
<h2 id="专有扩展">专有扩展</h2>
<h3 id="children">children</h3>
<p>children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> childCount = element.<span class="property">children</span>.<span class="property">length</span>; </span><br><span class="line"><span class="keyword">let</span> firstChild = element.<span class="property">children</span>[<span class="number">0</span>]; </span><br></pre></td></tr></table></figure>
<h3 id="contains">contains()</h3>
<p>DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 contains()方法， 让开发者可以在不遍历 DOM 的情况下获取这个信息。contains()方法应该在要搜索的祖先元素上调 用，参数是待确定的目标节点</p>
<p>如果目标节点是被搜索节点的后代，contains()返回 true，否则返回 false另外，使用 DOM Level 3 的 compareDocumentPosition()方法也可以确定节点间的关系。这个 方法会返回表示两个节点关系的位掩码</p>
<table>
<thead>
<tr>
<th style="text-align:center">掩码</th>
<th style="text-align:center">十进制</th>
<th style="text-align:left">节点关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1</td>
<td style="text-align:center">1</td>
<td style="text-align:left">断开(传入的节点不在文档中)</td>
</tr>
<tr>
<td style="text-align:center">0x2</td>
<td style="text-align:center">2</td>
<td style="text-align:left">领先(传入的节点在DOM树中位于参考节点之前)</td>
</tr>
<tr>
<td style="text-align:center">0x4</td>
<td style="text-align:center">4</td>
<td style="text-align:left">落后(传入的节点在DOM树中位于参考节点之后)</td>
</tr>
<tr>
<td style="text-align:center">0x8</td>
<td style="text-align:center">8</td>
<td style="text-align:left">包含(传入的节点是参考节点的祖先)</td>
</tr>
<tr>
<td style="text-align:center">0x10</td>
<td style="text-align:center">16</td>
<td style="text-align:left">被包含(传入的节点是参考节点的后代)</td>
</tr>
<tr>
<td style="text-align:center">0x20</td>
<td style="text-align:center">32</td>
<td style="text-align:left">待定</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">contains</span>(<span class="variable language_">document</span>.<span class="property">body</span>)); <span class="comment">// true </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">compareDocumentPosition</span>(<span class="variable language_">document</span>.<span class="property">body</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!(result &amp; <span class="number">0x10</span>)); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** result 的值为 20（或 0x14，其中 0x4 表示“随后”，加上 0x10“被包含”）。</span></span><br><span class="line"><span class="comment"> * 对result 和 0x10 应用按位与会返回非零值，而两个叹号将这个值转换成对应的布尔值。 </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>这里是模仿contains才与 0x10 进行按位与运算. 判断其他关系使用相应位掩码按位与即可</p>
</div>
<h3 id="插入标记-2">插入标记</h3>
<p>HTML5 将 IE 发明的 innerHTML 和 outerHTML 纳入了标准，但还有两个属性没有入选。这两个剩下的属性是 innerText 和 outerText。</p>
<h4 id="innerText-属性">innerText 属性</h4>
<p>innerText 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时， innerText 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，innerText 会移除元素的所有后代并插入一个包含该值的文本节点。</p>
<p>因为设置 innerText 只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必 须进行 HTML 编码。innerText 属性可以用于去除 HTML 标签。通过将 innerText 设置为等于 innerText，可以去除所有 HTML 标签而只剩文本，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.<span class="property">innerText</span> = div.<span class="property">innerText</span>; </span><br></pre></td></tr></table></figure>
<p>执行以上代码后，容器元素的内容只会包含原先的文本内容。</p>
<h4 id="outerText-属性">outerText 属性</h4>
<p>outerText 与 innerText 是类似的，只不过作用范围包含调用它的节点。要读取文本值时， outerText 与 innerText 实际上会返回同样的内容。但在写入文本值时，outerText 就大不相同了。 写入文本值时，outerText 不止会移除所有后代节点，而是会替换整个元素。</p>
<p>本质上，这相当于用新的文本节点替代 outerText 所在的元素。此时，原来的元素会与文档脱离 关系，因此也无法访问。</p>
<p>outerText 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现 重要的操作。除 Firefox 之外所有主流浏览器都支持 outerText</p>
<h3 id="滚动">滚动</h3>
<p>如前所述，滚动是 HTML5 之前 DOM 标准没有涉及的领域。虽然 HTML5 把 scrollIntoView() 标准化了，但不同浏览器中仍然有其他专有方法。比如，scrollIntoViewIfNeeded()作 为 HTMLElement 类型的扩展可以在所有元素上调用。scrollIntoViewIfNeeded(alingCenter)会在 元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见；如果已经在视口中可见，则这个方法 什么也不做。如果将可选的参数 alingCenter 设置为 true，则浏览器会尝试将其放在视口中央。Safari、 Chrome 和 Opera 实现了这个方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果不可见，则将元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>].<span class="title function_">scrollIntoViewIfNeeded</span>(); </span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-DOM-Style/Traverse</title>
    <url>/Javascript-DOM-Style&amp;Traverse/</url>
    <content><![CDATA[<h2 id="DOM-的演进">DOM 的演进</h2>
<p>DOM2 和 DOM3 Core 模块的目标是扩展 DOM API，满足 XML 的所有需求并提供更好的错误处理 和特性检测。很大程度上，这意味着支持 XML 命名空间的概念。DOM2 Core 没有新增任何类型，仅仅 在 DOM1 Core 基础上增加了一些方法和属性。DOM3 Core 则除了增强原有类型，也新增了一些新类型。</p>
<p>更多信息，请自行查阅🤣</p>
<h2 id="样式">样式</h2>
<p>HTML 中的样式有 3 种定义方式：外部样式表（通过&lt;link&gt;元素）、文档样式表（使用&lt;style&gt;元素）和元素特定样式（使用 style 属性）。DOM2 Style 为这 3 种应用样式的机制都提供了 API。</p>
<h3 id="存取元素样式">存取元素样式</h3>
<p>任何支持 style 属性的 HTML 元素在 JavaScript 中都会有一个对应的 style 属性。这个 style 属性是 CSSStyleDeclaration 类型的实例，其中包含通过 HTML style 属性为元素设置的所有样式信息，但不包含通过层叠机制从文档样式和外部样式中继承来的样式。HTML style 属性中的 CSS 属性在 JavaScript style 对象中都有对应的属性。因为 CSS 属性名使用连字符表示法（用连字符分隔两个单词，如 background-image），所以在 JavaScript 中这些属性必须转换为驼峰大小写形式（如backgroundImage）。</p>
<table>
<thead>
<tr>
<th>CSS属性</th>
<th>JavaScript 属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-image</td>
<td>style.backgroundImage</td>
</tr>
<tr>
<td>color</td>
<td>style.color</td>
</tr>
<tr>
<td>display</td>
<td>style.display</td>
</tr>
<tr>
<td>font-family</td>
<td>style.fontFamily</td>
</tr>
</tbody>
</table>
<p>大多数属性名会这样直接转换过来。但有一个 CSS 属性名不能直接转换，它就是 float。因为 float 是 JavaScript 的保留字，所以不能用作属性名。DOM2 Style 规定它在 style 对象中对应的属性 应该是 cssFloat。</p>
<p>任何时候，只要获得了有效 DOM 元素的引用，就可以通过 JavaScript 来设置样式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>); </span><br><span class="line"><span class="comment">// 设置背景颜色</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line"><span class="comment">// 修改大小</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;100px&quot;</span>; </span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;200px&quot;</span>; </span><br><span class="line"><span class="comment">// 设置边框</span></span><br><span class="line">myDiv.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&quot;1px solid black&quot;</span>; </span><br></pre></td></tr></table></figure>
<h4 id="DOM样式属性和方法">DOM样式属性和方法</h4>
<p>DOM2 Style 规范也在 style 对象上定义了一些属性和方法。这些属性和方法提供了元素 style 属性的信息并支持修改，列举如下。</p>
<ul>
<li>cssText，包含style属性中的CSS代码</li>
<li>length，应用给元素的CSS属性数量</li>
<li>parentRule，表示CSS信息的CSSRule对象</li>
<li>getPropertyPriority(propertyName) ，如果CSS属性propertyName使用了!important，则返回&quot;important&quot;，否则返回空字符串</li>
<li>getPropertyValue(propertyName)，返回属性propertyName的字符串值</li>
<li>item(index)，返回索引为index的CSS属性名</li>
<li>removeProperty(propertyName)，从样式表删除CSS属性propertyName</li>
<li>setProperty(propertyName, value, priority)，设置CSS属性propertyName的值为value，priority是&quot;important&quot;或空字符串</li>
<li>getPropertyCSSValue(propertyName)，返回包含 CSS 属性 propertyName 值的 CSSValue对象（已废弃）。</li>
</ul>
<p>通过 cssText 属性可以存取样式的 CSS 代码。在读模式下，cssText 返回 style 属性 CSS 代码在浏览器内部的表示。在写模式下，给 cssText 赋值会重写整个 style 属性的值，意味着之前通过style 属性设置的属性都会丢失</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> prop, value, i, len; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = myDiv.<span class="property">style</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> prop = myDiv.<span class="property">style</span>[i]; <span class="comment">// 或者用 myDiv.style.item(i) </span></span><br><span class="line"> value = myDiv.<span class="property">style</span>.<span class="title function_">getPropertyValue</span>(prop); </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prop: <span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="操作样式表">操作样式表</h3>
<p>CSSStyleSheet 类型表示 CSS 样式表，包括使用&lt;link&gt;元素和通过&lt;style&gt;元素定义的样式表。注意，这两个元素本身分别是 HTMLLinkElement 和 HTMLStyleElement。CSSStyleSheet 类型是一个通用样式表类型，可以表示以任何方式在 HTML 中定义的样式表。另外，元素特定的类型允许修改HTML 属性，而 CSSStyleSheet 类型的实例则是一个只读对象（只有一个属性例外）</p>
<p>CSSStyleSheet类型继承StyleSheet，后者可用作非CSS样式表的基类。以下是CSSStyleSheet从 StyleSheet 继承的属性</p>
<ul>
<li>disabled，布尔值，表示样式表是否被禁用了（这个属性是可读写的，因此将它设置为 true会禁用样式表）</li>
<li>href，如果是使用&lt;link&gt;包含的样式表，则返回样式表的 URL，否则返回 null。</li>
<li>media，样式表支持的媒体类型集合，这个集合有一个 length 属性和一个 item()方法，跟所有 DOM 集合一样。同样跟所有 DOM 集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表。</li>
<li>ownerNode，指向拥有当前样式表的节点，在 HTML 中要么是&lt;link&gt;元素要么是&lt;style&gt;元素（在 XML 中可以是处理指令）。如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性值为 null。</li>
<li>parentStyleSheet，如果当前样式表是通过@import 被包含在另一个样式表中，则这个属性指向导入它的样式表</li>
<li>title，ownerNode 的 title 属性。</li>
<li>type，字符串，表示样式表的类型。对 CSS 样式表来说，就是&quot;text/css&quot;。</li>
</ul>
<p>上述属性里除了 disabled，其他属性都是只读的。除了上面继承的属性，CSSStyleSheet 类型还支持以下属性和方法。</p>
<ul>
<li>cssRules，当前样式表包含的样式规则的集合。</li>
<li>ownerRule，如果样式表是使用@import 导入的，则指向导入规则；否则为 null。</li>
<li>deleteRule(index)，在指定位置删除 cssRules 中的规则。</li>
<li>insertRule(rule, index)，在指定位置向 cssRules 中插入规则。</li>
</ul>
<p>document.styleSheets 表示文档中可用的样式表集合。这个集合的 length 属性保存着文档中样式表的数量，而每个样式表都可以使用中括号或 item()方法获取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sheet = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="variable language_">document</span>.<span class="property">styleSheets</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[i]; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(sheet.<span class="property">href</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="CSS-规则">CSS 规则</h4>
<p>CSSRule 类型表示样式表中的一条规则。这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的 CSSStyleRule（其他 CSS 规则还有@import、@font-face、@page 和@charset 等，不过这些规则很少需要使用脚本来操作）。以下是 CSSStyleRule 对象上可用的属性</p>
<ul>
<li>cssText，返回整条规则的文本。</li>
<li>parentRule，如果这条规则被其他规则(如@media)包含，则指向包含规则，否则就是null</li>
<li>parentStyleSheet，包含当前绘制的样式表</li>
<li>selectorText，返回规则的选择符文本。</li>
<li>style，返回CSSStyleDeclaration对象，可以设置和获取当前规则中的样式</li>
<li>type，数值常量，表示规则类型。对于样式规则，它始终是-1</li>
</ul>
<p>这里的文本可能于样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样</p>
<p>在这些属性中，使用最多的是 cssText、selectorText 和 style。cssText 属性与 style.cssText类似，不过并不完全一样。前者包含选择符文本和环绕样式声明的大括号，而后者则只包含样式声明（类似于元素上的 style.cssText）。此外，cssText 是只读的，而 style.cssText 可以被重写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">假设这条规则位于页面中的第一个样式表中，而且是该样式表中唯一一条 CSS 规则</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">div.box &#123; </span></span><br><span class="line"><span class="comment"> background-color: blue; </span></span><br><span class="line"><span class="comment"> width: 100px; </span></span><br><span class="line"><span class="comment"> height: 200px; </span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">selectorText</span>); <span class="comment">// &quot;div.box&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">cssText</span>); <span class="comment">// 完整的 CSS 代码</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">backgroundColor</span>); <span class="comment">// &quot;blue&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">width</span>); <span class="comment">// &quot;100px&quot; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rule.<span class="property">style</span>.<span class="property">height</span>); <span class="comment">// &quot;200px&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sheet = <span class="variable language_">document</span>.<span class="property">styleSheets</span>[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">let</span> rules = sheet.<span class="property">cssRules</span> || sheet.<span class="property">rules</span>; <span class="comment">// 取得规则集合</span></span><br><span class="line"><span class="keyword">let</span> rule = rules[<span class="number">0</span>]; <span class="comment">// 取得第一条规则</span></span><br><span class="line">rule.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span> </span><br></pre></td></tr></table></figure>
<h4 id="创建规则">创建规则</h4>
<p>DOM 规定，可以使用 insertRule()方法向样式表中添加新规则。这个方法接收两个参数：规则 的文本和表示插入位置的索引值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sheet.<span class="title function_">insertRule</span>(<span class="string">&quot;body &#123; background-color: silver &#125;&quot;</span>, <span class="number">0</span>); <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure>
<p>这个例子插入了一条改变文档背景颜色的规则。这条规则是作为样式表的第一条规则（位置 0）插入的，顺序对规则层叠是很重要的。</p>
<p>虽然可以这样添加规则，但随着要维护的规则增多，很快就会变得非常麻烦。这时候，更好的方式是使用动态样式加载技术。</p>
<h4 id="删除规则">删除规则</h4>
<p>支持从样式表中删除规则的 DOM 方法是 deleteRule()，它接收一个参数：要删除规则的索引。要删除样式表中的第一条规则，可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sheet.<span class="title function_">deleteRule</span>(<span class="number">0</span>); <span class="comment">// 使用 DOM 方法</span></span><br></pre></td></tr></table></figure>
<p>与添加规则一样，删除规则并不是 Web 开发中常见的做法。考虑到可能影响 CSS 层叠的效果，删除规则时要慎重</p>
<h3 id="元素尺寸">元素尺寸</h3>
<p><a href="https://zh.javascript.info/size-and-scroll#ji-he">Javascript.info - 几何</a></p>
<p><img data-src="https://zh.javascript.info/article/size-and-scroll/metric-all.svg" alt=""></p>
<h4 id="偏移尺寸">偏移尺寸</h4>
<p>第一组属性涉及偏移尺寸（offset dimensions），包含元素在屏幕上占用的所有视觉空间。元素在页面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框（但不包含外边距）。以下 4 个属性用于取得元素的偏移尺寸</p>
<ul>
<li>offsetHeight，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度(如果可见)和上下边框的高度</li>
<li>offsetLeft，元素左边框外侧距离包含元素左边框内侧的像素数</li>
<li>offsetTop，元素上边框外侧距离包含元素上边框内侧的像素数</li>
<li>offsetWidth，元素在水平方向上占用的像素尺寸，包括他的宽度、垂直滚动条高度(如果可见)和左、右边框的宽度。</li>
</ul>
<p>其中，offsetLeft 和 offsetTop 是相对于包含元素的，包含元素保存在 offsetParent 属性中。offsetParent 不一定是 parentNode。比如，&lt;td&gt;元素的 offsetParent 是作为其祖先的&lt;table&gt;元素，因为&lt;table&gt;是节点层级中第一个提供尺寸的元素。</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/offsetSize.png" alt=""></p>
<p>要确定一个元素在页面中的偏移量，可以把它的 offsetLeft 和 offsetTop 属性分别与 offsetParent的相同属性相加，一直加到根元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getElementLeft</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualLeft = element.<span class="property">offsetLeft</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line"> actualLeft += current.<span class="property">offsetLeft</span>; </span><br><span class="line"> current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualLeft; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementTop</span>(<span class="params">element</span>) &#123; </span><br><span class="line"> <span class="keyword">let</span> actualTop = element.<span class="property">offsetTop</span>; </span><br><span class="line"> <span class="keyword">let</span> current = element.<span class="property">offsetParent</span>; </span><br><span class="line"> <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123; </span><br><span class="line"> actualTop += current.<span class="property">offsetTop</span>; </span><br><span class="line"> current = current.<span class="property">offsetParent</span>; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> actualTop; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="客户端尺寸">客户端尺寸</h4>
<p>元素的客户端尺寸（client dimensions）包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性：clientWidth 和 clientHeight。其中，clientWidth 是内容区宽度加左、右内边距宽度，clientHeight 是内容区高度加上、下内边距高度</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/clientSize.png" alt=""></p>
<p>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性最常用于确定浏览器视口尺寸，即检测 document.documentElement 的 clientWidth 和 clientHeight。这两个属性表示视口（&lt;html&gt;或&lt;body&gt;元素）的尺寸。</p>
<h4 id="滚动尺寸">滚动尺寸</h4>
<p>最后一组尺寸是滚动尺寸（scroll dimensions），提供了元素内容滚动距离的信息。有些元素，比如&lt;html&gt;无须任何代码就可以自动滚动，而其他元素则需要使用 CSS 的 overflow 属性令其滚动。滚动尺寸相关的属性有如下 4 个</p>
<ul>
<li>scrollHeight，没有滚动条出现时，元素内容的总高度</li>
<li>scrollLeft，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>
<li>scrollTop，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置</li>
<li>scrollWidth，没有出现滚动条时，元素内容的总宽度</li>
</ul>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/scrollSize.png" alt=""></p>
<p>scrollWidth 和 scrollHeight 可以用来确定给定元素内容的实际尺寸。例如，&lt;html&gt;元素是浏览器中滚动视口的元素。因此，document.documentElement.scrollHeight 就是整个页面垂直方向的总高度。</p>
<p>scrollWidth 和 scrollHeight 与 clientWidth 和 clientHeight 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等，scrollWidth 和 scollHeight 等于文档内容的宽度，而 clientWidth 和 clientHeight 等于视口的大小。</p>
<p>scrollLeft 和 scrollTop 属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于 0。如果元素在垂直方向上滚动，则 scrollTop 会大于 0，表示元素顶部不可见区域的高度。如果元素在水平方向上滚动，则 scrollLeft 会大于 0，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的，所以把它们都设置为 0 就可以重置元素的滚动位置。</p>
<h4 id="确定元素尺寸">确定元素尺寸</h4>
<p>浏览器在每个元素上都暴露了 getBoundingClientRect()方法，返回一个 DOMRect 对象，包含6 个属性：left、top、right、bottom、height 和 width。这些属性给出了元素在页面中相对于视口的位置</p>
<p><img data-src="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png" alt="DOMRect"></p>
<h2 id="遍历">遍历</h2>
<p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型—— NodeIterator 和 TreeWalker——从某个起点开始执行对 DOM 结构的深度优先遍历。</p>
<p>如前所述，DOM 遍历是对 DOM 结构的深度优先遍历，至少允许朝两个方向移动（取决于类型）。遍历以给定节点为根，不能在 DOM 中向上超越这个根节点</p>
<h3 id="NodeIterator">NodeIterator</h3>
<p>NodeIterator 类型是两个类型中比较简单的，可以通过 document.createNodeIterator()方法创建其实例。这个方法接收以下 4 个参数。</p>
<ul>
<li>root，作为遍历根节点的节点。</li>
<li>whatToShow，数值代码，表示应该访问哪些节点。</li>
<li>filter，NodeFilter 对象或函数，表示是否接收或跳过特定节点。</li>
<li>entityReferenceExpansion，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。</li>
</ul>
<p>whatToShow 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在 NodeFilter 类型中定义的。</p>
<ul>
<li>NodeFilter.SHOW_ALL，所有节点。</li>
<li>NodeFilter.SHOW_ELEMENT，元素节点。</li>
<li>NodeFilter.SHOW_ATTRIBUTE，属性节点。由于 DOM 的结构，因此实际上用不上</li>
<li>NodeFilter.SHOW_TEXT，文本节点。</li>
<li>NodeFilter.SHOW_CDATA_SECTION，CData 区块节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_ENTITY_REFERENCE，实体引用节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_ENTITY，实体节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_PROCESSING_INSTRUCTION，处理指令节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_COMMENT，注释节点。</li>
<li>NodeFilter.SHOW_DOCUMENT，文档节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_TYPE，文档类型节点。</li>
<li>NodeFilter.SHOW_DOCUMENT_FRAGMENT，文档片段节点。不是在 HTML 页面中使用的。</li>
<li>NodeFilter.SHOW_NOTATION，记号节点。不是在 HTML 页面中使用的</li>
</ul>
<p>这些值除了 NodeFilter.SHOW_ALL 之外，都可以组合使用。比如，可以像下面这样使用按位或 操作组合多个选项</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> whatToShow = <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span> | <span class="title class_">NodeFilter</span>.<span class="property">SHOW_TEXT</span>;</span><br></pre></td></tr></table></figure>
<p>createNodeIterator()方法的 filter 参数可以用来指定自定义 NodeFilter 对象，或者一个作为节点过滤器的函数NodeFilter 对象只有一个方法 acceptNode()，如果给定节点应该访问就返回 NodeFilter.FILTER_ACCEPT，否则返回NodeFilter.FILTER_SKIP。因为 NodeFilter 是一个抽象类型，所以不可能创建它的实例。只要创建一个包含 acceptNode()的对象，然后把它传给createNodeIterator()就可以了。以下代码定义了只接收&lt;p&gt;元素的节点过滤器对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> filter = &#123; </span><br><span class="line">   <span class="title function_">acceptNode</span>(<span class="params">node</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> node.<span class="property">tagName</span>.<span class="title function_">toLowerCase</span>() == <span class="string">&quot;p&quot;</span> ? <span class="title class_">NodeFilter</span>.<span class="property">FILTER_ACCEPT</span> : </span><br><span class="line">        <span class="title class_">NodeFilter</span>.<span class="property">FILTER_SKIP</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(root, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, filter, <span class="literal">false</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个简单的遍历所有节点的 NodeIterator</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(<span class="variable language_">document</span>, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ALL</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>NodeIterator 的两个主要方法是 nextNode()和 previousNode()。nextNode()方法在 DOM子树中以深度优先方式进前一步，而 previousNode()则是在遍历中后退一步。创建 NodeIterator对象的时候，会有一个内部指针指向根节点，因此第一次调用 nextNode()返回的是根节点。当遍历到达 DOM 树最后一个节点时，nextNode()返回 null。previousNode()方法也是类似的。当遍历到达DOM 树最后一个节点时，调用 previousNode()返回遍历的根节点后，再次调用也会返回 null。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">li</span>&gt;</span>List item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历&lt;div&gt;元素内部的所有元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> iterator = <span class="variable language_">document</span>.<span class="title function_">createNodeIterator</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line"><span class="keyword">let</span> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); <span class="comment">// 输出标签名</span></span><br><span class="line"> node = iterator.<span class="title function_">nextNode</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>nextNode()和 previousNode()方法共同维护 NodeIterator 对 DOM 结构的内部指针，因此修改 DOM 结构也会体现在遍历中。</p>
<h3 id="TreeWalker">TreeWalker</h3>
<p>TreeWalker 是 NodeIterator 的高级版。除了包含同样的 nextNode()、previousNode()方法，TreeWalker 还添加了如下在 DOM 结构中向不同方向遍历的方法。</p>
<ul>
<li>parentNode()，遍历到当前节点的父节点</li>
<li>firstChild()，遍历到当前节点的第一个子节点</li>
<li>lastChild()，遍历到当前节点的最后一个子节点</li>
<li>nextSibling()，遍历到当前节点的下一个同胞节点</li>
<li>previousSibling()，遍历到当前节点的上一个同胞节点</li>
</ul>
<p>TreeWalker 对象要调用 document.createTreeWalker()方法来创建，这个方法接收与document.createNodeIterator()同样的参数：作为遍历起点的根节点、要查看的节点类型、节点过滤器和一个表示是否扩展实体引用的布尔值。因为两者很类似，所以 TreeWalker 通常可以取代NodeIterator</p>
<p>不同的是，节点过滤器（filter）除了可以返回 NodeFilter.FILTER_ACCEPT 和 NodeFilter. FILTER_SKIP，还可以返回 NodeFilter.FILTER_REJECT。在使用 NodeIterator 时，NodeFilter. FILTER_SKIP 和 NodeFilter.FILTER_REJECT 是一样的。但在使用 TreeWalker 时，NodeFilter. FILTER_SKIP 表示跳过节点，访问子树中的下一个节点，而NodeFilter.FILTER_REJECT 则表示跳过该节点以及该节点的整个子树。例如，如果把前面示例中的过滤器函数改为返回 NodeFilter. FILTER_REJECT（而不是 NodeFilter.FILTER_SKIP），则会导致遍历立即返回，不会访问任何节点。这是因为第一个返回的元素是&lt;div&gt;，其中标签名不是&quot;li&quot;，因此过滤函数返回 NodeFilter.FILTER_ REJECT，表示要跳过整个树。因为&lt;div&gt;本身就是遍历的根节点，所以遍历会就此结束。</p>
<p>当然，TreeWalker 真正的威力是可以在 DOM 结构中四处游走。如果不使用过滤器，单纯使用TreeWalker 的漫游能力同样可以在 DOM 树中访问&lt;li&gt;元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>); </span><br><span class="line"><span class="keyword">let</span> walker = <span class="variable language_">document</span>.<span class="title function_">createTreeWalker</span>(div, <span class="title class_">NodeFilter</span>.<span class="property">SHOW_ELEMENT</span>, <span class="literal">null</span>, <span class="literal">false</span>); </span><br><span class="line">walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往&lt;p&gt; </span></span><br><span class="line">walker.<span class="title function_">nextSibling</span>(); <span class="comment">// 前往&lt;ul&gt; </span></span><br><span class="line"><span class="keyword">let</span> node = walker.<span class="title function_">firstChild</span>(); <span class="comment">// 前往第一个&lt;li&gt; </span></span><br><span class="line"><span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">tagName</span>); </span><br><span class="line"> node = walker.<span class="title function_">nextSibling</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-DOM-range</title>
    <url>/Javascript-DOM-range/</url>
    <content><![CDATA[<h2 id="范围">范围</h2>
<p>为了支持对页面更细致的控制，DOM2 Traversal and Range 模块定义了范围接口。范围可用于在文档中选择内容，而不用考虑节点之间的界限。（选择在后台发生，用户是看不到的。）范围在常规 DOM操作的粒度不够时可以发挥作用。</p>
<h3 id="DOM范围">DOM范围</h3>
<p>DOM2 在 Document 类型上定义了一个 createRange()方法，暴露在 document 对象上。使用这个方法可以创建一个 DOM 范围对象</p>
<p>与节点类似，这个新创建的范围对象是与创建它的文档关联的，不能在其他文档中使用。然后可以使用这个范围在后台选择文档特定的部分。创建范围并指定它的位置之后，可以对范围的内容执行一些操作，从而实现对底层 DOM 树更精细的控制。</p>
<span id="more"></span>
<p>每个范围都是 Range 类型的实例，拥有相应的属性和方法</p>
<ul>
<li>startContainer，范围起点所在的节点(选区中第一个子节点的父节点)</li>
<li>startOffset，范围起点在startContainer中的偏移量。如果startContainer是文本节点、注释节点或CData区块节点，则startOffset指范围起点之前跳过的字符数；否则，表示范围中第一个节点的索引</li>
<li>endContainer，范围终点所在的节点(选区中最后一个子节点的父节点)</li>
<li>endOffset，范围起点在startContainer中的偏移量(与startOffset中偏移量的含义相同)</li>
<li>commonAncestorContainer，文档中以startContainer和endContainer为后代的最深的节点</li>
</ul>
<p>这些属性会在范围被放到文档中特定位置时获得响应的值</p>
<h3 id="简单选择">简单选择</h3>
<p>通过范围选择文档中某个部分最简单的方式，就是使用selectNode()或selectNodeContenets()方法。这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。selectNode()方法选择整个节点，包含其后代节点，而selectNodeContents()只选择节点的后代</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"><span class="keyword">let</span> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">range1.<span class="title function_">selectNode</span>(p1); </span><br><span class="line">range2.<span class="title function_">selectNodeContents</span>(p1); </span><br></pre></td></tr></table></figure>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/simpleRangeSelect.png" alt=""></p>
<p>调用 selectNode()时，startContainer、endContainer 和 commonAncestorContainer 都等于传入节点的父节点。在这个例子中，这几个属性都等于 document.body。startOffset 属性等于传入节点在其父节点 childNodes 集合中的索引（在这个例子中，startOffset 等于 1，因为 DOM的合规实现把空格当成文本节点），而 endOffset 等于 startOffset 加 1（因为只选择了一个节点）。</p>
<p>在调用 selectNodeContents()时，startContainer、endContainer 和 commonAncestor<br>
Container 属性就是传入的节点，在这个例子中是&lt;p&gt;元素。startOffset 属性始终为 0，因为范围从传入节点的第一个子节点开始，而 endOffset 等于传入节点的子节点数量（node.child Nodes.length），在这个例子中等于 2。</p>
<p>在像上面这样选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制</p>
<ul>
<li>setStartBefore(refNode)，把范围的起点设置到refNode之前，从而让refNode成为选区的第一个子节点。startContainer属性被设置为refNode.parentNode，而startOffset属性被设置为refNode在其父节点childNodes集合中的索引</li>
<li>setStartAfter(refNode)，把范围的起点设置到refNode之后，从而将refNode排除在选区之外，让其下一个同胞节点成为选区的第一个字节点。startContainer属性被refNode.parentNode，startOffset属性被设置为refNode在其父节点childNodes集合中的索引加1</li>
<li>setEndBefore(refNode)，把范围的终点设置到refNode之前，从而将refNode排除在选区之外、让其上一个同胞节点成为选区的最后一个字节点。endContainer属性被设置为refNode.parentNode，endOffset属性被设置为refNode在其父节点childNodes集合中的索引</li>
<li>setEndAfter(refNode)，把范围的终点设置到refNode之后，从而让refNode成为选区的最后一个子节点。endContainer属性被设置为refNode.parentNode，endOffset属性被设置为refNode在其父节点child集合中的索引加1</li>
</ul>
<p>调用这些方法时，所有属性都会自动重新赋值。不过，为了实现复杂的选区，也可以直接修改这些属性的值</p>
<h3 id="复杂选择">复杂选择</h3>
<p>要创建复杂的范围，需要使用setStart()和setEnd()方法。这两个方法都接收两个参数：参照节点和偏移量。对setStart()来说，参照节点会成为startContainer，而偏移量会赋值给startOffset。对setEnd()而言，参照节点会成为endContainer，而偏移量会赋值给endOffset。</p>
<p>使用这两个方法，可以模拟 selectNode()和 selectNodeContents()的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"><span class="keyword">let</span> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p1Index = -<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> i</span><br><span class="line"><span class="keyword">let</span> len</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, len = p1.<span class="property">parentNode</span>.<span class="property">childNodes</span>.<span class="property">length</span>; i &lt; len; i++) &#123; </span><br><span class="line"> <span class="keyword">if</span> (p1.<span class="property">parentNode</span>.<span class="property">childNodes</span>[i] === p1) &#123; </span><br><span class="line">   p1Index = i; </span><br><span class="line">   <span class="keyword">break</span>; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range1.<span class="title function_">setStart</span>(p1.<span class="property">parentNode</span>, p1Index); </span><br><span class="line">range1.<span class="title function_">setEnd</span>(p1.<span class="property">parentNode</span>, p1Index + <span class="number">1</span>); </span><br><span class="line">range2.<span class="title function_">setStart</span>(p1, <span class="number">0</span>); </span><br><span class="line">range2.<span class="title function_">setEnd</span>(p1, p1.<span class="property">childNodes</span>.<span class="property">length</span>); </span><br></pre></td></tr></table></figure>
<p>注意，要选择节点（使用 range1），必须先确定给定节点（p1）在其父节点 childNodes 集合中的索引。而要选择节点的内容（使用 range2），则不需要这样计算，因为可以直接给 setStart()和setEnd()传默认值。虽然可以模拟 selectNode()和 selectNodeContents()，但 setStart()和setEnd()真正的威力还是选择节点中的某个部分。</p>
<p>假设我们想通过范围从前面示例中选择从&quot;Hello&quot;中的&quot;llo&quot;到&quot; world!&quot;中的&quot;o&quot;的部分。很简单，第一步是取得所有相关节点的引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span></span><br><span class="line"><span class="keyword">let</span> worldNode = p1.<span class="property">lastChild</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>因为选区起点在&quot;Hello&quot;中的字母&quot;e&quot;之后，所以要给 setStart()传入 helloNode 和偏移量 2（&quot;e&quot;后面的位置，&quot;H&quot;的位置是 0）。要设置选区终点，则要给 setEnd()传入 worldNode 和偏移量 3，即不属于选区的第一个字符的位置，也就是&quot;r&quot;的位置 3（位置 0 是一个空格）。<strong>也就是半开区间 [ start, end )</strong></p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/compRangeSelect.png" alt=""></p>
<p>因为 helloNode 和 worldNode 是文本节点，所以它们会成为范围的 startContainer 和endContainer，这样startOffset 和 endOffset 实际上表示每个节点中文本字符的位置，而不是子节点的位置（传入元素节点时的情形）。而commonAncestorContainer 是&lt;p&gt;元素，即包含这两个节点的第一个祖先节点。</p>
<p>当然，只选择文档中的某个部分并不是特别有用，除非可以对选中部分执行操作</p>
<h3 id="操作范围">操作范围</h3>
<p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。为操作范围的内容，选区中的内容必须格式完好。在前面的例子中，因为范围的起点和终点都在文本节点内部，并不是完好的 DOM 结构，所以无法在 DOM 中表示。不过，范围能够确定缺失的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作。</p>
<p>仍以前面例子中的范围来说，范围发现选区中缺少一个开始的&lt;b&gt;标签，于是会在后台动态补上这个标签，同时还需要补上封闭&quot;He&quot;的结束标签&lt;/b&gt;，结果会把 DOM 修改为这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>而且，&quot; world!“文本节点会被拆分成两个文本节点，一个包含” wo&quot;，另一个包含&quot;rld!&quot;</p>
<p>这样创建了范围之后，就可以使用很多方法来操作范围的内容。（注意，范围对应文档片段中的所有节点，都是文档中相应节点的指针。）</p>
<p>第一个方法最容易理解和使用：deleteContents()。顾名思义，这个方法会从文档中删除范围包含的节点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>), </span><br><span class="line"> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span>, </span><br><span class="line"> worldNode = p1.<span class="property">lastChild</span>, </span><br><span class="line"> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line">range.<span class="title function_">deleteContents</span>(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">执行上面的代码之后，页面中的 HTML 会变成这样：&lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>因为前面介绍的范围选择过程通过修改底层 DOM 结构保证了结构完好，所以即使删除范围之后，剩下的 DOM 结构照样是完好的。</p>
<p>另一个方法 extractContents()跟 deleteContents()类似，也会从文档中移除范围选区。但不同的是，extractContents()方法返回范围对应的文档片段。这样，就可以把范围选中的内容插入文档中其他地方</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span></span><br><span class="line"><span class="keyword">let</span> worldNode = p1.<span class="property">lastChild</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"></span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> fragment_1 = range.<span class="title function_">extractContents</span>(); </span><br><span class="line">p1.<span class="property">parentNode</span>.<span class="title function_">appendChild</span>(fragment_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** result:</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;b&gt;He&lt;/b&gt;rld!&lt;/p&gt; </span></span><br><span class="line"><span class="comment">  &lt;b&gt;llo&lt;/b&gt; wo </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不想把范围从文档中移除，也可以使用 cloneContents()创建一个副本，然后把这个副本插入到文档其他地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fragment_2 = range.<span class="title function_">cloneContents</span>(); </span><br><span class="line">p1.<span class="property">parentNode</span>.<span class="title function_">appendChild</span>(fragment_2);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** result:</span></span><br><span class="line"><span class="comment">  &lt;p&gt;&lt;b&gt;Hello&lt;/b&gt; world!&lt;/p&gt; </span></span><br><span class="line"><span class="comment">  &lt;b&gt;llo&lt;/b&gt; wo </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="范围插入">范围插入</h3>
<p>使用insertNode()方法可以在范围选区的开始位置插入一个节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入: &lt;span style=&quot;color: red&quot;&gt;Inserted text&lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span> </span><br><span class="line"><span class="keyword">let</span> worldNode = p1.<span class="property">lastChild</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line">range.<span class="title function_">setStart</span>(helloNode, <span class="number">2</span>); </span><br><span class="line">range.<span class="title function_">setEnd</span>(worldNode, <span class="number">3</span>); </span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>; </span><br><span class="line">span.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Inserted text&quot;</span>)); </span><br><span class="line">range.<span class="title function_">insertNode</span>(span); </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>He<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span>Inserted text<span class="tag">&lt;/<span class="name">span</span>&gt;</span>llo<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，&lt;span&gt;正好插入到&quot;Hello&quot;中的&quot;llo&quot;之前，也就是范围选区的前面。同时，也要注意原始的 HTML 并没有添加或删除&lt;b&gt;元素，因为这里并没有使用之前提到的方法。使用这个技术可以插入有用的信息，比如在外部链接旁边插入一个小图标。</p>
<p>除了向范围中插入内容，还可以使用 surroundContents()方法插入包含范围的内容。这个方法接收一个参数，即包含范围内容的节点。调用这个方法时，后台会执行如下操作：</p>
<ol>
<li>提取出范围的内容</li>
<li>在原始文档中范围之前所在的位置插入给定的节点</li>
<li>将范围对应文档的内容添加到给定节点</li>
</ol>
<p>这种功能适合在网页中高亮显示某些关键词</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> helloNode = p1.<span class="property">firstChild</span>.<span class="property">firstChild</span></span><br><span class="line"><span class="keyword">let</span> worldNode = p1.<span class="property">lastChild</span></span><br><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>()</span><br><span class="line"></span><br><span class="line">range.<span class="title function_">selectNode</span>(helloNode); </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> span = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;span&quot;</span>); </span><br><span class="line">span.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;yellow&quot;</span>; </span><br><span class="line"></span><br><span class="line">range.<span class="title function_">surroundContents</span>(span); </span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color:yellow&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="范围折叠">范围折叠</h3>
<p>如果范围并没有选择文档的任何部分，则称为折叠（collapsed）。折叠范围有点类似文本框：如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。而在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/rangeCollapsed.png" alt=""></p>
<p>折叠范围可以使用 collapse()方法，这个方法接收一个参数：布尔值，表示折叠到范围哪一端。true 表示折叠到起点，false 表示折叠到终点。要确定范围是否已经被折叠，可以检测范围的 collapsed属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">range.<span class="title function_">collapse</span>(<span class="literal">true</span>); <span class="comment">// 折叠到起点</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range.<span class="property">collapsed</span>); <span class="comment">// 输出 true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">&lt;p id=&quot;p1&quot;&gt;Paragraph 1&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;p id=&quot;p2&quot;&gt;Paragraph 2&lt;/p&gt; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> range = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line"></span><br><span class="line">range.<span class="title function_">setStartAfter</span>(p1); </span><br><span class="line">range.<span class="title function_">setStartBefore</span>(p2); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range.<span class="property">collapsed</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="范围比较">范围比较</h3>
<p>如果有多个范围，则可以使用 compareBoundaryPoints()方法确定范围之间是否存在公共的边界（起点或终点）。这个方法接收两个参数：要比较的范围和一个常量值，表示比较的方式。这个常量参数包括</p>
<ul>
<li>Range.START_TO_START(0)，比较两个范围的起点</li>
<li>Range.START_TO_END(1)，比较第一个范围的起点和第二个范围的终点</li>
<li>Range.END_TO_END(2)，比较两个范围的终点</li>
<li>Range.END_TO_START(3)，比较第一个范围的终点和第二个范围的起点</li>
</ul>
<p>compareBoundaryPoints()方法在第一个范围的边界点位于第二个范围的边界点之前时返回-1， 在两个范围的边界点相等时返回 0，在第一个范围的边界点位于第二个范围的边界点之后时返回 1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">b</span>&gt;</span> world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range1 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line"><span class="keyword">let</span> range2 = <span class="variable language_">document</span>.<span class="title function_">createRange</span>(); </span><br><span class="line"><span class="keyword">let</span> p1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;p1&quot;</span>); </span><br><span class="line"></span><br><span class="line">range1.<span class="title function_">selectNodeContents</span>(p1); </span><br><span class="line">range2.<span class="title function_">selectNodeContents</span>(p1); </span><br><span class="line">range2.<span class="title function_">setEndBefore</span>(p1.<span class="property">lastChild</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range1.<span class="title function_">compareBoundaryPoints</span>(<span class="title class_">Range</span>.<span class="property">START_TO_START</span>, range2)); <span class="comment">// 0 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(range1.<span class="title function_">compareBoundaryPoints</span>(<span class="title class_">Range</span>.<span class="property">END_TO_END</span>, range2)); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure>
<h3 id="复制范围-清理">复制范围 &amp; 清理</h3>
<p>调用范围的 cloneRange()方法可以复制范围。新范围包含与原始范围一样的属性，修改其边界点不会影响原始范围</p>
<p>在使用完范围之后，最好调用 detach()方法把范围从创建它的文档中剥离。调用 detach()之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newRange = range.<span class="title function_">cloneRange</span>(); </span><br><span class="line"></span><br><span class="line">range.<span class="title function_">detach</span>(); <span class="comment">// 从文档中剥离范围</span></span><br><span class="line">range = <span class="literal">null</span>; <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure>
<p>这两步是最合理的结束使用范围的方式。剥离之后的范围就不能再使用了</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript - Date</title>
    <url>/Javascript-Date/</url>
    <content><![CDATA[<h2 id="Date">Date</h2>
<p>要创建日期对象，就使用 new 操作符来调用 Date 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在不给Date()传参数的时候，创建的对象将保存当前的日期和时间。</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要基于其他日期和时间建立日期对象，必须传入其毫秒表示(UNIX纪元1970年1月1日午夜之后的毫秒数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Date.parse() */</span></span><br><span class="line"><span class="comment">// 月/日/年</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&quot;3/18/1998&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> otherDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;3/18/1998&quot;</span>); <span class="comment">// 等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Date.UTC() */</span></span><br><span class="line"><span class="comment">// *年-*月(0-11)-日(1-31)-时(0-23)-分-秒-毫秒</span></span><br><span class="line"><span class="comment">// GMT 时间 2021年1月13日1时06分55秒</span></span><br><span class="line"><span class="keyword">let</span> nowDate_1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2021</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">05</span>, <span class="number">55</span>)); <span class="comment">// 无引号</span></span><br><span class="line"><span class="keyword">let</span> nowDate_2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2021</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">05</span>, <span class="number">55</span>); <span class="comment">// 等价</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Date.now() */</span></span><br><span class="line"><span class="comment">// 返回表示方法执行时日期和时间的毫秒数</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">let</span> stop = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">let</span> result = stop - start;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="字符串方法">字符串方法</h3>
<mark class="label info">Date 类型的</mark>
<ul>
<li>toLocaleString()方法 返回与浏览器运行的本地环境一致的时间和日期。这通常意味着格式中包含针对时间的AM或PM，但不包含时区信息(具体格式  可能因浏览器而不同)</li>
<li>toString()方法 返回带时区信息的日期和时间，而时间也是24小时制表示的</li>
<li>valueOf()方法 不返回字符串，这个方法被重写后返回的是日期的毫秒表示</li>
<li>toDateString() 显示日期中的周几、月、日、年(格式特定于实现)</li>
<li>toTimeString() 显示日期中的时、分、秒和时区(格式特定与实现)</li>
<li>toLocaleDateString() 显示日期中的周几、月、日、年(格式特定于实现和地区)</li>
<li>toLocaleTimeString() 显示日期中的时、分、秒和时区(格式特定与实现)</li>
<li>toUTCString() 显示完整UTC日期(格式特定于实现)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toLocaleString</span>()); <span class="comment">// 2021/1/13 上午1:25:05</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toString</span>()); <span class="comment">// Wed Jan 13 2021 01:29:11 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">valueOf</span>()); <span class="comment">// 1610472551838</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toDateString</span>()); <span class="comment">// Wed Jan 13 2021</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toTimeString</span>()); <span class="comment">// 01:39:22 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toLocaleDateString</span>()); <span class="comment">// 2021/1/13</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toLocaleTimeString</span>()); <span class="comment">// 上午1:39:22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">toUTCString</span>()); <span class="comment">// 1610472Tue, 12 Jan 2021 17:39:22 GMT551838</span></span><br></pre></td></tr></table></figure>
<h3 id="日期-时间组件方法">日期/时间组件方法</h3>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">getTime()</td>
<td style="text-align:left">返回日期的毫秒数；与 valueOf()相同</td>
</tr>
<tr>
<td style="text-align:left">setTime(milliseconds)</td>
<td style="text-align:left">设置日期的毫秒数，从而修改整个日期</td>
</tr>
<tr>
<td style="text-align:left">getFullYear()</td>
<td style="text-align:left">返回四位年数(即 2021 而不是 21)</td>
</tr>
<tr>
<td style="text-align:left">getUTCFullYear()</td>
<td style="text-align:left">返回 UTC 日期的四位年数</td>
</tr>
<tr>
<td style="text-align:left">setFullYear(year)</td>
<td style="text-align:left">设置日期的年(year 必须是 4 位数)</td>
</tr>
<tr>
<td style="text-align:left">setUTCFullYear(year)</td>
<td style="text-align:left">设置 UTC 日期的年(year 必须是四位数)</td>
</tr>
<tr>
<td style="text-align:left">getMonth()</td>
<td style="text-align:left">返回日期的月(0 表示 1 月，11 表示 12 月)</td>
</tr>
<tr>
<td style="text-align:left">getUTCMonth()</td>
<td style="text-align:left">返回 UTC 日期的月(0 表示 1 月，11 表示 12 月)</td>
</tr>
<tr>
<td style="text-align:left">setMonth(month)</td>
<td style="text-align:left">设置日期的月(month 为大于 0 的数值，大于 11 加年)</td>
</tr>
<tr>
<td style="text-align:left">setUTCMonth(month)</td>
<td style="text-align:left">设置 UTC 日期的月(month 为大于 0 的数值，大于 11 加年)</td>
</tr>
<tr>
<td style="text-align:left">getDate()</td>
<td style="text-align:left">返回日期中的日(1~31)</td>
</tr>
<tr>
<td style="text-align:left">getUTCDate()</td>
<td style="text-align:left">返回 UTC 日期中的日(1~31)</td>
</tr>
<tr>
<td style="text-align:left">setDate(date)</td>
<td style="text-align:left">设置日期的日(如果 date 大于该月天数，则加月)</td>
</tr>
<tr>
<td style="text-align:left">setUTCDate(date)</td>
<td style="text-align:left">设置 UTC 日期的日(如果 date 大于该月天数，则加月)</td>
</tr>
<tr>
<td style="text-align:left">getDay()</td>
<td style="text-align:left">返回日期中表示周几的数值(0 表示周日，6 表示周六)</td>
</tr>
<tr>
<td style="text-align:left">getUTCDay()</td>
<td style="text-align:left">返回 UTC 日期中表示周几的数值(0 表示周日，6 表示周六)</td>
</tr>
<tr>
<td style="text-align:left">getHours()</td>
<td style="text-align:left">返回日期中的时(0~23)</td>
</tr>
<tr>
<td style="text-align:left">getUTCHours()</td>
<td style="text-align:left">返回 UTC 日期中的时(0~23)</td>
</tr>
<tr>
<td style="text-align:left">setHours(hours)</td>
<td style="text-align:left">设置日期中的时(如果 hours 大于 23，则加日)</td>
</tr>
<tr>
<td style="text-align:left">setUTCHours(hours)</td>
<td style="text-align:left">设置 UTC 日期中的时(如果 hours 大于 23，则加日)</td>
</tr>
<tr>
<td style="text-align:left">getMinutes()</td>
<td style="text-align:left">返回日期中的分(0~59)</td>
</tr>
<tr>
<td style="text-align:left">getUTCMinutes()</td>
<td style="text-align:left">返回 UTC 日期中的分(0~59)</td>
</tr>
<tr>
<td style="text-align:left">setMinutes(minutes)</td>
<td style="text-align:left">设置日期中的分(如果 minutes 大于 59，则加时)</td>
</tr>
<tr>
<td style="text-align:left">setUTCMinutes(minutes)</td>
<td style="text-align:left">设置 UTC 日期中的分(如果 minutes 大于 59，则加时)</td>
</tr>
<tr>
<td style="text-align:left">getSeconds()</td>
<td style="text-align:left">返回日期中的秒(0~59)</td>
</tr>
<tr>
<td style="text-align:left">getUTCSeconds()</td>
<td style="text-align:left">返回 UTC 日期中的秒(0~59)</td>
</tr>
<tr>
<td style="text-align:left">setSeconds(seconds)</td>
<td style="text-align:left">设置日期中的秒(如果 seconds 大于 59，则加分)</td>
</tr>
<tr>
<td style="text-align:left">setUTCSeconds(seconds)</td>
<td style="text-align:left">设置 UTC 日期中的秒(如果 seconds 大于 59，则加分)</td>
</tr>
<tr>
<td style="text-align:left">getMillseconds()</td>
<td style="text-align:left">返回日期中的毫秒</td>
</tr>
<tr>
<td style="text-align:left">getUTCMillseconds()</td>
<td style="text-align:left">返回 UTC 日期中的毫秒</td>
</tr>
<tr>
<td style="text-align:left">setMillseconds(millseconds)</td>
<td style="text-align:left">设置日期中的毫秒</td>
</tr>
<tr>
<td style="text-align:left">setUTCMillseconds(millseconds)</td>
<td style="text-align:left">设置 UTC 日期中的毫秒</td>
</tr>
<tr>
<td style="text-align:left">getTimezoneOffset()</td>
<td style="text-align:left">返回以分钟计的 UTC 与本地时区的偏移量</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getTime</span>()); <span class="comment">// 1610474569539</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">setTime</span>(now.<span class="title function_">getTime</span>() / <span class="number">2</span>)); <span class="comment">// Sun Jul 09 1995 05:01:24 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(now.<span class="title function_">getTimezoneOffset</span>()); <span class="comment">// -480</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Event-1</title>
    <url>/Javascript-Event-1/</url>
    <content><![CDATA[<h2 id="事件流">事件流</h2>
<p>事件流描述了页面接收事件的顺序。</p>
<h3 id="事件冒泡">事件冒泡</h3>
<p>IE 事件流被称为事件冒泡，这是因为事件被定义为从最具体的元素(文档树中最深的节点)开始触发，然后向上传播指没有那么具体的元素(文档)。比如有如下 HTML 页面</p>
<span id="more"></span>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件冒泡示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在点击页面中的&lt;div&gt;元素后，click 事件会以如下顺序发生：</p>
<ol>
<li>&lt;div&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;html&gt;</li>
<li>document</li>
</ol>
<p>所有现代浏览器都支持事件冒泡，只是在实现方式上会有一些变化。IE5.5 及早期版本会跳过&lt;html&gt;元素。现代浏览器中的事件会一直冒泡到 window。</p>
<h3 id="事件捕获">事件捕获</h3>
<p>事件捕获的意思是最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件。事件捕获实际上是为了在事件到达最终目标前拦截事件。如果前面的例子使用时间捕获，则点击&lt;div&gt;元素会以下列顺序触发 click 事件：</p>
<ol>
<li>document</li>
<li>&lt;html&gt;</li>
<li>&lt;body&gt;</li>
<li>&lt;div&gt;</li>
</ol>
<p>由于旧版本浏览器不支持，因此实际当中几乎不会使用事件捕获。通常建议使用事件冒泡，特殊情况下可以使用事件捕获。</p>
<h3 id="DOM-事件流">DOM 事件流</h3>
<p>DOM2 Event 规范规定事件流分为 3 个阶段：事件捕获、到达目标和事件冒泡。事件捕获是最先发生，为提前拦截事件提供了可能。然后实际的目标元素接收到事件。最后一个阶段是冒泡，最迟要在这个阶段响应事件。<br>
<img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/event.png" alt=""><br>
在 DOM 事件流中，实际的目标(&lt;div&gt;元素)在捕获阶段不会接收到事件。这是因为捕获阶段从 document 到&lt;html&gt;再到&lt;body&gt;就结束了。下一阶段，即会在&lt;div&gt;元素上触发事件的“到达目标”阶段，通常在事件处理时被认为是冒泡阶段的一部分。然后冒泡阶段开始，事件反向传播至文档。<br>
大多数支持 DOM 事件流的浏览器实现了一个小小的扩展。虽然 DOM2 Event 规范明确捕获阶段不命中事件目标，但现代浏览器都会在捕获阶段在事件目标上触发事件。最终结果是在事件目标上有两个机会来处理事件。</p>
<h2 id="事件处理程序">事件处理程序</h2>
<p>为响应事件而调用的函数被称为事件处理程序(或事件监听器)。</p>
<h3 id="HTML-事件处理程序">HTML 事件处理程序</h3>
<p>特定元素支持的每个事件都可以使用事件处理程序的名字以 HTML 属性的形式来指定。此时属性的值必须是能够执行的 Javascript 代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不能在未经转义的情况下使用HTML语法字符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;Clicked&#x27;)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 作为事件处理程序执行的代码可以访问全局作用域中的一切 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;showMessage()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以这种方式指定的事件处理程序有一些特殊的地方。首先，会创建一个函数来封装属性的值。这个函数有一个特殊的局部变量event，其中保存的就是event对象 。--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(event.type)&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- click --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this.value)&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Click Me --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这个函数的作用域链被扩展了。在这个函数中document和元素自身的成员都可以被当成局部变量来访问 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(value)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果这个元素是一个表单输入框，则作用域中还会包含表单元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Click Me&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(username.value)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 点击会显示出文本框中包含的文本。注意，这里直接引用了username --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM0-事件处理程序">DOM0 事件处理程序</h3>
<p>在 Javascript 中指定事件处理程序的传统方式是把一个函数赋值给(DOM 元素的)一个事件处理程序属性。每个元素(包括 window 和 document)都有通常小写的事件处理程序属性，比如 onclick</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>); <span class="comment">// &quot;myBtn&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 事件处理程序会在元素的作用域中运行，即this等于元素 */</span></span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>; <span class="comment">// 移除事件处理程序</span></span><br></pre></td></tr></table></figure>
<p>以这种方式添加事件处理程序是注册在事件流的冒泡阶段的。</p>
<h3 id="DOM2-事件处理程序">DOM2 事件处理程序</h3>
<p>DOM2 Events 为事件处理程序的赋值和移除定义了两个方法：addEventListener()和 removeEventListener()。这两个方法暴露在所有 DOM 节点上，它们接收 3 个参数：事件名、事件处理函数和一个布尔值，true 表示在捕获阶段调用事件处理程序，false(默认值)表示在冒泡阶段调用事件处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 通过addEventListener()添加的事件处理程序只能使用removeEventListener()并传入与添加时同样的参数来移除。</span></span><br><span class="line"><span class="comment"> * 这意味着使用addEventListener()添加的匿名函数无法移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&quot;click&quot;</span>, handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="IE-事件处理程序">IE 事件处理程序</h3>
<p>IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()。这两个方法接收两个同样的参数：事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 attachEvent()添加的事件处理程序会添加到冒泡阶段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">id</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, handler); <span class="comment">// 这里第一个参数是 onclick 而不是 click</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** attachEvent()添加的事件处理程序只能使用detachEvent()并传入与添加时同样的参数来移除。</span></span><br><span class="line"><span class="comment"> * 这意味着使用attachEvent()添加的匿名函数无法移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">detachEvent</span>(<span class="string">&quot;onclick&quot;</span>, handler); <span class="comment">// 这里第一个参数是 onclick 而不是 click</span></span><br></pre></td></tr></table></figure>
<p>使用 DOM0 方式时，事件处理程序中的 this 值等于目标元素。而使用 attachEvent()时，事件处理程序是在全局作用域中运行的，因此 this 等于 window。另外，若给同一个元素添加了两个不同的事件处理程序，它们会以添加它们的顺序反向触发。</p>
<h2 id="事件对象">事件对象</h2>
<p>在 DOM 中发生事件时，所有相关信息都会被收集并存储在一个名为 event 的对象中。这个对象包含了一些基本信息，比如导致事件的元素、发生的事件类型，以及可能与特定事件相关的任何其他数据</p>
<h3 id="DOM-事件对象">DOM 事件对象</h3>
<p>在 DOM 合规的浏览器中，event 对象是传给事件处理程序的唯一参数。不管以那种方式(DOM0 或 DOM2)指定事件处理程序，都会传入这个 event 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>);</span><br><span class="line">&#125;;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// click</span></span><br></pre></td></tr></table></figure>
<p>所有事件对象都会包含下表列出的这些公共属性和方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">读/写</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bubbles</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">表示事件是否冒泡</td>
</tr>
<tr>
<td style="text-align:left">cancelable</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">表示是否可以取消事件的默认行为</td>
</tr>
<tr>
<td style="text-align:left">currentTarget</td>
<td style="text-align:center">元素</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">当前事件处理程序所在的元素</td>
</tr>
<tr>
<td style="text-align:left">defaultPrevented</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">true 表示已经调用 preventDefault()方法</td>
</tr>
<tr>
<td style="text-align:left">detail</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">事件相关的其他信息</td>
</tr>
<tr>
<td style="text-align:left">eventPhase</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">表示调用事件处理程序的阶段：1-捕获，2-到达，3-冒泡</td>
</tr>
<tr>
<td style="text-align:left">preventDefault()</td>
<td style="text-align:center">函数</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">事件相关的用于取消事件的默认行为。只有其他 cancelable 为 true 才可以调用这个方法</td>
</tr>
<tr>
<td style="text-align:left">stopImmediatePropagation()</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">用于取消所有后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序</td>
</tr>
<tr>
<td style="text-align:left">stopPropagation()</td>
<td style="text-align:center">整数</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">用于取消所有后续事件捕获或事件冒泡，只有其他 bubbles 为 true 才可以调用这个方法</td>
</tr>
<tr>
<td style="text-align:left">target</td>
<td style="text-align:center">元素</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">事件目标</td>
</tr>
<tr>
<td style="text-align:left">trusted</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">true 表示事件是由浏览器生成的。false 表示事件是开发者通过 Javascript 创建的</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:center">字符串</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">被触发的事件类型</td>
</tr>
<tr>
<td style="text-align:left">view</td>
<td style="text-align:center">AbstractView</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">与事件相关的抽象视图。等于事件所发生的 window 对象</td>
</tr>
</tbody>
</table>
<p>在事件处理程序内部，this 对象始终等于 currentTarget 的值，而 target 只包含事件的实际目标。(想一下事件委托就明白了)</p>
<h3 id="IE-事件对象">IE 事件对象</h3>
<p>与 DOM 事件对象不同，IE 事件对象可以基于事件处理程序被指定的方式以不同方式来访问。如果事件处理程序是使用 DOM0 方式指定的，则 event 对象只是 window 对象的一个属性。如果事件处理程序是使用 attachEvent()指定的，则 event 对象会作为唯一的参数传给处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> event = <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// click</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">attachEvent</span>(<span class="string">&quot;onclick&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">type</span>); <span class="comment">// click</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>所有的 IE 事件对象都会包含下表所列的公共属性和方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性/方法</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">读/写</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cancelBubble</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">读/写</td>
<td style="text-align:left">默认 false，设置为 true 可以取消冒泡(与 DOM 的 stopPropagation()方法相同)</td>
</tr>
<tr>
<td style="text-align:left">returnValue</td>
<td style="text-align:center">布尔值</td>
<td style="text-align:center">读/写</td>
<td style="text-align:left">默认 true，设置为 false 可以取消事件的默认行为(与 DOM 的 preventDefault()方法相同)</td>
</tr>
<tr>
<td style="text-align:left">srcElement</td>
<td style="text-align:center">元素</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">事件目标(与 DOM 的 target 属性相同)</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:center">字符串</td>
<td style="text-align:center">只读</td>
<td style="text-align:left">触发的事件类型</td>
</tr>
</tbody>
</table>
<p>由于事件处理程序的作用域取决于指定它的方式，因此 this 值并不总是等于事件目标。为此，更好的方式是使用事件对象的 srcElement 属性代替 this。</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript - Fetch</title>
    <url>/Javascript-Fetch/</url>
    <content><![CDATA[<p>Fetch API 能够执行 XMLHttpRequest 对象的所有任务，但更容易使用，接口也更现代化，能够在Web 工作线程等现代 Web 工具中使用。XMLHttpRequest 可以选择异步，而 Fetch API 则必须是异步</p>
<div class="note primary"><p>文章内容大部分出自 <a href="https://zh.javascript.info/fetch">现代Javascript教程. Fetch.</a> 可直接跳转过去查看</p>
</div>
<h2 id="基本用法">基本用法</h2>
<p>fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法， 浏览器就会向给定 URL 发送请求</p>
<h3 id="分派请求">分派请求</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="title function_">fetch</span>(url, [options])</span><br></pre></td></tr></table></figure>
<ul>
<li>
<mark class="label primary">url</mark>——要访问的URL
</li>
<li>
<mark class="label primary">options</mark>——可选参数: method, header 等；
</li>
</ul>
<p>具体参数参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/fetch">MDN. Fetch.</a> 或 <a href="https://fetch.spec.whatwg.org/#request-class">Request class</a>;  没有<mark class="label primary">options</mark>，那就是一个简单的GET请求，下载<mark class="label primary">url</mark>的内容</p>
<span id="more"></span>
<h3 id="读取响应">读取响应</h3>
<p>为了获取response body， 我们需要使用一个其他的方法调用</p>
<ul>
<li>response.text() ——读取response，并以文本形式返回response</li>
<li>response.json() ——将response解析为JSON</li>
<li>response.formData() ——以<mark class="label primary">FromData</mark>对象的形式返回response</li>
<li>response.blob() ——以  <a href="https://zh.javascript.info/blob">Blob</a> (具有类型的二进制数据)形式返回response</li>
<li>response.arrayBuffer()  —— 以 <a href="https://zh.javascript.info/arraybuffer-binary-arrays">ArrayBuffer</a>（低级别的二进制数据）形式返回 response</li>
</ul>
<p>response.body 是一个ReadableStream对象，它允许你逐块读取body</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> commits = <span class="keyword">await</span> response.<span class="title function_">json</span>(); <span class="comment">// 读取 response body，并将其解析为 JSON</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(commits[<span class="number">0</span>].<span class="property">author</span>.<span class="property">login</span>);</span><br></pre></td></tr></table></figure>
<div class="note warning"><p>我们只能选择一种读取 body 的方法。</p>
<p>如果我们已经使用了 <mark class="label primary">response.text()</mark> 方法来获取 response，那么如果再用<mark class="label primary">response.json()</mark> 则不会生效，因为 body 内容已经被处理过了</p>
<p>要多次读取包含响应体的同一个 Response 对象，必须在第一次读取前调用 clone()</p>
</div>
<h3 id="处理状态码和请求失败">处理状态码和请求失败</h3>
<p>Fetch API 支持通过 Response 的 status (状态码) 和 statusText (状态文本) 属性检查响应状态。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/does-not-exist&#x27;</span>) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 404 </span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>); <span class="comment">// Not Found </span></span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure>
<div class="note warning"><p>虽然请求可能失败（如状态码为 500），但都只执行了期约的解决处理函数。事实上，只要服务器返回了响应，fetch()期约都会解决。这个行为是合理的：系统级网络协议已经成功完成消息的一次往返传输。至于真正的“成功”请求，则需要在处理响应时再定义。</p>
</div>
<p>通常状态码为 200 时就会被认为成功了，其他情况可以被认为未成功。为区分这两种情况，可以在状态码非 200~299 时检查 Response 对象的 ok 属性:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/bar&#x27;</span>) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 200 </span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>); <span class="comment">// true </span></span><br><span class="line"> &#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/does-not-exist&#x27;</span>) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123; </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>); <span class="comment">// 404 </span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">ok</span>); <span class="comment">// false </span></span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure>
<div class="note primary"><p>可以显式地设置 fetch()在遇到重定向时的行为，不过默认行为是跟随重定向 并返回状态码不是 300~399 的响应。跟随重定向时，响应对象的 redirected 属性会被设置为 true， 而状态码仍然是 200：</p>
</div>
<h2 id="Response-header">Response header</h2>
<p>Response header 位于 <mark class="label primary">response.headers</mark> 中的一个类似于 Map 的 header 对象。它不是真正的 Map，但是它具有类似的方法，我们可以按名称（name）获取各个 header，或迭代它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.github.com/repos/javascripttutorial/en.javascript.info/commits&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个 header</span></span><br><span class="line"><span class="title function_">alert</span>(response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Type&#x27;</span>)); <span class="comment">// application/json; charset=utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代所有 header</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.<span class="property">headers</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Request-header">Request header</h2>
<p>要在 <mark class="label primary">fetch</mark> 中设置 request header，我们可以使用 <mark class="label primary">headers</mark> 选项。它有一个带有输出 header 的对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="title function_">fetch</span>(protectedUrl, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="title class_">Authentication</span>: <span class="string">&#x27;secret&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但有一些我们无法设置的header <a href="https://fetch.spec.whatwg.org/#forbidden-header-name">Forbidden HTTP headers</a></p>
<h2 id="常见Fetch-请求模式">常见Fetch 请求模式</h2>
<h3 id="发送JSON">发送JSON</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; </span><br><span class="line"> <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">let</span> jsonHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-json&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line"> <span class="attr">body</span>: payload, </span><br><span class="line"> <span class="attr">headers</span>: jsonHeaders </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<h3 id="发送参数">发送参数</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> payload = <span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> paramHeaders = <span class="keyword">new</span> <span class="title class_">Headers</span>(&#123; </span><br><span class="line"> <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;</span> </span><br><span class="line">&#125;); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/send-me-params&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// 发送请求体时必须使用一种 HTTP 方法</span></span><br><span class="line"> <span class="attr">body</span>: payload, </span><br><span class="line"> <span class="attr">headers</span>: paramHeaders </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="发送文件">发送文件</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imageFormData = <span class="keyword">new</span> <span class="title class_">FormData</span>(); </span><br><span class="line"><span class="keyword">let</span> imageInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input[type=&#x27;file&#x27;][multiple]&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; imageInput.<span class="property">files</span>.<span class="property">length</span>; ++i) &#123; </span><br><span class="line"> imageFormData.<span class="title function_">append</span>(<span class="string">&#x27;image&#x27;</span>, imageInput.<span class="property">files</span>[i]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/img-upload&#x27;</span>, &#123; </span><br><span class="line"> <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line"> <span class="attr">body</span>: imageFormData </span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>
<h3 id="加载Blob">加载Blob</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imageElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;my-image.png&#x27;</span>) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> response.<span class="title function_">blob</span>()) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123; </span><br><span class="line"> imageElement.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob); </span><br><span class="line"> &#125;); </span><br></pre></td></tr></table></figure>
<h3 id="跨域请求">跨域请求</h3>
<p>从不同的源请求资源，响应要包含 CORS 头部才能保证浏览器收到响应。没有这些头部，跨源请求会失败并抛出错误.头部设置参考 <a href="https://kinsiy.github.io/Javascript-CORS/">Javascript-CORS</a></p>
<p>如果代码不需要访问响应，也可以发送 no-cors 请求。此时响应的 type 属性值为 opaque，因此无法读取响应内容。这种方式适合发送探测请求或者将响应缓存起来供以后使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;//cross-origin.com&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;no-cors&#x27;</span> &#125;) </span><br><span class="line"> .<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">type</span>)); </span><br><span class="line"><span class="comment">// opaque</span></span><br></pre></td></tr></table></figure>
<h3 id="中断请求">中断请求</h3>
<p>Fetch API 支持通过 AbortController/AbortSignal 对中断请求。调用 AbortController. abort()会中断所有网络传输，特别适合希望停止传输大型负载的情况。中断进行中的 fetch()请求会导致包含错误的拒绝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> abortController = <span class="keyword">new</span> <span class="title class_">AbortController</span>(); </span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;wikipedia.zip&#x27;</span>, &#123; <span class="attr">signal</span>: abortController.<span class="property">signal</span> &#125;) </span><br><span class="line"> .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aborted!&#x27;</span>); </span><br><span class="line"><span class="comment">// 10 毫秒后中断请求</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> abortController.<span class="title function_">abort</span>(), <span class="number">10</span>); </span><br><span class="line"><span class="comment">// 已经中断</span></span><br></pre></td></tr></table></figure>
<h2 id="更多用法">更多用法</h2>
<p>更多更详细的用法，像下载进度、断定续传等可以参考 <a href="https://zh.javascript.info/network">现代Javascript教程. 网络请求专题</a></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://zh.javascript.info/fetch">Javascript.info. Fetch</a></p>
<p>[2]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Event-2</title>
    <url>/Javascript-Event-2/</url>
    <content><![CDATA[<h2 id="事件类型">事件类型</h2>
<p>DOM3 Events 定义了如下事件类型</p>
<ul>
<li>用户界面事件(UIEvent): 涉及与 BOM 交互德尔通用浏览器事件</li>
<li>焦点事件(FocusEvent): 在元素获得和失去焦点时触发</li>
<li>鼠标事件(MouseEvent): 使用鼠标在页面上执行某些操作是触发</li>
<li>滚轮事件(WheelEvent)：使用鼠标滚轮(或类似设备)时触发</li>
<li>输入事件(InputEvent): 在文档中输入文本时触发</li>
<li>键盘事件(KeyboardEvent): 使用键盘在页面上执行某些操作时触发</li>
<li>合成事件(CompositionEvent): 在使用某种 IME(Input Method Editor, 输入法编辑器)输入字符时触发</li>
</ul>
<span id="more"></span>
<h3 id="用户界面事件">用户界面事件</h3>
<ul>
<li>load：在 window 上当页面加载完成后触发，在窗套(&lt;frameset&gt;)上所有窗格(&lt;frame&gt;)都加载完成后触发</li>
<li>unload：在 window 上当页面完全卸载后触发，在窗套(&lt;frameset&gt;)上当所有窗格(&lt;frame&gt;)都卸载完成后触发，在&lt;object&gt;元素上当相应对象卸载完成后触发</li>
<li>abort：在&lt;object&gt;元素上当相应对象加载完成前被用户提前终止下载时触发</li>
<li>error：在 window 上当 Javascript 报错时触发，在&lt;img&gt;元素上当无法加载指定图片时触发，在&lt;object&gt;元素上当无法加载相应对象时触发，在窗套(&lt;frameset&gt;)上当一个或多个窗格(&lt;frame&gt;)无法加载时触发</li>
<li>select：在文本框(&lt;input&gt;或 textarea)上当用户选择了一个或多个字符时触发</li>
<li>resize：在 window 或窗格上当窗口或窗格被缩放是触发</li>
<li>scroll：当用户滚动包含滚动条的元素时在元素上触发。&lt;body&gt;元素包含已加载页面的滚动条</li>
<li>DOMActivate：元素被用户通过鼠标或键盘操作激活时触发(DOM3 Event 已废弃)</li>
</ul>
<h3 id="焦点事件">焦点事件</h3>
<p>焦点事件在页面元素获得或失去焦点时触发。这些事件可以与 document.hasFocus()和 document.activeElement 一起为开发者提供用户在页面中的导航信息。</p>
<ul>
<li>blur：当元素失去焦点时触发。这个事件不冒泡，所有浏览器都支持</li>
<li>focus：当元素获得焦点时触发。这个事件不冒泡，所有浏览器都支持</li>
<li>focusout：当元素失去焦点时触发。这个事件是 blur 的通用版</li>
<li>focusin：当元素获得焦点时触发。这个事件是 focus 的冒泡版</li>
<li>DOMFocusOut：当元素失去焦点时触发。这个事件是 blur 的的通用版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusIn，推荐 focusout。</li>
<li>DOMFocusIn：当元素获得焦点时触发。这个事件是 focus 的冒泡版。Opera 是唯一支持这个事件的主流浏览器。DOM3 Events 废弃了 DOMFocusIn，推荐 focusin。</li>
</ul>
<p>当焦点从页面中的一个元素移到另一个元素上时，会依次发生如下事件。</p>
<ol>
<li>focusout 在失去焦点的元素上触发</li>
<li>focusin 在获得焦点的元素上触发</li>
<li>blur 在失去焦点的元素上触发</li>
<li>DOMFocusOut 在失去焦点的元素上触发</li>
<li>focus 在获得焦点的元素上触发</li>
<li>DOMFocusIn 在获得焦点的元素上触发</li>
</ol>
<p>blur、DOMFocusOut 和 focusout 的事件目标是失去焦点的元素，而 focus、DOMFocusIn 和 focusin 的事件目标是获得焦点的元素</p>
<h3 id="鼠标和滚轮事件">鼠标和滚轮事件</h3>
<ul>
<li>click：在用户单击鼠标主键(通常是左键)或按键盘回车键时触发。这主要是基于无障碍的考虑，让键盘和鼠标都可以触发 onclick 事件处理程序</li>
<li>dbclick：在用户双击鼠标主键(通常是左键)时触发</li>
<li>mousedown：在用户按下任意鼠标键时触发。这个事件不能通过键盘触发</li>
<li>mouseenter：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发</li>
<li>mouseleave：在用户把鼠标光标从元素内部移到元素外部时触发。这个事件不冒泡，也不会在光标经过后代元素时触发。</li>
<li>mousemove：在鼠标光标在元素上移到时反复触发。这个事件不能通过键盘触发。</li>
<li>mouseout：在用户把光标从一个元素移动到另一个元素上时触发。移到到的元素可以是原始元素的外部元素，也可以是原始元素的子元素。这个事件不能通过键盘触发</li>
<li>mouseover：在用户把鼠标光标从元素外部移到元素内部时触发。这个事件不能通过键盘触发</li>
<li>mouseup：在用户释放鼠标键时触发。这个事件不能通过键盘触发。</li>
</ul>
<p>mousedown、mouseup、click、dbclick 四个事件永远会按照如下顺序触发</p>
<ol>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>mousedown</li>
<li>mouseup</li>
<li>click</li>
<li>dbclick</li>
</ol>
<p>使用 event.shiftKey/ctrlKey/altKey/metaKey 可以检测出用户是否按下了某个修饰键。<br>
对于 mouseover 和 mouseout 事件而言，还存在与事件相关的其他元素。对 mouseover 事件来说，事件的主要目标是获得光标的元素，相关元素是失去光标的元素。mouseout 则相反，DOM 通过 event 对象的 relatedTarget 属性提供了相关元素的信息。这个属性只有在 mouseover 和 mouseout 事件发生时才有包含值，其他所有事件的这个属性的值都是 null。</p>
<h3 id="键盘和输入事件">键盘和输入事件</h3>
<p>键盘事件是用户操作键盘时触发的</p>
<ul>
<li>keydown：用户按下键盘某个键时触发，而且持续按住会重复触发</li>
<li>keypress，用户按下键盘上某个键并产生字符时触发，而且持续按住会重发触发。Esc 键也会触发这个事件。DOM3 Events 废弃了 keypress 事件，而推荐 textInput 事件。</li>
<li>keyup，用户释放键盘上某个键时触发</li>
</ul>
<p>输入事件只有一个，即 textInput。这个事件是对 keypress 事件的扩展，用于在文本显示给用户之前更方便地截取文本输入。textInput 会在文本被插入到文本框之前触发。</p>
<h3 id="合成事件">合成事件</h3>
<p>合成事件是 DOM3 Events 中新增的，用于处理通常使用 IME 输入时的复杂输入序列。IME 可以让用户输入物理键盘上没有的字符。例如，使用拉丁字母键盘的用户还可以使用 IME 输入日文。IME 通常需要同时按下多个键才能输入一个字符。合成事件用于监测和控制这种输入。</p>
<ul>
<li>compositionstart: 在 IME 的文本合成系统打开时触发，表示输入即将开始</li>
<li>compositionupdate： 在新字符插入输入字段时触发</li>
<li>compositionend：在 IME 的文本合成系统关时触发，表示恢复正常键盘输入。</li>
</ul>
<p>合成事件在很多方面与输入事件很类似。在合成事件触发时，事件目标是接收文本的输入字段。唯一增加的事件属性是 data，其中包含的值视情况而异：</p>
<ul>
<li>compositionstart 事件中，包含正在编辑的文本(例如，已经选择了文本但还没替换)</li>
<li>compositionupdate 事件中，包含要插入的新字符</li>
<li>compositionend 事件中，包含本次合成过程中输入的全部内容</li>
</ul>
<h3 id="HTML5-事件">HTML5 事件</h3>
<h4 id="contextmenu-事件">contextmenu 事件</h4>
<p>contextmenu 事件专门用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单。contextmenu 事件冒泡，因此只要给 document 指定一个事件处理程序就可以处理页面上的所用同类事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件冒泡示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>此处右键获取特有上下文菜单，别处右键获取默认上下文菜单<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myMenu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute;visibility: hidden;background-color: silver;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>菜单1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>菜单2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>菜单3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        div.<span class="title function_">addEventListener</span>(<span class="string">&quot;contextmenu&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">let</span> menu = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          menu.<span class="property">style</span>.<span class="property">left</span> = event.<span class="property">clientX</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          menu.<span class="property">style</span>.<span class="property">top</span> = event.<span class="property">clientY</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">          menu.<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;visible&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myMenu&quot;</span>).<span class="property">style</span>.<span class="property">visibility</span> = <span class="string">&quot;hidden&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="beforeunload-事件">beforeunload 事件</h4>
<p>beforeunload 事件会在 window 上触发，用意是给开发者提供阻止页面被卸载的机会。这个事件会在页面即将从浏览器中卸载时触发，如果页面要继续使用，则可以不被卸载。这个事件不能取消，否则就意味着可以把用户永久阻拦在一个页面上。相反，这个事件会向用户显示一个确认框，其中的消息表明浏览器即将卸载页面，并请用户确认是希望关闭页面，还是继续留在页面上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&quot;我会想你的！🔈🔉🔊&quot;</span>;</span><br><span class="line">  event.<span class="property">returnValue</span> = message;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在chrome这样子写上并不能显示message的信息(应该是限制了)，但确实阻止了页面卸载(会弹出确认框)</span></span><br></pre></td></tr></table></figure>
<h4 id="DOMContentLoaded-事件">DOMContentLoaded 事件</h4>
<p>window 的 load 事件会在页面完全加载后触发，因为要等待很多外部资源加载完成，所以会花费较长时间。而 DOMContentLoaded 事件会在 DOM 树构建完成后立即触发，而不用等待图片、Javascript 文件、CSS 文件或者其他资源加载完成。相对于 load 事件，DOMContentLoaded 可以让开发者在外部资源下载的同时就能指定事件处理程序，从而让用户能够更快地与界面交互。</p>
<h4 id="readystatechange-事件">readystatechange 事件</h4>
<p>支持 readystatechange 事件的每个对象都有一个 readyState 属性，该属性具有一个以下列出的可能的字符串值</p>
<ul>
<li>uninitialized：对象存在并尚未初始化</li>
<li>loading：对象正在加载数据</li>
<li>loaded：对象已经加载完数据</li>
<li>interactive：对象可以交互，但尚未加载完成</li>
<li>complete：对象加载完成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;readystatechange&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&quot;interactive&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Content loaded&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="hashchange-事件">hashchange 事件</h4>
<p>HTML5 增加了 hashchange 事件，用于在 URL 散列值(URL 最后#后面的部分)发生变化时通知开发者。onhashchange 事件处理程序必须添加给 window，每次 URL 散列值发生变化时会调用它。</p>
<h3 id="设备事件">设备事件</h3>
<p>暂略</p>
<h2 id="模拟事件">模拟事件</h2>
<h3 id="DOM-事件模拟">DOM 事件模拟</h3>
<p>任何时候，都可以使用 document.creatEvent()方法创建一个 event 事件。这个方法接收一个参数，此参数是一个表示要创建事件类型的字符串。<br>
可用的字符串值是以下值之一</p>
<ul>
<li>“UIEvents”(DOM3 中是&quot;UIEvent&quot;): 通用用户界面事件(鼠标事件和键盘事件都继承自这个事件)</li>
<li>“MouseEvents”(DOM3 中是&quot;MouseEvent&quot;): 通用鼠标事件</li>
<li>“HTMLEvents”(DOM3 中没有): 通用 HTML 事件(HTML 事件已经分散到了其他事件大类中)</li>
</ul>
<p>创建 event 事件之后，需要使用事件相关的信息来初始化。每种类型的 event 对象都有特定的方法，可以使用相应数据来完成初始化。方法的名字并不相同，这取决于调用 createEvent()时传入的参数。<br>
事件模拟的最后一步是触发事件。为此要使用 dispatchEvent()方法，这个方法存在于所有支持事件的 DOM 节点之上。dispatchEvent()方法接收一个参数，即表示要触发事件的 event 对象。调用 dispatchEvent()方法之后，事件就&quot;转正&quot;了,接着便冒泡并触发事件处理程序执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟鼠标事件</span></span><br><span class="line"><span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myBtn&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;MouseEvents&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化event对象(参数含义暂略，需要时再查)</span></span><br><span class="line">event.<span class="title function_">initMouseEvent</span>(<span class="string">&quot;click&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaulyView</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">btn.<span class="title function_">dispatchEvent</span>(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟键盘事件</span></span><br><span class="line"><span class="keyword">let</span> textbox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myTextbox&quot;</span>),</span><br><span class="line">  event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照DOM3 的方式创建event对象</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">implementation</span>.<span class="title function_">hasFeature</span>(<span class="string">&quot;KeyboardEvents&quot;</span>, <span class="string">&quot;3.0&quot;</span>)) &#123;</span><br><span class="line">  event = <span class="variable language_">document</span>.<span class="title function_">createEvent</span>(<span class="string">&quot;KeyboardEvent&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化event对象(参数含义暂略，需要时再查)</span></span><br><span class="line">  event.<span class="title function_">initKeyboardEvent</span>(<span class="string">&quot;keydown&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="variable language_">document</span>.<span class="property">defaulyView</span>, <span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Shift&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line">textbox.<span class="title function_">dispatchEvent</span>(event);</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Event</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript - Function</title>
    <url>/Javascript-Function/</url>
    <content><![CDATA[<p>函数实际上是对象。每个函数都是 Function 类型的实例，而 Function 也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum_1</span>(<span class="params">val_1, val_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val_1 + val_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> sum_2 = <span class="keyword">function</span> (<span class="params">val_1, val_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val_1 + val_2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum_3</span> = (<span class="params">val_1, val_2</span>) =&gt; val_1 + val_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Function构造函数</span></span><br><span class="line"><span class="keyword">let</span> sum_4 = <span class="keyword">new</span> <span class="title class_">Function</span>(val_1, val_2, <span class="string">&quot;return val_1 + val_2&quot;</span>);</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="箭头函数">箭头函数</h2>
<p>很大程度上，箭头函数实例化的函数对象与正式的函数表达式创建的函数对象行为是相同的。任何可以使用函数表达式的地方，都可以使用箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = x =&gt; &#123;retuan <span class="number">2</span> * x&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个参数与无参数需要括号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a,b</span>) =&gt; &#123;<span class="keyword">return</span> a+b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数体不用大括号则，箭头后面只能有一行代码。省略大括号会隐式的返回这行代码的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a,b,c</span>) =&gt; a+b+c</span><br></pre></td></tr></table></figure>
<p>箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外箭头函数也没有 prototype 属性。</p>
<h2 id="函数名">函数名</h2>
<p>函数名就是指向函数的指针，它们跟其他包含对象指针的变量具有相同的行为。这意味着一个函数可以有多个变体</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num_1 + num_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anthorSum = sum;</span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anthorSum</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECMAScript 6 的所有函数都会暴露一个只读的name 属性，其中包含关于函数的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">king</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anthorSum.<span class="property">name</span>); <span class="comment">// sum</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(king.<span class="property">name</span>); <span class="comment">// king</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">// 空字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Function</span>().<span class="property">name</span>); <span class="comment">// anonymous</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数是一个获取函数、设置函数，或者使用bind()实例化，那么标识符前面会加上一个前缀</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queen</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queen.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound queen</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">year_</span>: <span class="number">2021</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">year</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">year</span>(<span class="params">newYear</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`oldYear: <span class="subst">$&#123;<span class="variable language_">this</span>.year_&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">year_</span> = newYear;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get year</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">set</span>.<span class="property">name</span>); <span class="comment">// set year</span></span><br></pre></td></tr></table></figure>
<h2 id="理解参数">理解参数</h2>
<p>ECMAScript 函数的参数跟大多数其他语言不同。ECMAScript 函数既不关系传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器也不会报错。<br>
ECMAScript 函数的参数在内部表现为一个数组。在使用 function 关键字定义(非箭头)函数时，可以在函数内部访问 arguments 对象，从中取得传递进来的每个参数值。arguments 对象是一个类数组对象(不是 Array 实例)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">val_1, val_2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">66</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val_1 + <span class="number">10</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val_2);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">88</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val_2);</span><br><span class="line">    val_2 = <span class="number">100</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments 对象的长度由传入的命名参数数量决定。</span></span><br><span class="line"><span class="comment">// auguments[n](n &gt; 传入参数数量)对象与命名参数不同步，argument[n](n &lt; 传入参数数量)与命名参数始终保持同步</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">4</span>); <span class="comment">//14  undefined</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 88 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 《Javascript高级程序设计》中单向同步的说法应该是错的，在chrome[ 89.0.4389.82（正式版本） （64 位）]中测试是双向同步的 */</span></span><br></pre></td></tr></table></figure>
<p>如果函数是使用箭头函数定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p>
<h2 id="没有重载">没有重载</h2>
<p>ECMAScript 函数不能像传统编程那样重载。在其他语言比如 Java 中，一个函数可以有两个定义，只要签名(接收函数的类型和数量)不同就行。ECMAScript 中函数没有签名，因为参数是由包含零个或多个值得数组表示。没有函数签名，自然也就没有重载。如果在 ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。</p>
<h2 id="默认函数值">默认函数值</h2>
<p>在 ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于 undefined。如果是则意味着没有传这个参数，那就给它赋一个值。ES6 之后就不用这么麻烦了，因为它支持显式定义默认参数了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES 5</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeKing</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  name = <span class="keyword">typeof</span> name !== <span class="string">&quot;undefined&quot;</span> ? name : <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`King <span class="subst">$&#123;name&#125;</span> VII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeQueen</span>(<span class="params">name = <span class="string">&quot;QingLai&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Queen <span class="subst">$&#123;name&#125;</span> VII`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用默认参数时，arguments 对象的值不反应参数的默认值，只反映传给函数的参数</span></span><br><span class="line"><span class="comment">// 跟ES5 严格模式一样，修改命名参数也不会影响arguments对象，它始终以调用函数时传入的值为准</span></span><br></pre></td></tr></table></figure>
<h3 id="默认函数作用域与暂时性死区">默认函数作用域与暂时性死区</h3>
<p>给多个参数定义默认值实际上跟使用 let 关键字顺序声明变量一样。参数初始化顺序遵循&quot;暂时性死区&quot;规则，即前面定义的参数不能引用后面定义的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">marry</span>(<span class="params">king = queen, queen = <span class="string">&quot;QingLai&quot;</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`king <span class="subst">$&#123;king&#125;</span> queen <span class="subst">$&#123;queen&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数也存在于自己的作用域中，它们不能引用函数体的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 ReferenceError</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeMarry</span>(<span class="params">name = <span class="string">&quot;Kinsiy&quot;</span>, age = num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">18</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`age <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数扩展与收集">参数扩展与收集</h2>
<p>ECMAScript 6 新增了扩展操作符，使用它可以非常简洁地操作和组合集合数据。扩展操作符最有用的场景就是函数定义中的参数列表。</p>
<h3 id="扩展参数">扩展参数</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countArguments</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">countArguments</span>(-<span class="number">1</span>, ...values); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="收集参数">收集参数</h3>
<p>在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点像 arguments 对象的构造机制，只不过收集参数的结果会得到一个 Array 实例。因为收集参数的结果可变，所以只能把它作为最后一个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...values</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作函数声明提升。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">5</span>)); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num_1 + num_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum_1</span>(<span class="number">20</span>, <span class="number">5</span>)); <span class="comment">// ReferenceError: Cannot access &#x27;sum_1&#x27; before initialization</span></span><br><span class="line"><span class="keyword">let</span> sum_1 = <span class="keyword">function</span> (<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用var 也是一样的</span></span><br><span class="line">  <span class="keyword">return</span> num_1 + num_2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。</p>
<h2 id="函数作为值">函数作为值</h2>
<p>如果是访问函数而不是调用函数，那就必须不带括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj_1, obj_2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value_1 = obj_1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value_2 = obj_2[propertyName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value_1 &lt; value_2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_1 &gt; value_2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;QingLai&quot;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">data.<span class="title function_">sort</span>(<span class="title function_">createComparisonFunction</span>(<span class="string">&quot;age&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data[<span class="number">0</span>].<span class="property">name</span>); <span class="comment">// QingLai</span></span><br></pre></td></tr></table></figure>
<h2 id="函数内部">函数内部</h2>
<p>ES 5 中，函数内部存在两个特殊的对象：arguments 和 this。ES 6 新增了 new.target 属性</p>
<h3 id="arguments">arguments</h3>
<p>arguments 前面已经说过很多次了，这里主要讲一下 arguments 对象的 callee 属性，是一个指向 arguments 对象所在函数的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num - <span class="number">1</span>); <span class="comment">// 递归函数逻辑与函数名解耦</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">factorial</span>(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h3 id="this">this</h3>
<p>this 在标准函数和箭头函数中有不同的行为。</p>
<ul>
<li>在标准函数中 this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值</li>
<li>在剪头函数中，this 引用的是定义箭头函数的上下文</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;orange&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">sayColor_1</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayColor</span>(); <span class="comment">// purple</span></span><br><span class="line"><span class="title function_">sayColor_1</span>(); <span class="comment">// purple</span></span><br><span class="line"></span><br><span class="line">o.<span class="property">sayColor</span> = sayColor;</span><br><span class="line">o.<span class="title function_">sayColor</span>(); <span class="comment">// orange</span></span><br><span class="line"></span><br><span class="line">o.<span class="property">sayColor_1</span> = sayColor_1;</span><br><span class="line">o.<span class="title function_">sayColor_1</span>(); <span class="comment">// purple</span></span><br></pre></td></tr></table></figure>
<h3 id="caller">caller</h3>
<p>这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="property">caller</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>(); <span class="comment">// ƒ outer()</span></span><br></pre></td></tr></table></figure>
<h3 id="new-target">new.target</h3>
<p>检测函数是否使用 new 关键字调用。如果函数是正常调用的，new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">King</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;King 必须new&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;% label primary@<span class="keyword">new</span> <span class="title class_">King</span> %&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">King</span>(); <span class="comment">// new King</span></span><br><span class="line"><span class="title class_">King</span>(); <span class="comment">// Error: King 必须new</span></span><br></pre></td></tr></table></figure>
<h2 id="函数属性与方法">函数属性与方法</h2>
<p>每个函数都有两个属性：length 和 prototype。其中 length 属性保存函数定义的命名参数的个数。prototype 是保存引用类型所有实例方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实例共享。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num_1 + num_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayName.<span class="property">length</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sayHi.<span class="property">length</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>函数还有两个方法: apply()和 call()。这两个方法都会以指定 this 值来调用函数，即会设置调用函数时函数体内 this 对象的值.apply()方法接受两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象。call()方法与 apply()的作用一样，只是传参的形式不同，第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须将参数一个个地列出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> num_1 + num_2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">applysum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> sum.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callsum</span>(<span class="params">num_1, num_2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> sum.<span class="title function_">call</span>(<span class="variable language_">this</span>, num_1, num_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line">applysum.<span class="title function_">call</span>(object, <span class="number">3</span>, <span class="number">4</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 5 出于同样的目的定义了一个新方法：bind()。bind()方法会创建一个新的函数实例，其this值会被绑定到传给this的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">color</span> = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;purple&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ObjectSayColor</span> = sayColor.<span class="title function_">bind</span>(o);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ObjectSayColor</span>(); <span class="comment">// purple</span></span><br></pre></td></tr></table></figure>
<h2 id="函数表达式">函数表达式</h2>
<p>记住。函数声明会被提升，而函数表达式不会被提升。任何时候，只要函数被当作值来使用，它就是一个函数表达式。</p>
<h2 id="递归">递归</h2>
<p>在编写递归函数时，arguments.callee 是引用当前函数的首选。在严格模式下可以使用命名函数表达式达到目的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="title function_">f</span>(num - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">factorial</span>(<span class="number">5</span>)); <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<h2 id="尾调用优化">尾调用优化</h2>
<p>ES 6 规范新增了一项内存管理优化机制，让 javascript 引擎在满足条件时重用栈帧。具体来说，这项优化非常适合&quot;尾调用&quot;，即外部函数的返回值是一个内部函数的返回值。<br>
示例及适用条件略(:</p>
<h2 id="闭包">闭包</h2>
<p>闭包指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj_1, obj_2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value_1 = obj_1[propertyName];</span><br><span class="line">    <span class="keyword">let</span> value_2 = obj_2[propertyName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value_1 &lt; value_2) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_1 &gt; value_2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compare = <span class="title function_">createComparisonFunction</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">compare</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;Restituo&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>compare 函数就是一个闭包，他的作用域链包含本身函数的的作用域与 createComparisonFunction()的作用域以及全局作用域。createComparisonFunction()活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。</p>
<h3 id="this-对象">this 对象</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">identity</span> = <span class="string">&quot;the window&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">  <span class="attr">identity</span>: <span class="string">&quot;my object&quot;</span>,</span><br><span class="line">  <span class="title function_">getIdentity</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">identity</span>); <span class="comment">// 内部函数永远不可能直接访问外部函数的this与arguments</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="title function_">getIdentity</span>()()); <span class="comment">// the window</span></span><br></pre></td></tr></table></figure>
<h3 id="内存泄露">内存泄露</h3>
<p>因为 IE 在 IE9 之前对 JScript 和 COM 对象使用了不同的垃圾回收机制，所以 IE 在旧版本 IE 中可能回导致内存泄露。</p>
<h2 id="立即调用表达式">立即调用表达式</h2>
<p>立即调用的匿名函数又被称作立即调用的函数表达式。它类似与函数声明，但由于被包含在括号中，所以会被解释为函数表达式。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;)()(</span><br><span class="line">  <span class="comment">// ES5 中常用来隔离块级作用域</span></span><br><span class="line">  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)(); <span class="comment">// 0,1,2</span></span><br></pre></td></tr></table></figure>
<h2 id="私有变量">私有变量</h2>
<p>略</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript - 继承方式</title>
    <url>/Javascript-Inherit/</url>
    <content><![CDATA[<h2 id="原型链">原型链</h2>
<p>ECMA-262 把原型链定义为 ECMAScript 的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后续代码以次段为基础</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">property</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">property</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subproperty</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); <span class="comment">// SubType 的原型是另一个类型的实例</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSubValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="默认原型">默认原型</h3>
<p>实际上，原型链中还有一环。默认情况下，所有引用类型都继承自 Object，这也是通过原型链实现的。任何函数的默认原型都是一个 Object 的实例，这意味着这个实例有一个内部指针指向 Object.prototype。这也是为什么自定义类型能够继承包括 toString(),valueOf()在内的所有默认的方法的原因。</p>
<h3 id="原型与继承关系">原型与继承关系</h3>
<p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用 instanceof 操作符，如果一个实例的原型链中出现过相应的构造函数，则 instanceof 返回 true。<br>
第二种方法是使用 isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例的原型链中出现过相应的构造函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance <span class="keyword">instanceof</span> <span class="title class_">SubType</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要原型链中包含这个原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(instance)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用返回false SubType.isPrototypeOf(instance) false</span></span><br></pre></td></tr></table></figure>
<h3 id="关于方法">关于方法</h3>
<p>子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后再添加到原型上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 覆盖已有的方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getSuperValue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>以对象字面量方式创建原型方法会破坏之前的原型链，这相当于重写了原型链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="title function_">getSubValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">subproperty</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">someOtherMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="title function_">getSuperValue</span>()); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="原型的问题">原型的问题</h3>
<ul>
<li>原型中包含的引用值会在所有实例间共享</li>
<li>子类型在实例化时不能给父类型的构造函数传参</li>
</ul>
<h2 id="盗用构造函数">盗用构造函数</h2>
<p>“盗用构造函数&quot;有时也称作&quot;对象伪装&quot;或&quot;经典继承”。基本思路很简单：在子类构造函数中调用父类构造函数。因为毕竟函数就是在特地上下文中执行代码的简单对象，所以可以使用 apply()和 call()方法以新创建的对象为上下文执行的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">language</span> = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Javascript&quot;</span>, <span class="string">&quot;C&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance_1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="keyword">let</span> instance_2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"></span><br><span class="line">instance_1.<span class="property">language</span>.<span class="title function_">push</span>(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inatance_1); <span class="comment">// [&quot;Python&quot;, &quot;Javascript&quot;, &quot;C&quot;, &quot;Java&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(inatance_2); <span class="comment">// [&quot;Python&quot;, &quot;Javascript&quot;, &quot;C&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="传递参数">传递参数</h3>
<p>相比于使用原型链，盗用构造函数的一个优点就是可以在子类构造函数中向父类构造函数传参。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, v);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = <span class="string">&quot;girl&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance_1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> instance_2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Restituo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value: <span class="subst">$&#123;instance_1.value&#125;</span>     sex: <span class="subst">$&#123;instance_1.sex&#125;</span>`</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value: <span class="subst">$&#123;instance_2.value&#125;</span>     sex: <span class="subst">$&#123;instance_2.sex&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//value: Kinsiy     sex: girl</span></span><br><span class="line"><span class="comment">//value: Restituo     sex: girl</span></span><br></pre></td></tr></table></figure>
<h3 id="盗用构造函数的问题">盗用构造函数的问题</h3>
<ul>
<li>
<p>必须在构造函数中定义方法, 函数不能重用</p>
</li>
<li>
<p>子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。</p>
</li>
</ul>
<h2 id="组合继承">组合继承</h2>
<p>组合继承(有时候也叫伪经典继承)综合了原型链和盗用构造函数，将两者的优点集中了起来。其基本思想是使用原型链继承原型上的属性和方法，而通过盗用构造函数来继承实例属性。</p>
<p>组合继承拟补了原型链和盗用构造函数的不足，是 Javascript 中使用最多的继承模式。而且组合继承也保留了 instanceof 操作符和 isPrototypeOf()方法识别合成对象的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = v;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">language</span> = [<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Go&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">v, n</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, v);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance_1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="keyword">let</span> instance_2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Restituo&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">instance_1.<span class="property">language</span>.<span class="title function_">push</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance_1.<span class="property">language</span>); <span class="comment">// [&quot;Java&quot;, &quot;Python&quot;, &quot;Go&quot;, &quot;Rust&quot;]</span></span><br><span class="line">instance_1.<span class="title function_">sayName</span>(); <span class="comment">// Kinsiy</span></span><br><span class="line">instance_1.<span class="title function_">sayAge</span>(); <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance_2.<span class="property">language</span>); <span class="comment">// [&quot;Java&quot;, &quot;Python&quot;, &quot;Go&quot;]</span></span><br><span class="line">instance_2.<span class="title function_">sayName</span>(); <span class="comment">// Restituo</span></span><br><span class="line">instance_2.<span class="title function_">sayAge</span>(); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>
<h2 id="原型式继承">原型式继承</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。</p>
<p>原型式继承是适用于这种情况：你有一个对象，想在它的基础上再创建一个新对象。你需要把这个对象先传给 object()，然后再对返回的对象进行适当修改。</p>
<p>EMCAScript5 通过增加 Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：作为新对象原型的对象，以及给新对象定义额外属性的对象(第二个可选)。在只有一个参数时，Object.create()与这里的 object()方法效果相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Restituo&quot;</span>, <span class="string">&quot;Type57&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;QingLai&quot;</span>;</span><br><span class="line">anOtherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;King&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yetAnthorPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;BaiLiXu&quot;</span>;</span><br><span class="line">anOtherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;witcher&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yetAnthorPerson.<span class="property">friends</span>); <span class="comment">//  [&quot;Restituo&quot;, &quot;Type57&quot;, &quot;King&quot;, &quot;witcher&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(person, &#123;</span><br><span class="line">  <span class="attr">name</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Queen&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_3.<span class="property">name</span>); <span class="comment">// Queen</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生式继承">寄生式继承</h2>
<p>与原型式继承比较接近的是一种继承方式是寄生式继承。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。基本的寄生继承模式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">language</span>: [<span class="string">&quot;Javascript&quot;</span>, <span class="string">&quot;Python&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someone = <span class="title function_">createAnother</span>(person);</span><br><span class="line">someone.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>
<h2 id="寄生式组合继承">寄生式组合继承</h2>
<p>组合继承其实也有存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：一次是在创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  prototype.<span class="property">constructor</span> = <span class="title class_">SubType</span>;</span><br><span class="line">  <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">v, n</span>) &#123;</span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, v);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">SubType</span>, <span class="title class_">SuperType</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">23</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me <span class="keyword">instanceof</span> <span class="title class_">SuperType</span>); <span class="comment">// true</span></span><br><span class="line">me.<span class="title function_">sayName</span>(); <span class="comment">// Kinsiy</span></span><br></pre></td></tr></table></figure>
<p>这里只调用了一次 SuperType 构造函数，避免了 SubType.prototype 上不必要也用不到的属性，因此可以说是这个例子的效率更高。而且，原型链仍然保持不变，因此 instanceof 操作符合 isPrototypeOf()方法正常有效。寄生式组合继承可以算是引用类型继承的最佳模式。</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Classes</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Map&amp;Set</title>
    <url>/Javascript-Map&amp;Set/</url>
    <content><![CDATA[<h1>Map</h1>
<p>Map 是一种新的集合类型，为 Javascript 带来了真正的键/值存储机制。Map 的大多数特性都可以通过 Object 类型实现，但二者之间还是存在一些细微的差异。具体实践中使用哪一个值得细细甄别。</p>
<h2 id="基本-API">基本 API</h2>
<p>创建 Map 实例并初始化实例，可以给 Map() 构造函数传入一个可迭代对象，需要包含键/值对数组。可迭代对象的每个键/值对都会按照迭代顺序插入到新映射实例中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m_1 = <span class="keyword">new</span> <span class="title class_">Map</span>(); <span class="comment">// 创建空映射</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m_2 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key_1&quot;</span>, <span class="string">&quot;val_1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key_2&quot;</span>, <span class="string">&quot;val_2&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key_3&quot;</span>, <span class="string">&quot;val_3&quot;</span>],</span><br><span class="line">]); <span class="comment">// 创建的同时初始化实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_2.<span class="property">size</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m_3 = <span class="keyword">new</span> <span class="title class_">Map</span>([[]]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_3.<span class="title function_">has</span>(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_3.<span class="title function_">get</span>(<span class="literal">undefined</span>)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>初始化后，可以使用 set()方法在添加键/值对。另外，可以使用 get()和 has()进行查询，可以通过 size 属性获取映射中的键/值对的数量，还可以使用 delete()和 clear()删除值。delete()返回一个布尔值，表示集合中是否存在要删除的键.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m_4 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;Kinsiy&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;lastName&quot;</span>, <span class="string">&quot;Restituo&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">m_4.<span class="title function_">set</span>(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4); <span class="comment">// &#123;&quot;firstName&quot; =&gt; &quot;Kinsiy&quot;, &quot;lastName&quot; =&gt; &quot;Restituo&quot;, &quot;age&quot; =&gt; &quot;23&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4.<span class="title function_">has</span>(<span class="string">&quot;firstName&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4.<span class="title function_">get</span>(<span class="string">&quot;lastName&quot;</span>)); <span class="comment">// Restituo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4.<span class="property">size</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4.<span class="title function_">delete</span>(<span class="string">&quot;age&quot;</span>)); <span class="comment">// true 只删除这一个键/值对</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4); <span class="comment">// &#123;&quot;firstName&quot; =&gt; &quot;Kinsiy&quot;, &quot;lastName&quot; =&gt; &quot;Restituo&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">m_4.<span class="title function_">clear</span>(); <span class="comment">// 清除这个映射实例中的所有键/值对</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_4); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>在映射中用作键和值得对象及其他&quot;集合&quot;类型，在自己的内容或属性被修改时仍然保持不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m_5 = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">const</span> obj_key = &#123;&#125;,</span><br><span class="line">  obj_val = &#123;&#125;,</span><br><span class="line">  arr_key = [],</span><br><span class="line">  arr_val = [];</span><br><span class="line"></span><br><span class="line">m_5.<span class="title function_">set</span>(obj_key, obj_val).<span class="title function_">set</span>(arr_key, arr_val);</span><br><span class="line"></span><br><span class="line">obj_key.<span class="property">foo</span> = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">obj_val.<span class="property">bar</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">arr_key.<span class="title function_">push</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line">arr_val.<span class="title function_">push</span>(<span class="string">&quot;Restituo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_5.<span class="title function_">get</span>(obj_key)); <span class="comment">// &#123;bar: &quot;bar&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_5.<span class="title function_">get</span>(arr_key)); <span class="comment">// [&quot;Restituo&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="顺序与迭代">顺序与迭代</h2>
<p>与 Object 类型的一个主要的差异是，Map 实例会维护键/值对的插入顺序，因此可以按照插入顺序执行迭代操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m_6 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;Javascript&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;two&quot;</span>, <span class="string">&quot;Java&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;three&quot;</span>, <span class="string">&quot;Python&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;four&quot;</span>, <span class="string">&quot;C&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m_6.<span class="property">entries</span> === m_6[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* entries(),keys(),values() */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> m_6.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span>    value: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key: one    value: Javascript</span></span><br><span class="line"><span class="comment">// key: two    value: Java</span></span><br><span class="line"><span class="comment">// key: three    value: Python</span></span><br><span class="line"><span class="comment">// key: four    value: C</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m_6.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// one two three four</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> m_6.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// Javascript Java Python C</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...m_6]); <span class="comment">//[[&quot;one&quot;, &quot;Javascript&quot;], [&quot;two&quot;, &quot;Java&quot;], [&quot;three&quot;, &quot;Python&quot;], [&quot;four&quot;, &quot;C&quot;]]</span></span><br></pre></td></tr></table></figure>
<p>键和值在迭代器遍历时时可以修改的，但映射内部的引用则无法修改。当然，这并不妨碍修改作为键或值的对象内部的属性。因为这样并不英雄他们在映射实例中的身份。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj_key = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> m_7 = <span class="keyword">new</span> <span class="title class_">Map</span>([[obj_key, <span class="string">&quot;Kinsiy&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> m_7.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  key.<span class="property">id</span> = <span class="number">8</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &#123;id: 8&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(m_7.<span class="title function_">get</span>(key)); <span class="comment">// Kinsiy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择-Object-还是-Map">选择 Object 还是 Map</h2>
<ol>
<li><b>内存占用。</b> 给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对。</li>
<li><b>插入性能。</b> 两者消耗大致相当，不过 Map 在所有浏览器中一般会稍微快一点儿。</li>
<li><b>查找速度。</b> 从大型 Object 和 Map 中查找键/值对的性能差异极小，但如果只包含少量键值对,则 Object 有时候速度更快。如果代码涉及大量查找操作，那么某些时候可能选择 Object 更好一些</li>
<li><b>删除性能。</b> 对大多浏览器引擎来说，Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。</li>
</ol>
<h1>WeakMap</h1>
<p>WeakMap 是 Map 的&quot;兄弟&quot;类型，其 API 也是 Map 的子集。WeakMap 中的&quot;Weak&quot; 描述的是 Javascript 垃圾回收程序对待&quot;弱映射&quot;中键的方式。</p>
<h2 id="基本-API-2">基本 API</h2>
<p>弱映射的键只能是 Object 或继承自 Object 的类型。尝试使用非对象设置键会抛出 TypeError，值得类型没有限制。API 包括 set()、has()、get()、delete()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj_1 = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  obj_2 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  obj_3 = &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">/* 初始化是全有或全无的操作</span></span><br><span class="line"><span class="comment">    只要有一个键无效就会抛出错误，导致整个初始化失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> m_1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([</span><br><span class="line">  [obj_1, <span class="string">&quot;value_1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;Str_obj_2&quot;</span>, <span class="string">&quot;value_2&quot;</span>],</span><br><span class="line">  [obj_3, <span class="string">&quot;value_3&quot;</span>],</span><br><span class="line">]); <span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>
<h2 id="弱键">弱键</h2>
<p>WeakMap 中&quot;weak&quot;表示弱映射的键时&quot;弱弱地拿着&quot;的。意思就是，这些键不属于正式的引用，不会阻止垃圾回收。但要注意的是，弱映射中值的引用可不是&quot;弱弱地拿着&quot;的。只要键存在，键值对就会存在于映射中，并被当作值得引用，因此就不会被当作垃圾回收。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  由于没有指向这个对象(&#123;&#125;)的其他引用，这行代码执行完之后，这个对象键就会被当作垃圾回收。</span></span><br><span class="line"><span class="comment">    键值对被破坏，值也会成为垃圾回收的目标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> wm_1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[&#123;&#125;, <span class="string">&quot;value_1&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* container 维护着一个对弱映射键的引用，这个键不会成为垃圾回收的目标</span></span><br><span class="line"><span class="comment">    如果调用了remove_Reference，就会摧毁对象的最后一个引用，垃圾回收程序会把这个键值对清理掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> container = &#123;</span><br><span class="line">  <span class="attr">key</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> wm_2 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>([[container.<span class="property">key</span>, <span class="string">&quot;value_2&quot;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">remove_Reference</span>(<span class="params"></span>) &#123;</span><br><span class="line">  container.<span class="property">key</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用弱映射">使用弱映射</h2>
<h3 id="私有变量">私有变量</h3>
<p>(有些不理解，待研究)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">idProperty</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setId</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setPrivate</span>(<span class="params">property, value</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> privateMemers = wm.<span class="title function_">get</span>(<span class="variable language_">this</span>) || &#123;&#125;;</span><br><span class="line">      privateMemers[property] = value;</span><br><span class="line">      wm.<span class="title function_">set</span>(<span class="variable language_">this</span>, privateMembers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getPrivate</span>(<span class="params">property</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> wm.<span class="title function_">get</span>(<span class="variable language_">this</span>)[property];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setId</span>(<span class="params">id</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getId</span>(<span class="params">id</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">getPrivate</span>(<span class="variable language_">this</span>.<span class="property">idProperty</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">User</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="title function_">getId</span>()); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<h3 id="DOM-节点元数据">DOM 节点元数据</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm_1 = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OneDom</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#login&quot;</span>);</span><br><span class="line">wm.<span class="title function_">set</span>(<span class="title class_">OneDom</span>, &#123; <span class="attr">disabled</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当节点从DOM树删除后，垃圾回收程序就可以立即释放其内存(架设没有其他地方引用这个对象)。</span></span><br></pre></td></tr></table></figure>
<h1>Set</h1>
<p>集合数据结构。Set 在很多方面都像是加强的 Map，这是因为他们的大多数 API 和行为都是共有的。</p>
<h2 id="基本-API-3">基本 API</h2>
<p>与 Map 相比，Set 的 API 基本与 Map 一致，不过 Map 的 set()方法，在 Set 这边变为 add(),功能类似,均为向集合中新增元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s_1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;val_1&quot;</span>, <span class="string">&quot;val_2&quot;</span>, <span class="string">&quot;val_3&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_1); <span class="comment">// &#123;&quot;val_1&quot;, &quot;val_2&quot;, &quot;val_3&quot;&#125;</span></span><br><span class="line">s_1.<span class="title function_">add</span>(<span class="string">&quot;val_4&quot;</span>).<span class="title function_">add</span>(<span class="string">&quot;val_5&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_1); <span class="comment">// &#123;&quot;val_1&quot;, &quot;val_2&quot;, &quot;val_3&quot;, &quot;val_4&quot;, &quot;val_5&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="顺序与迭代-2">顺序与迭代</h2>
<p>与 Map 相比，Set 的迭代方法也大都一致。Set 的 entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值得重复出现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s_2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&quot;Kinsiy&quot;</span>, <span class="string">&quot;Restituo&quot;</span>, <span class="string">&quot;Supreman&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_2); <span class="comment">// &#123;&quot;Kinsiy&quot;, &quot;Restituo&quot;, &quot;Supreman&quot;&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> s_2.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">// [&quot;Kinsiy&quot;, &quot;Kinsiy&quot;] [&quot;Restituo&quot;, &quot;Restituo&quot;] [&quot;Supreman&quot;, &quot;Supreman&quot;]</span></span><br><span class="line">  v = <span class="string">&quot;Super&quot;</span>; <span class="comment">// 修改集合中值得属性不会影响其作为集合值得身份</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_2); <span class="comment">// &#123;&quot;Kinsiy&quot;, &quot;Restituo&quot;, &quot;Supreman&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h1>WeakSet</h1>
<p>与 Map 和 WeakMap 的关系类似，WeakSet 也是 Set 的&quot;兄弟&quot;类型，其 API 也是 Set 的子集。&quot;weak&quot;描述的是 Javascript 垃圾回收程序对待&quot;弱集合&quot;中值得方式。弱集合中的值只能是 Object 或者继承自 Object 的类型。</p>
<h2 id="基本-API-4">基本 API</h2>
<p>包括 add()、has()、delete()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj_1 = &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> s_3 = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line">s_3.<span class="title function_">add</span>(obj_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_3.<span class="title function_">has</span>(obj_1)); <span class="comment">// true</span></span><br><span class="line">s_3.<span class="title function_">delete</span>(obj_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s_3.<span class="title function_">has</span>(obj_1)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="不可迭代值">不可迭代值</h2>
<p>因为 WeakSet 中的值任何时候都可能被销毁，所以没必要提供迭代其值得能力。当然，也用不着向 clear()这样一次性销毁所有值得方法。</p>
<h2 id="使用弱集合">使用弱集合</h2>
<p>打标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledElements = <span class="keyword">new</span> <span class="title class_">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> loginButton = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#login&quot;</span>);</span><br><span class="line">disabledElements.<span class="title function_">add</span>(loginButton);</span><br><span class="line"><span class="comment">// 只要WeakSet 中任何元素从DOM树中被删除，垃圾回收程序就可以忽略其存在，而立即释放其内存(假设没有其他地方引用这个对象)</span></span><br></pre></td></tr></table></figure>
<h1>迭代与扩展操作</h1>
<p>有四种原生集合定义了默认迭代器：</p>
<ul>
<li>Array</li>
<li>所有的定型数组</li>
<li>Map</li>
<li>Set</li>
</ul>
<p>这意味着上述所有类型都支持顺序迭代，都可以传入 for-of 循环。这也意味着这些类型都兼容扩展操作符。扩展操作符在对可迭代对象执行浅复制时特别有用，只需简单的语法就可以复制整个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr_2 = [...arr_1];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_1 === arr_2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于构建数组的部分元素 */</span></span><br><span class="line"><span class="keyword">let</span> arr_3 = [<span class="number">5</span>, <span class="number">2</span>, ...arr_1, <span class="number">9</span>, <span class="number">8</span>]; <span class="comment">// [5, 2, 1, 2, 3, 4, 9, 8]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对于期待可迭代对象的构造函数，只要传入一个可迭代对象就可以实现复制 */</span></span><br><span class="line"><span class="keyword">let</span> map_1 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;key_1&quot;</span>, <span class="string">&quot;1&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;key_2&quot;</span>, <span class="string">&quot;2&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> map_2 = <span class="keyword">new</span> <span class="title class_">Map</span>(map_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map_2); <span class="comment">// &#123;&quot;key_1&quot; =&gt; &quot;1&quot;, &quot;key_2&quot; =&gt; &quot;2&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 浅复制意味着只会复制对象的引用 */</span></span><br><span class="line"><span class="keyword">let</span> arr_4 = [&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr_5 = [...arr_4];</span><br><span class="line">arr_4[<span class="number">0</span>].<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr_5[<span class="number">0</span>]); <span class="comment">// &#123;name: &quot;Kinsiy&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Map</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-迭代器与生成器</title>
    <url>/Javascript-Iterable&amp;Iterator/</url>
    <content><![CDATA[<h2 id="理解迭代">理解迭代</h2>
<p>在 Javascript 中计数循环就是一种最简单的迭代。循环是迭代的基础，这是因为它可以指定迭代的次数，以及每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完成，而每次迭代的顺序都是事先定义好的。<br>
迭代会在一个有序集合上进行。(&quot;有序&quot;可以理解为集合中所有的项都可以按照既定的顺序被遍历到，特别是开始和结束都有明确的定义。)数组是 Javascript 中有序集合的最典型的例子。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的迭代，计数循环 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);     <span class="comment">// 1,2,...,10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Javascript&quot;</span>,<span class="string">&quot;Java&quot;</span>]；</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr[index]);    <span class="comment">// &quot;Python&quot; &quot;Javascript&quot; &quot;Java&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ES5 新增了Array.prototype.forEach()方法，想通用迭代需求迈进了一步(但仍不够理想) */</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(item))    <span class="comment">// // &quot;Python&quot; &quot;Javascript&quot; &quot;Java&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器模式">迭代器模式</h2>
<p>迭代器模式(特别是 ECMAScript 这个语境下)描述了一个方案，即可以把有些结构称为“可迭代对象”(iterable)，因为它们实现了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。<br>
可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解成数组或集合这样的集合类型的对象。它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。迭代器无需了解与其关联的可迭代对象的结构，只需知道如何取得连续的值。</p>
<h3 id="可迭代协议">可迭代协议</h3>
<p>实现 Iterale 接口(可迭代协议)要求同时具备两种能力：支持迭代的自我识别能力和创建实现 Iterator 接口的对象的能力。在 ECMAScript 中，这意味着必须暴露一个属性作为&quot;默认迭代器&quot;，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。很多内置类型都实现了 Iterable 接口：</p>
<ul>
<li>字符串</li>
<li>数组</li>
<li>映射</li>
<li>集合</li>
<li>arguments 对象</li>
<li>NodeList 等 DOM 集合类型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否存在默认迭代器属性可以暴露这个工厂函数 */</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Javascript&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>).<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>).<span class="title function_">add</span>(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">let</span> els = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ [Symbol.iterator]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ entries() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用工厂函数 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// StringIterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// MapIterator &#123;&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// SetIterator &#123;&quot;c&quot;, &quot;d&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(els[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际写代码过程中,不需要显式调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。接收可迭代对象的原生语言特性包括：</p>
<ul>
<li>for - of 循环</li>
<li>数组解构</li>
<li>扩展操作符</li>
<li>Array.from()</li>
<li>创建集合</li>
<li>创建映射</li>
<li>Promise.all()接收由期约组成的可迭代对象</li>
<li>Promise.race()接收由期约组成的可迭代对象</li>
<li>yield* 操作符，在生成器中使用</li>
</ul>
<p>这些原生语言结构会在后台调用提供的可迭代对象的这个工厂函数，从而创建一个迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Javascript&quot;</span>];</span><br><span class="line"><span class="comment">// 数组结构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c); <span class="comment">// Python C Javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Map 构造函数</span></span><br><span class="line"><span class="keyword">let</span> pairs = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">x, i</span>) =&gt;</span> [x.<span class="title function_">toUpperCase</span>(), i]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pairs); <span class="comment">// [[&quot;PYTHON&quot;, 0], [&quot;C&quot;, 1], [&quot;JAVASCRIPT&quot;, 2]]</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>(pairs);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m); <span class="comment">// &#123;&quot;PYTHON&quot; =&gt; 0, &quot;C&quot; =&gt; 1, &quot;JAVASCRIPT&quot; =&gt; 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果对象原型链上的父类实现了Iterable接口，那这个对象也就实现是这个接口 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KinsiyArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">KinsiyArr</span> = <span class="keyword">new</span> <span class="title class_">KinsiyArray</span>(<span class="string">&quot;Html&quot;</span>, <span class="string">&quot;Xml&quot;</span>, <span class="string">&quot;Hxml&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> el <span class="keyword">of</span> <span class="title class_">KinsiyArr</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(el); <span class="comment">// Html Xml Hxml</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器协议">迭代器协议</h3>
<p>迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对象。迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Javascript&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;Python&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器工厂函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter); <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行迭代</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Javascript&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;C&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Python&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* done: true状态称为&quot;耗尽&quot;。只要迭代器到达done: true状态，后续调用next()就一直返回同样的值了 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同迭代器的实例相互之间没有联系</span></span><br><span class="line"><span class="keyword">let</span> iter_1 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="keyword">let</span> iter_2 = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter_1.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Javascript&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter_2.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Javascript&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象在迭代期间被修改了，迭代器也会反映相应的变化</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iter_1.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Java&quot;, done: false&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="自定义迭代器">自定义迭代器</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Kinsiy</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">limit</span> = limit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>,</span><br><span class="line">      limit = <span class="variable language_">this</span>.<span class="property">limit</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; limit) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">Kinsiy</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> me) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提前终止迭代器">提前终止迭代器</h3>
<p>可选的 return()方法用于指定迭代器提前关闭时执行的逻辑。执行迭代的结构在想让迭代器知道它不想遍历到可迭代对象耗尽时，就可以关闭迭代器。可能的情况包括：</p>
<ul>
<li>for - of 循环通过 break, continue, return, thorw 提前退出</li>
<li>解构操作并未消费所有值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chat <span class="keyword">of</span> counter)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chat == <span class="string">&quot;B&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="string">&quot;err&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(chat);      <span class="comment">// A    提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="生成器">生成器</h2>
<p>生成器是 EMCAScript 6 新增的一个极为灵活的结构，拥有在一个函数块内暂停和恢复代码执行的能力。</p>
<h3 id="生成器基础">生成器基础</h3>
<p>生成器的形式是一个函数，函数名称前面加一个星号(*)表示它是一个生成器。只要是可以定义函数的地方，就可以定义生成器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 标识生成器函数的星号不受两侧空格影响 */</span></span><br><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> generatorF = <span class="keyword">function</span>* ()&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为对象字面量方法的生成器函数</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">    * <span class="title function_">generator_f</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为类实例方法的生成器函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">foo</span> = &#123;</span><br><span class="line">    * <span class="title function_">generator_Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 箭头函数不能用来定义生成器函数 */</span></span><br></pre></td></tr></table></figure>
<p>调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行(suspended)的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="property">next</span>); <span class="comment">// ƒ next() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* next()方法的返回值类似于迭代器，有一个done属性和一个value属性。</span></span><br><span class="line"><span class="comment">    函数体为空的生成器函数中间不会停留，调用一次next()就会让生成器达到done: true 状态</span></span><br><span class="line"><span class="comment">    value属性是生成器函数的返回值，默认值为undefined，可以通过生成器函数的返回值指定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g_1 = <span class="title function_">generatorFn_1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g_1); <span class="comment">// generatorFn_1 &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g_1.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;foo&quot;, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成器函数只会在初次调用next()方法后开始执行 */</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初次调用生成器函数并不会打印日志</span></span><br><span class="line"><span class="keyword">let</span> g_2 = <span class="title function_">generatorFn_2</span>();</span><br><span class="line">g_2.<span class="title function_">next</span>(); <span class="comment">// running</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生成器对象实现了Iterator 接口，他们默认的迭代器是自引用的 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generatorFn); <span class="comment">// ƒ* generatorFn()&#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generatorFn</span>()[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]); <span class="comment">// ƒ [Symbol.iterator]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g === g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="通过-yield-中断执行">通过 yield 中断执行</h3>
<p>yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到这个我关键字后，执行会停止，函数作用域的状态会被保留。停止执行的生成器函数只能通过在生成器对象上调用 next()方法来恢复执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过yield 关键字退出的生成器函数会处在done: false 状态; 通过return关键字退出的生成器函数会处于done: true 状态 */</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;Hey&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Live&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Kinsiy&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Hey&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Live&quot;, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在一个生成器对象上调用next()不会影响其他生成器</span></span><br><span class="line"><span class="comment">    yield 关键字必须直接位于生成器函数定义中，出现在嵌套的非生成器函数中会抛出语法错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 有效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无效</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ chrome(88.0.4324.146)未见报错，但yield 确实无效 ]</span></span><br></pre></td></tr></table></figure>
<h4 id="生成器对象作为可迭代对象">生成器对象作为可迭代对象</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">genertorFn</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is : <span class="subst">$&#123;x&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x is : 0</span></span><br><span class="line"><span class="comment">// x is : 1</span></span><br><span class="line"><span class="comment">// x is : 2</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-yield-实现输入输出">使用 yield 实现输入输出</h4>
<p>除了可以作为函数的中间返回语句使用，yield 关键字还可以作为函数的中间参数使用。上一次让生成器函数暂停的 yield 关键字会接收到传给 next()方法的第一个值。<br>
第一次调用的 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(initial);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = <span class="title function_">genertorFn</span>(<span class="string">&quot;Chinese&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&quot;Test&quot;</span>)); <span class="comment">// Chinese</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&quot;English&quot;</span>)); <span class="comment">// English</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同时用于输入和输出 */</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g_1 = <span class="title function_">genertorFn_1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g_1.<span class="title function_">next</span>()); <span class="comment">// &#123;value: &quot;Kinsiy&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g_1.<span class="title function_">next</span>(<span class="string">&quot;Queen&quot;</span>)); <span class="comment">// &#123;value: &quot;Queen&quot;, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="产生可迭代对象">产生可迭代对象</h4>
<p>可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对象，从而一次产出一个值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* yield* 的值是关联迭代器返回done: true 时的value的值。</span></span><br><span class="line"><span class="comment">    使用console.log(yield*)的原因是 for-of 循环等内置语言结构会忽略状态为done: true 的IteratorObject 内部返回的值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ,];</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>* [<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// 打印yield*</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>* <span class="title function_">genertorFn_1</span>()); <span class="comment">// 打印yield*</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">genertorFn_2</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// undefined        对于普通迭代器来说，这个值是undefined</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8                对于生成器函数产生的迭代器来说，这个值就是生成器函数返回的值</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-yield-实现递归算法">使用 yield* 实现递归算法</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">nTimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="title function_">nTimes</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> n - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="title function_">nTimes</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历图数据结构示例(暂略)。</p>
<h3 id="生成器作为默认迭代器">生成器作为默认迭代器</h3>
<p>因为生成器对象实现了 Iterator 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">values</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">values</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> f)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提前终止生成器">提前终止生成器</h3>
<p>与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next()方法，还有一个可选的 return() 方法用于提前终止迭代器。生成器对象除了有这两个方法，还有第三个方法 throw()。</p>
<h4 id="return">return()</h4>
<p>retrun()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">genertorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// genertorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="keyword">return</span>(<span class="string">&quot;Kinsiy&quot;</span>)); <span class="comment">// &#123;value: Kinsiy, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// genertorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="throw">throw()</h4>
<p>throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn_1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">genertorFn_1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// genertorFn_1 &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.<span class="keyword">throw</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Kinsiy</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g); <span class="comment">// genertorFn_1 &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure>
<p>不过，假如生成器函数内部处理了这个错误，那么生成器就不会关闭，而且还可以恢复执行。错误处理会跳过对应的 yield</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">genertorFn_2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// yield e</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">genertorFn_2</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">g.<span class="keyword">throw</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()); <span class="comment">// &#123;value: 6, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* console.log(g.throw(&quot;Kinsiy&quot;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    genertorFn_2() 不yield e </span></span><br><span class="line"><span class="comment">    &#123;value: 5, done: false&#125;</span></span><br><span class="line"><span class="comment">    反之 yield e </span></span><br><span class="line"><span class="comment">    &#123;value: &quot;Kinsiy&quot;, done: false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-(Global &amp; Math)</title>
    <url>/Javascript-Math/</url>
    <content><![CDATA[<p>任何由 EMCAscript 实现提供、与宿主环境无关，并在 EMCAscript 程序开始执行时就存在的对象。前面已经接触了大部分内置对象，包括 Object，Array 和 String。本文介绍 EMCA-262 定义的另外两个单例对象：Global 和 Math。</p>
<h1>Global</h1>
<p>Global 对象为一种兜底对象，它所针对的是不属于任何对象的属性和方法。在全局作用域中的变量和方法都会成为 Global 对象的属性。</p>
<span id="more"></span>
<h2 id="URL-编码方法">URL 编码方法</h2>
<p>encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符(URI)，以便传给浏览器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编码</span></span><br><span class="line"><span class="comment">    encodeURI()</span></span><br><span class="line"><span class="comment">    encondeURIComponent()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">&quot;https://kinsiy.github.io?name=哈哈哈&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> url_1 = <span class="built_in">encodeURI</span>(uri);</span><br><span class="line"><span class="keyword">let</span> url_2 = <span class="built_in">encodeURIComponent</span>(uri);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url_1); <span class="comment">// https://kinsiy.github.io?name=%E5%93%88%E5%93%88%E5%93%88</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url_2); <span class="comment">// https%3A%2F%2Fkinsiy.github.io%3Fname%3D%E5%93%88%E5%93%88%E5%93%88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 解码</span></span><br><span class="line"><span class="comment">    decodeURI()</span></span><br><span class="line"><span class="comment">    decondeURIComponent()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURI</span>(url_1)); <span class="comment">// https://kinsiy.github.io?name=哈哈哈</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(url_2)); <span class="comment">// https://kinsiy.github.io?name=哈哈哈</span></span><br></pre></td></tr></table></figure>
<h2 id="eval">eval()</h2>
<p>这个方法就是一个完整的 EMCAScript 解释器，它接收一个参数，即一个要执行的 EMCAScript(Javascript)字符串。<br>
通过 eval()定义的任何变量和函数都不会提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;console.log(msg)&quot;</span>); <span class="comment">// hello world!</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function sayHi() &#123; console.log(&#x27;Hi&#x27;); &#125;&quot;</span>);</span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;var name = &#x27;Kinsiy&#x27;&quot;</span>); <span class="comment">// 此处使用let与const声明console.log()均为空，原因不明，作用域原因？</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Kinsiy</span></span><br></pre></td></tr></table></figure>
<h2 id="Global-属性">Global 属性</h2>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">特殊值 undefined</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">特殊值 NaN</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">特殊值 Infinity</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">Object 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">Array 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Function</td>
<td style="text-align:left">Function 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">Boolean 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">String 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">Number 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">Date 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">RegExp</td>
<td style="text-align:left">RegExp 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Symbol</td>
<td style="text-align:left">Symbol 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">Error</td>
<td style="text-align:left">Errot 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">EvalError</td>
<td style="text-align:left">EvalError 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">RangeError</td>
<td style="text-align:left">RangerError 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">ReferenceError</td>
<td style="text-align:left">RefenceError 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">SyntaxError</td>
<td style="text-align:left">SytaxError 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">TypeError</td>
<td style="text-align:left">TypeError 的构造函数</td>
</tr>
<tr>
<td style="text-align:left">URIError</td>
<td style="text-align:left">URIError 的构造函数</td>
</tr>
</tbody>
</table>
<h2 id="window-对象">window 对象</h2>
<p>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域声明的变量和函数都变成了 window 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">color</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">satColor</span>(); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 另一种获取Global对象的方式 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">global</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h1>Math</h1>
<h2 id="Math-对象属性">Math 对象属性</h2>
<p>Math 有一些属性，主要用于保存数学中的一些特殊值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Math.E</td>
<td style="text-align:left">自然对数的基数 e 的值</td>
</tr>
<tr>
<td style="text-align:left">Math.LN10</td>
<td style="text-align:left">In10</td>
</tr>
<tr>
<td style="text-align:left">Math.LN2</td>
<td style="text-align:left">In2</td>
</tr>
<tr>
<td style="text-align:left">Math.LOG2E</td>
<td style="text-align:left">Log<sub>2</sub>e</td>
</tr>
<tr>
<td style="text-align:left">Math.LOG10E</td>
<td style="text-align:left">Log<sub>10</sub>e</td>
</tr>
<tr>
<td style="text-align:left">Math.PI</td>
<td style="text-align:left">π</td>
</tr>
<tr>
<td style="text-align:left">Math.SQRT1_2</td>
<td style="text-align:left">√(1/2)</td>
</tr>
<tr>
<td style="text-align:left">Math.SQRT2</td>
<td style="text-align:left">√2</td>
</tr>
</tbody>
</table>
<h2 id="min-max">min() &amp;&amp; max()</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">48</span>, <span class="number">56.1</span>, <span class="number">54.6</span>, <span class="number">100</span>, <span class="number">1.2</span>, <span class="number">100.5</span>); <span class="comment">// 100.5</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">5</span>, <span class="number">7</span>, <span class="number">48</span>, <span class="number">56.1</span>, <span class="number">54.6</span>, <span class="number">100</span>, <span class="number">1.2</span>, <span class="number">100.5</span>); <span class="comment">// 1.2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(max);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(min);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用扩展操作符 */</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">5</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">25</span>, <span class="number">7</span>, <span class="number">45</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(...values)); <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>
<h2 id="舍入方法">舍入方法</h2>
<ul>
<li>Math.ceil() 向上取整</li>
<li>Math.floor() 向下取整</li>
<li>Math.round() 四舍五入</li>
<li>Math.fround() 返回数值最接近的单精度(32 位)浮点值表示</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">25.5</span>)); <span class="comment">// 26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">25.5</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">26.6</span>)); <span class="comment">// 27</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">fround</span>(<span class="number">26.8</span>)); <span class="comment">// 26.799999237060547</span></span><br></pre></td></tr></table></figure>
<h2 id="random">random()</h2>
<p>Math.random()返回一个 0~1 范围内的随机数，其中包含 0 不包含 1。[0,1)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 随机数公式</span></span><br><span class="line"><span class="comment">    number = Math.floor(Math.random() * total_number_of_choices + first_possible_value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> choices = upperValue - lowerValue + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * choices + lowerValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">selectFrom</span>(<span class="number">5</span>, <span class="number">45</span>)); <span class="comment">// [5,45]</span></span><br><span class="line">  i++; <span class="comment">// 8 17 28 17 11 (5个随机数)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他方法">其他方法</h2>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Math.abs(x)</td>
<td style="text-align:left">x 的绝对值</td>
</tr>
<tr>
<td style="text-align:left">Math.exp(x)</td>
<td style="text-align:left">e<sup>x</sup></td>
</tr>
<tr>
<td style="text-align:left">Math.expm1(x)</td>
<td style="text-align:left">e<sup>x</sup>-1</td>
</tr>
<tr>
<td style="text-align:left">Math.log(x)</td>
<td style="text-align:left">Inx</td>
</tr>
<tr>
<td style="text-align:left">Math.log1p(x)</td>
<td style="text-align:left">1+Inx</td>
</tr>
<tr>
<td style="text-align:left">Math.pow(x, power)</td>
<td style="text-align:left">x<sup>power</sup></td>
</tr>
<tr>
<td style="text-align:left">Math.hypot(…nums)</td>
<td style="text-align:left">√(a<sup>2</sup>+b<sup>2</sup>+…+n<sup>2</sup>)</td>
</tr>
<tr>
<td style="text-align:left">Math.clz32(x)</td>
<td style="text-align:left">返回 32 位整数 x 的前置零的数量</td>
</tr>
<tr>
<td style="text-align:left">Math.sign(x)</td>
<td style="text-align:left">返回表示 x 符号的 1、0、-0 或-1</td>
</tr>
<tr>
<td style="text-align:left">Math.trunc(x)</td>
<td style="text-align:left">取整</td>
</tr>
<tr>
<td style="text-align:left">Math.sqrt(x)</td>
<td style="text-align:left">√x</td>
</tr>
<tr>
<td style="text-align:left">Math.cbrt(x)</td>
<td style="text-align:left"><sup>3</sup>√x</td>
</tr>
<tr>
<td style="text-align:left">Math.acos(x)</td>
<td style="text-align:left">cos<sup>-1</sup>x</td>
</tr>
<tr>
<td style="text-align:left">Math.acosh(x)</td>
<td style="text-align:left">反双曲余弦</td>
</tr>
<tr>
<td style="text-align:left">Math.asin(x)</td>
<td style="text-align:left">sin<sup>-1</sup>x</td>
</tr>
<tr>
<td style="text-align:left">Math.asinh(x)</td>
<td style="text-align:left">反双曲正弦</td>
</tr>
<tr>
<td style="text-align:left">Math.atan(x)</td>
<td style="text-align:left">tan<sup>-1</sup>x</td>
</tr>
<tr>
<td style="text-align:left">Math.atanh(x)</td>
<td style="text-align:left">反双曲正切</td>
</tr>
<tr>
<td style="text-align:left">Math.atan2(y, x)</td>
<td style="text-align:left">tan<sup>-1</sup>(y/x)</td>
</tr>
<tr>
<td style="text-align:left">Math.sin(x)</td>
<td style="text-align:left">sin(x)</td>
</tr>
<tr>
<td style="text-align:left">Math.cos(x)</td>
<td style="text-align:left">cos(x)</td>
</tr>
<tr>
<td style="text-align:left">Math.tan(x)</td>
<td style="text-align:left">tan(x)</td>
</tr>
</tbody>
</table>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Global</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Promise</title>
    <url>/Javascript-Promise/</url>
    <content><![CDATA[<p>期约是对尚不存在的的结果的一个替身。ESMAScript 6 增加了对 Promise/A+规范的完善支持，即 Promise 类型。一经退出，Promise 就大受欢迎，成为了主导性的异步编程机制。所有的现代浏览器都支持 ES6 期约，很多其他浏览器 API(如 fetch()和电池 API)也以期约为基础。</p>
<h2 id="期约基础">期约基础</h2>
<p>ESMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新期约时需要传入执行器(executor)函数作为参数。</p>
<span id="more"></span>
<h3 id="期约状态">期约状态</h3>
<ul>
<li>待定(pending)</li>
<li>兑现(fulfilled，有时候也称为&quot;解决&quot;，resolved)</li>
<li>拒绝(rejected)<br>
待定(pending)是期约的最初始状态。在待定状态下，期约可以落定(settled)为代表成功的兑现(fulfilled)状态，或者代表失败的拒绝(rejected)状态。无论落定为那种状态都是不可逆的。只要从待定转换为兑现或拒绝，期约的状态就不再改变。而且，也不能保证期约必然会脱离待定(pending)状态。因此，组织合理的代码无论期约解决(resolve)还是拒绝(reject)，甚至是永远待定(pending)状态，都应该具有恰当的行为。</li>
</ul>
<h3 id="解决值、拒绝理由己期约用例">解决值、拒绝理由己期约用例</h3>
<p>期约主要有两大用途。首先是抽象地表示一个异步操作。期约的状态代表期约是否完成。&quot;待定&quot;表示尚未开始或者正在执行中。&quot;兑现&quot;表示已经成功完成，而&quot;拒绝&quot;则表示没有成功完成。<br>
每个期约只要状态切换为兑现，就会有一个私有的内部值(value)。类似的，每个期约只要状态切换为拒绝，就会有一个私有的内部理由(reason)。无论是值还是理由，都是包含原始值或对象的不可修改的引用。二者都是可选的，而且默认值为 undefined。在期约到达某个落定状态时执行的异步代码始终会收到这个值或理由。</p>
<h3 id="通过执行函数控制期约状态">通过执行函数控制期约状态</h3>
<p>由于期约的状态是私有的，所以只能在内部进行操作。内部操作在期约的执行器函数中完成。执行器函数主要有两项职责：初始化期约的异步行为和控制状态的最终转换。其中，控制期约状态的转换是通过调用它的两个函数参数实现的。这两个函数擦参数通常都命名为 resolve()和 reject()。调用 resolve()会把状态切换为兑现，调用 reject()会把状态切换为拒绝。另外，调用 reject()也会抛出错误(后面讨论)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(reject, <span class="number">10000</span>); <span class="comment">// 10 秒后调用reject</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p); <span class="comment">// Promise</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">11000</span>, p); <span class="comment">// 11秒后再检查状态  Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br></pre></td></tr></table></figure>
<p><b>注意：</b>执行器函数是同步执行的</p>
<h3 id="Promise-resolve">Promise.resolve()</h3>
<p>期约并非一开始就必须处于待定状态。然后通过执行器函数才能转换为落定状态。通过调用 Promise.resolve()静态方法，可以实例化为一个解决的期约。使用这个静态方法，实际上可以把任何值都转换为一个期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个解决的期约的值对应着传给Promise.resolve()的第一个参数。多于的参数会忽略</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 1&#125;</span></span><br></pre></td></tr></table></figure>
<p>对这个静态方法而言，如果传入的参数本身就是一个期约，那它的行为就类似一个空包装。因此，Promise.resolve()可以说是一个幂等方法。这个幂等性会保留传入期约的状态。</p>
<h3 id="Promise-reject">Promise.reject()</h3>
<p>与 Promise.resolve()类似，Promise.reject()会实例化一个拒绝的期约并抛出一个异步错误(这个错误不能通过 try/catch 捕获，而只能通过拒绝处理程序捕获)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>());</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>()); <span class="comment">// Promise &#123;&lt;rejected&gt;: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个解决的期约的值对应着传给Promise.reject()的第一个参数。多于的参数会忽略</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// Promise &#123;&lt;rejected&gt;: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>())); <span class="comment">// Promise &#123;&lt;rejected&gt;: Promise&#125;</span></span><br></pre></td></tr></table></figure>
<p>关键在于，Promise.reject()并没有照搬 Promise.resolve()的幂等逻辑。如果给它传一个期约对象，则这个对象会成为它返回的拒绝期约的理由</p>
<h3 id="同步-异步执行的二元性">同步/异步执行的二元性</h3>
<p>Promise 的设计很大程度上会导致一种完全不同与 Javascript 的计算模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;bar&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: bar</span></span><br></pre></td></tr></table></figure>
<p>拒绝期约的错误并没有抛到执行同步代码的线程里，而是通过浏览器异步消息队列来处理的。因此，try/catch 块并不能捕获该错误。代码一旦开始以异步模式执行，则唯一与之交互的方式就是使用异步结构——更具体地说，就是期约的方法。</p>
<h2 id="期约的实例方法">期约的实例方法</h2>
<p>期约实例的方法是连接外部同步代码与内部异步代码之间的桥梁，这些方法可以访问异步操作返回的数据，处理期约成功和返回的输出，连续对期约求值，或者添加只有期约进入终止状态时才会执行的代码。</p>
<h3 id="实现-Thenable-接口">实现 Thenable 接口</h3>
<p>在 ECMAScript 暴露的异步结构中，任何对象都有一个 then()方法。这个方法被认为实现了 Thenable()接口。ECMAScript 的 Promise 类型实现了 Thenable 接口</p>
<h3 id="Promise-prototype-then">Promise.prototype.then()</h3>
<p>Promise.prototype.then()是为期约实例添加处理程序的主要方法。这个 then()方法接收最多两个参数：onResolved()处理程序和 onReject()处理程序。这两个参数都是可选的，如果提供的话，则会在期约分别进入&quot;兑现&quot;和拒绝&quot;拒绝&quot;状态时执行。传给 then()的任何非函数类型的参数都会被静默忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onResolved</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&quot;resolved&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onReject</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, id, <span class="string">&quot;rejected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>));</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">3000</span>));</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">onResolved</span>(<span class="string">&quot;p1&quot;</span>),</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="title function_">onReject</span>(<span class="string">&quot;p1&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 这里使用箭头函数而不直接写onResolved(&quot;p1&quot;)的原因的，then是同步执行的，</span></span><br><span class="line"><span class="comment">// 若直接使用函数名，函数会直接执行，而等到期约落定时不会执行任何函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不传onResolve()处理程序的规范写法</span></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function">() =&gt;</span> <span class="title function_">onReject</span>(<span class="string">&quot;p2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3秒后</span></span><br><span class="line"><span class="comment">// p1 resolved</span></span><br><span class="line"><span class="comment">// p2 rejected</span></span><br></pre></td></tr></table></figure>
<p>Promise.prototype.then()返回一个新的期约实例。这个新期约实例基于 onResovled 处理程序的返回值构建。换句话说，改处理程序的返回值会通过 Promise.resolve()包装来生成新期约。如果没有提供这个处理程序，则 Promise.resolve()就会包装上一个期约解决之后的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p2); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;foo&quot;&#125;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p1 === p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有显式返回值，则Promise.resolve()会包装这个值</span></span><br><span class="line"><span class="keyword">let</span> p3 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p3); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常会返回拒绝的期约</span></span><br><span class="line"><span class="keyword">let</span> p4 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;baz&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p4); <span class="comment">// Promise &#123;&lt;rejected&gt;: &quot;baz&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而返回错误值不会触发拒绝行为</span></span><br><span class="line"><span class="keyword">let</span> p5 = p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;kinsiy&quot;</span>));</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p5); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Error: kinsiy</span></span><br></pre></td></tr></table></figure>
<p>onRejected()处理程序也与之类似：onRejected()处理程序返回的值也会被 Promise.resolve()包装。</p>
<h3 id="Promise-prototype-catch">Promise.prototype.catch()</h3>
<p>Promise.prototype.catch()方法用于给期约添加拒绝处理程序。这个方法只接受一个参数：onRejected()处理程序。事实上，这个方法就是一个语法糖，调用它就相当于调用 Promise.prototype.then(null, onRejected)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onRejected = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;rejected&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的行为是一样的</span></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected); <span class="comment">// rejected</span></span><br><span class="line">p1.<span class="title function_">catch</span>(onRejected); <span class="comment">// rejected</span></span><br></pre></td></tr></table></figure>
<p>Promise.prototype.catch()返回一个新的期约实例，其行为与 Promise.prototype.then()的 onRejected 处理程序是一样的。</p>
<h3 id="Promise-prototype-finally">Promise.prototype.finally()</h3>
<p>Promise.prototype.finally()方法用于给期约添加 onFinally()处理程序，这个处理程序在期约转换为解决或拒绝状态室都会执行。onFinally()处理程序没有办法知道期约的状态是解决还是拒绝，这个方法主要用于添加清理代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>();</span><br><span class="line"><span class="keyword">let</span> onFinally = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="string">&quot;Finally!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种添加拒绝处理程序的行为是一样的</span></span><br><span class="line">p1.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally!</span></span><br><span class="line">p2.<span class="title function_">finally</span>(onFinally); <span class="comment">// Finally!</span></span><br></pre></td></tr></table></figure>
<p>Promise.prototype.finally()方法返回一个新的期约实例。这个新期约实例不同于 then()或 catch()方式返回的实例。因为 onFinally 被设计为一个状态无关的方法，所以多数情况下它都会原样后传父期约。无论父期约是解决还是拒绝，都会原样后传。</p>
<h3 id="非重入期约方法">非重入期约方法</h3>
<p>当期约进入落定状态时，与改状态相关的处理程序仅仅会被排期，而非立即执行。跟在添加这个处理程序的代码之后的同步代码一定会在处理程序之前先执行。即使期约一开始就是与附加程序关联的状态，执行顺序也是这样的。这个特性由 Javascript 运行时保证，被称为&quot;非重入&quot;(non-reentrancy)特性.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> synchronousResolve;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  synchronousResolve = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1: invoking resolve&quot;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    conosole.<span class="title function_">log</span>(<span class="string">&quot;2: resolve returns&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Kinsiy test&quot;</span>);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;4: then() handler executes&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="title function_">synchronousResolve</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3: synchronousResolve() returns&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1: invoking resolve</span></span><br><span class="line"><span class="comment">// 2: resolve returns</span></span><br><span class="line"><span class="comment">// 3: synchronousResolve() returns</span></span><br><span class="line"><span class="comment">// 4: then() handler executes</span></span><br></pre></td></tr></table></figure>
<p>非重入适用于 onResolved/onRejected 处理程序、catch()处理程序和 finally()处理程序</p>
<h3 id="邻近处理程序的执行顺序">邻近处理程序的执行顺序</h3>
<p>如果给期约添加了多个处理程序，当期约状态变化时，相关处理程序会按照添加它们的顺序依次执行。无论是 then()、catch()还是 finally()添加的处理程序都是如此。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">3</span>));</span><br><span class="line">p2.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">5</span>));</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">7</span>));</span><br><span class="line">p1.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="传递解决值与拒绝理由">传递解决值与拒绝理由</h3>
<p>到了落定状态后，期约会提供其解决值(如果兑现)或其他拒绝理由(如果拒绝)给相关状态的处理程序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value)); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&quot;bar&quot;</span>));</span><br><span class="line">p2.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<h3 id="拒绝期约与拒绝错误处理">拒绝期约与拒绝错误处理</h3>
<p>拒绝期约类似于 throw()表达式，因为它们都代表一种程序状态，即需要中断或特殊处理。在期约的执行函数或处理程序中抛出错误会导致错误，对应的错误对象会成为拒绝的理由。<br>
正常情况下，在通过 throw()关键字抛出错误时，Javascript 运行时的错误处理程序会停止执行抛出错误之后的任何指令。但是，在期约中抛出错误时，因为错误实际上是从消息队列中异步抛出的，所有并不会阻止运行时继续执行同步指令。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常情况下</span></span><br><span class="line"><span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">consle.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// 不会执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期约中</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>); <span class="comment">// bar</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) Error: foo</span></span><br></pre></td></tr></table></figure>
<p>跟之前的 Promise.reject()示例所示，异步错误只能通过异步的 onRejected 处理程序捕获。<br>
then()和 catch()的 onRejected 处理程序在语义上相当于 try/catch。出发点都是捕获错误后将其隔离，同时不影响正常逻辑执行。为此，onRejected 处理程序的任务应该是在捕获异步错误之后返回一个解决的期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  consoel.<span class="title function_">log</span>(<span class="string">&quot;开始异步执行&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&quot;kinsiy&quot;</span>));</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误捕获: &quot;</span>, e);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;继续异步执行&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始异步执行</span></span><br><span class="line"><span class="comment">// 错误捕获:  Error: kinsiy</span></span><br><span class="line"><span class="comment">// 继续异步执行</span></span><br></pre></td></tr></table></figure>
<h2 id="期约连锁与期约合成">期约连锁与期约合成</h2>
<p>多个期约组合在一起可以构成强大的代码逻辑。这种组合可以通过两种方式实现：期约连锁与期约合成。前者是一个期约接一个期约地拼接，后者则是多个期约组合为一个期约。</p>
<h3 id="期约连锁">期约连锁</h3>
<p>把期约逐个地串联起来是一种非常有用的编程模式。之所以可以这样做，是因为每个期约实例的方法(then(),catch(),finally())都会返回一个新的期约对象，而这个新期约又有自己的实例方法。这样连缀方法就可以构成所谓的&quot;期约连锁&quot;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;初始化拒绝期约&quot;</span>);</span><br><span class="line">  <span class="title function_">reject</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拒绝处理程序&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;解决处理程序&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;最终处理程序&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化拒绝期约</span></span><br><span class="line"><span class="comment">// 拒绝处理程序</span></span><br><span class="line"><span class="comment">// 解决处理程序</span></span><br><span class="line"><span class="comment">// 最终处理程序</span></span><br></pre></td></tr></table></figure>
<h3 id="期约图">期约图</h3>
<p>因为一个期约可以有任意多个处理程序，所以期约连锁可以构建有向非循环图的结构。这样每个期约都是图中的一个节点，而使用实例方法添加的处理处理程序则是有向顶点。因为图中的每个节点都会等待前一个节点落定，所以图的方向就是期约的解决或拒绝顺序</p>
<h3 id="Promise-all-和-Promise-race">Promise.all()和 Promise.race()</h3>
<p>Promise 类提供两个将多个期约实例组合成一个期约的静态方法：Promise.all()和 Promise.race()。而合成后期约的行为取决于内部期约的行为。</p>
<h4 id="Promise-all">Promise.all</h4>
<p>Promise.all()静态方法创建的期约会在一组期约全部解决之后再解决。这个静态方法接收一个可迭代对象，返回一个新期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合成的期约只会在每个包含的期约都解决之后才解决</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(), <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>))]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(2)&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果所有期约都成功解决，则合成期约的解决值就是包含期约解决值得数组。<br>
如果有期约拒绝，则第一个拒绝的期约会将自己的理由作为合成期约的拒绝理由。之后在拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。合成的期约会静默处理所有包含期约的拒绝操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序</span></span><br><span class="line"><span class="comment">// 第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-race">Promise.race()</h4>
<p>Promise.race()静态方法返回一个包装期约，是一组集合中最先解决或拒绝的期约的镜像。这个方法接收一个可迭代对象，返回一个新期约。Promise.race()不会对解决或拒绝的期约区别对待。无论是解决还是拒绝，只要是第一个落定的，Promise.race()就会包装其解决值或拒绝理由并返回新期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决先发生，超时的拒绝被忽略</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">6</span>), <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, p)); <span class="comment">// Promise &#123;&lt;fulfilled&gt;: 6&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果有一个期约拒绝，只要它是第一个落定的，就会成为拒绝合成期约的理由。之后在拒绝的期约不会影响最终期约的拒绝理由。不过，这并不影响所有包含期约正常的拒绝操作。与 Promise.all()类似，合成的期约会静默处理所有包含期约的拒绝操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虽然只有第一个期约的拒绝理由会进入拒绝处理程序</span></span><br><span class="line"><span class="comment">// 第二个期约的拒绝也会被静默处理，不会有错误跑掉</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">4</span>), <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject, <span class="number">1000</span>))]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">reason</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="variable language_">console</span>.<span class="property">log</span>, <span class="number">0</span>, reason)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有未处理的错误</span></span><br></pre></td></tr></table></figure>
<h3 id="串行期约合成">串行期约合成</h3>
<p>期约的另一个主要特性：异步产生值并将其传给处理程序。基于后续期约使用之前期约的返回值来串联期约是期约的基本功能。这很像函数合成，即将多个函数合成为一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">x</span>) =&gt;</span> fns.<span class="title function_">reduce</span>(<span class="function">(<span class="params">promise, fn</span>) =&gt;</span> promise.<span class="title function_">then</span>(fn), <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTen = <span class="title function_">compose</span>(addTwo, addThree, addFive);</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Proxy[代理基础]</title>
    <url>/Javascript-Proxy-1/</url>
    <content><![CDATA[<h2 id="代理基础">代理基础</h2>
<p>代理是目标对象的抽象。从很多方面看，代理类似 C++指针，因为它可以用作目标对象的替身，但又完全独立于目标对象。目标对象即可以直接被操作，也可以通过代理来操作。</p>
<h3 id="创建空代理">创建空代理</h3>
<p>代理是使用 Proxy 构造函数来创建的。这个构造函数接收两个参数：目标对象和处理程序对象、缺少其中任何一个参数都会抛出 TypeError。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// id属性会访问同一个值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`target: <span class="subst">$&#123;target.id&#125;</span> proxy: <span class="subst">$&#123;proxy.id&#125;</span>`</span>); <span class="comment">// target: Kinsiy proxy: Kinsiy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给目标及代理属性赋值会反映在两个对象上</span></span><br><span class="line">target.<span class="property">key</span> = <span class="string">&quot;King&quot;</span>;</span><br><span class="line">proxy.<span class="property">value</span> = <span class="string">&quot;Queen&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">value</span>); <span class="comment">// Queen</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">key</span>); <span class="comment">// King</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hasOwnProperty()方法在两个地方</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;id&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy.prototype 是undefined 不能使用instanceof</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy <span class="keyword">instanceof</span> <span class="title class_">Proxy</span>); <span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格相等可以用来区分代理和目标</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === target); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="定义捕获器">定义捕获器</h3>
<p>使用代理的主要目的是可以定义捕获器(trap)。捕获器就是在处理程序对象中定义的“基本操作的拦截器”。每个处理程序可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接或间接在代理对象上调用。每次在捕获器上调用这些基本操作时，代理可以在这些操作传播到目标对象之前先调用捕获器函数，从而拦截并修改相应的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">language</span>: <span class="string">&quot;Javascript&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;handler override&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">language</span>); <span class="comment">// handler override</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">language</span>); <span class="comment">// Javascript</span></span><br></pre></td></tr></table></figure>
<p>上面定义的 get()捕获器不是 ECMAScript 对象可以调用的方法。这个操作在 Javascript 代码中可以通过多种形式触发并被 get()捕获器拦截到。proxy[prototype]、proxy.property 或 Object.create(proxy)[property]等操作都会触发基本的 get()操作以获取属性。</p>
<h3 id="捕获器参数和反射-API">捕获器参数和反射 API</h3>
<p>所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如 get()捕获器会接收到目标对象、要查询的属性和代理对象三个参数。<br>
所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像 get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，开发者不需要手动重建原始行为，而是可以通过调用全局 Reflect 对象上(封装了原始行为)的同名方法来轻松重建。<br>
处理程序对象中所有可以捕获的方法都有对应的反射(Reflect)API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有被拦截方法相同的行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">info</span>: <span class="string">&quot;man never cay!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">trapTarget, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> decoration = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&quot;id&quot;</span>) &#123;</span><br><span class="line">      decoration = <span class="string">&quot; may cry!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + decoration;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// Kinsiy may cry!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">info</span>); <span class="comment">// man never cay!</span></span><br></pre></td></tr></table></figure>
<h3 id="捕获器不变式">捕获器不变式</h3>
<p>使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据 ECMAScript 规范，每个捕获的方法都知道目标对象上下文，捕获函数签名，而捕获处理程序的行为必须遵守&quot;捕获器不变式&quot;(trap invariant)。捕获器不变式因方法不同而异，但通常都会防止捕获器定义出现过于反常的行为。比如，如果目标对象有一个<b>不可配置且不可写</b>的数据属性，那么在捕获器返回一个<b>与该属性不同的值</b>时，会抛出 TypeError。</p>
<h3 id="可撤销代理">可撤销代理</h3>
<p>有时候可能需要中断代理对象与目标对象之间的联系。对于 new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。<br>
Proxy 也暴露了 revocable()方法，这个方法支持撤销代理对象与目标对象之间的关联。撤销代理的操作是不可逆的。而且，撤销函数(revoke())是幂等的，调用多少次的结果都是一样的。撤销代理之后再调用代理会抛出 TypeError。<br>
撤销函数和代理对象是在实例化时同时生成的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&quot;king&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Queen&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="title class_">Proxy</span>.<span class="title function_">revocable</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="property">id</span>); <span class="comment">// king</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// Queen</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">revoke</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure>
<h3 id="实用反射-API">实用反射 API</h3>
<h4 id="反射-API-与对象-API">反射 API 与对象 API</h4>
<ol>
<li>反射 API 并不限于捕获处理程序</li>
<li>大多数反射 API 方法在 Object 类型上有对应的方法</li>
</ol>
<p>通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作</p>
<h4 id="标记状态">标记状态</h4>
<p>很多反射方法返回称作&quot;状态标记&quot;的布尔值，表示意图执行的操作是否成功。有时候，状态标记比那些返回修改后的对象或者抛出错误(取决于方法)的反射 API 更有用。以下反射方法都会提供状态标记</p>
<ul>
<li>Reflect.defineProperty()</li>
<li>Reflect.preventExtensions()</li>
<li>Reflect.setPrototypeOf()</li>
<li>Reflect.set()</li>
<li>Reflect.deleteProperty()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;id&quot;</span>, <span class="string">&quot;King&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&quot;age&quot;</span>, &#123; <span class="attr">value</span>: <span class="number">23</span> &#125;)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用一等函数替代操作符">用一等函数替代操作符</h4>
<p>以下方法提供只有通过操作符才能完成的操作</p>
<ul>
<li>Reflect.get(): 可以替代对象属性访问的操作符</li>
<li>Reflect.set(): 可以替代 = 赋值操作符</li>
<li>Reflect.has(): 可以替代 in 操作符或 with()</li>
<li>Reflect.deleteProperty(): 可以替代 delete 操作符</li>
<li>Reflect.construct(): 可以替代 new 操作符</li>
</ul>
<h4 id="安全地应用函数">安全地应用函数</h4>
<p>在通过 apply()方法调用函数时，被调用的函数可能也定义自己的 apply 属性(虽然可能性极小)。为绕过这个问题，可以使用定义在 Function 原型上的 apply 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="title function_">call</span>(myFunc, thisVal, argumentList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种可拍的代码完全可以使用Reflect.apply来避免</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(myFunc, thisVal, argumentList);</span><br></pre></td></tr></table></figure>
<h3 id="代理另一个代理">代理另一个代理</h3>
<p>代理可以拦截反射 API 的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这样就可以在一个目标对象之上构建多层拦截网</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;first proxy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + <span class="string">&quot; first&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secondProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(firstProxy, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;second proxy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>) + <span class="string">&quot; second.&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondProxy.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// second proxy</span></span><br><span class="line"><span class="comment">// first proxy</span></span><br><span class="line"><span class="comment">// Kinsiy first second.</span></span><br></pre></td></tr></table></figure>
<h3 id="代理的问题与不足">代理的问题与不足</h3>
<p>代理是 ECMAScript 现有基础之上构建起来的一套新 API，因此其实已经尽力做到最好了。很大程度上，代理作为对象的虚拟层可以正常使用。但在某些情况下，代理也不能与现在的 ECMAScript 机制很好地协作。</p>
<h4 id="代理中的-this">代理中的 this</h4>
<p>代理潜在的一个问题来源是 this 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="title function_">thisValEqualsProxys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> === proxy;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targer, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target.<span class="title function_">thisValEqualsProxys</span>()); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="title function_">thisValEqualsProxys</span>()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>调用代理上的任何方法，比如 proxy.outerMethod()，而这个方法进而又会调用另一个方法，比如 this.innerMethod()，实际上都会调用 proxy.innerMethod()。多数情况下，这是符合预期的行为。可是，如果目标对象依赖于对象标识，那就可能碰到意料之外的问题</p>
<h4 id="代理与内部槽位">代理与内部槽位</h4>
<p>代理与内置引用类型(比如 Array)的实例通常可以很好地协同，但有些 ECMAScript 内置类型可能会依赖代理无法控制的机制，结果导致在代理上调用某些方法会出错。<br>
一个典型的例子就是 Date 类型。根据 ECMAScript 规范，Date 类型方法的执行依赖 this 值上的内部槽位[[NumberDate]]。代理对象上不存在这个内部槽位，而且这个内部槽位的值也不能通过普通的 get()和 set()操作访问到，于是代理拦截后本应转发给目标对象的方法会抛出 TypeError。</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Object.1[理解对象]</title>
    <url>/Javascript-Object-1/</url>
    <content><![CDATA[<h1>理解对象</h1>
<p>Object 是 ECMAScript 中最常用的类型之一。虽然 Object 的实例没有多少功能，但很适合存储和在应用程序间交换数据。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* new Object() */</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对象字面量 */</span></span><br><span class="line"><span class="keyword">let</span> people = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Meng&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">  <span class="number">5</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 存取 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="property">name</span>); <span class="comment">// Meng</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people[<span class="string">&quot;age&quot;</span>]); <span class="comment">// 24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people[propertyName]); <span class="comment">// Meng</span></span><br><span class="line"></span><br><span class="line">people[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;ZHAO&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people[<span class="string">&quot;first name&quot;</span>]); <span class="comment">// ZHAO</span></span><br></pre></td></tr></table></figure>
<h2 id="属性的类型">属性的类型</h2>
<p>ECMA-262 使用一些内部特性来描述属性的特征。这些特征是由为 Javascript 实现引擎的规范定义的。因此开发者不能在 Javascript 中直接访问这些特征。为了将某个特性标识为内部特性，规范会用两个中括号括起来，比如[[Enumerable]]。</p>
<h3 id="数据属性">数据属性</h3>
<p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4 个特征描述他们的行为。</p>
<ul>
<li>[[Configurable]]: 表示 属性是否可以通过 delete 删除并重新定义，是否可以修改他的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Writable]]: 表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个属性都是 true。</li>
<li>[[Value]]: 包含属性实际的值。这个值默认值为 undefined。</li>
</ul>
<p>要修改属性的默认特性，就必须用 Object.defineProperty()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Kinsiy</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Queen&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// Kinsiy</span></span><br></pre></td></tr></table></figure>
<h3 id="访问器属性">访问器属性</h3>
<p>访问器属性不包含数据值。相反，它们包含一个获取(getter)函数和一个设置(setter)函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特性描述它们的行为。</p>
<ul>
<li>[[Configurable]]: 表示 属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Enumerable]]: 表示属性是否可以通过 for-in 循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是 true。</li>
<li>[[Get]]: 获取函数，在读取属性时调用。默认值为 undefined。</li>
<li>[[Set]]：设置函数，在写入属性时调用。默认值为 undefined。</li>
</ul>
<p>访问器属性是不能直接定义的，必须使用 Object.defineProperty().</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  <span class="attr">year_</span>: <span class="number">2020</span>,</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="variable language_">this</span>.<span class="property">year_</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2020</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.<span class="property">year</span> = <span class="number">2021</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">year_</span>); <span class="comment">// 2021</span></span><br></pre></td></tr></table></figure>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。</p>
<h2 id="定义多个属性">定义多个属性</h2>
<p>Object.defineProperties()。这个方法可以通过描述符一次性定义多个属性。它接收两个参数: 要为之添加或修改的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="comment">/* 只设置value，属性不可写。省缺值均为false */</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2020</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        value 和 get() 是同一个作用，只能同时用一个。</span></span><br><span class="line"><span class="comment">        writable 和 set() 是同一个作用，用一个</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2020</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue - <span class="number">2020</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.<span class="property">year</span> = <span class="number">2022</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">year_</span>); <span class="comment">// 2022</span></span><br></pre></td></tr></table></figure>
<h2 id="读取属性中的特性">读取属性中的特性</h2>
<p>使用 Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含 configurable、enumerable、get 和 set 属性，对于数据属性包含 configurable、enumerable、writable 和 value 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> descript = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year_&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descript.<span class="property">configurable</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descript.<span class="property">enumerable</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descript.<span class="property">writable</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descript.<span class="property">value</span>); <span class="comment">// 2022</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descript.<span class="property">get</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">let</span> descript_1 = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(book, <span class="string">&quot;year&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> descript_1.<span class="property">get</span>); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* getOwnPropertyDescriptors */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(book));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      year_: &#123;</span></span><br><span class="line"><span class="comment">        value: 2022,</span></span><br><span class="line"><span class="comment">        writable: true,</span></span><br><span class="line"><span class="comment">        enumerable: true,</span></span><br><span class="line"><span class="comment">        configurable: true</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      edition: &#123;</span></span><br><span class="line"><span class="comment">        value: 3,</span></span><br><span class="line"><span class="comment">        writable: true,</span></span><br><span class="line"><span class="comment">        enumerable: true,</span></span><br><span class="line"><span class="comment">        configurable: true</span></span><br><span class="line"><span class="comment">      &#125;,</span></span><br><span class="line"><span class="comment">      year: &#123;</span></span><br><span class="line"><span class="comment">        enumerable: true,</span></span><br><span class="line"><span class="comment">        configurable: true</span></span><br><span class="line"><span class="comment">        get: ƒ get()</span></span><br><span class="line"><span class="comment">        set: ƒ set(newValue)</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="合并对象">合并对象</h2>
<p>ECMAScript6 专门为合并对象提供了 Object.assign()方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举(Object.propertyIsEnumerable()返回 true)和自用(Object.hasOwnProperty()返回 true)属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的[[Get]]取得属性的值，然后谁用目标对象上的[[Set]]设置属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> desc = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Object.assign()实际上对每个源对象执行的是浅复制。</span></span><br><span class="line"><span class="comment"> *  如果多个源对象都有相同的属性，则使用最后一个复制的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">id</span>: <span class="string">&quot;K&quot;</span> &#125;, &#123; <span class="attr">id</span>: <span class="string">&quot;I&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(desc === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(desc); <span class="comment">// &#123;id: &quot;I&quot;, name: &quot;Kinsiy&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  如果赋值期间出错，则操作会中止并退出，同时抛出错误。</span></span><br><span class="line"><span class="comment"> *  Object.assign()没有&quot;回滚&quot;之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dest = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> scr = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&quot;Queen&quot;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">b</span>() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, scr);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123;a: &quot;Queen&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="对象标识及相等判定">对象标识及相等判定</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(&#123;&#125;, &#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&quot;2&quot;</span>, <span class="number">2</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  检查超过两个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recursivelyCheckEaual</span>(<span class="params">x, ...rest</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">is</span>(x, rest[<span class="number">0</span>]) &amp;&amp; (rest.<span class="property">length</span> &lt; <span class="number">2</span> || <span class="title function_">recursivelyCheckEaual</span>(...rest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增强的对象语法">增强的对象语法</h2>
<h3 id="属性值简写">属性值简写</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  age = <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`name: <span class="subst">$&#123;person.name&#125;</span>   age: <span class="subst">$&#123;person.age&#125;</span>`</span>); <span class="comment">// name: Kinsiy   age: 23</span></span><br></pre></td></tr></table></figure>
<h3 id="可计算属性">可计算属性</h3>
<p>可以在对象字面量中完成动态属性赋值。中括号包围的对象属性键告诉运行时将其作为 Javascript 表达式而不是字符串来求值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameKey = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ageKey = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> jobKey = <span class="string">&quot;job&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> uniqueToken = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getUniqueKey</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>_<span class="subst">$&#123;uniqueToken++&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(nameKey)]: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(ageKey)]: <span class="string">&quot;23&quot;</span>,</span><br><span class="line">  [<span class="title function_">getUniqueKey</span>(jobKey)]: <span class="string">&quot;Software engineer&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name_0: &quot;Kinsiy&quot;, age_1: &quot;23&quot;, job_2: &quot;Software engineer&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="简写方法名">简写方法名</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayName</span>(); <span class="comment">// Kinsiy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  与可计算属性键相互兼容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> methodKey = <span class="string">&quot;sayAge&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> person_2 = &#123;</span><br><span class="line">  [methodKey](age) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person_2.<span class="title function_">sayAge</span>(<span class="string">&quot;23&quot;</span>); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>
<h2 id="对象解构">对象解构</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: myName, age, job = <span class="string">&quot;Software engineer&quot;</span> &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myName); <span class="comment">// Kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 23</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(job); <span class="comment">// Software engineer</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  事先声明变量时</span></span><br><span class="line"><span class="comment"> *  赋值表达式必须包含在一对括号中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">OtherName</span>, newAge;</span><br><span class="line">(&#123; <span class="attr">name</span>: <span class="title class_">OtherName</span>, <span class="attr">age</span>: newAge &#125; = person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">OtherName</span>); <span class="comment">// Kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newAge); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>
<h3 id="嵌套解构">嵌套解构</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">  <span class="attr">job</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;Software engineer&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> otherPerson = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">name</span>: otherPerson.<span class="property">name</span>, <span class="attr">age</span>: otherPerson.<span class="property">age</span>, <span class="attr">job</span>: otherPerson.<span class="property">job</span> &#125; = person);</span><br><span class="line">person.<span class="property">job</span>.<span class="property">title</span> = <span class="string">&quot;Hacker&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherPerson); <span class="comment">// &#123;name: &quot;Kinsiy&quot;, age: 23, job: &#123;Hacker&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;name: &quot;Kinsiy&quot;, age: 23, job: &#123;Hacker&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">job</span>: &#123; <span class="attr">title</span>: newTitle &#125;,</span><br><span class="line">&#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newTitle); <span class="comment">// Hacker</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在外层属性没有定义的情况下不能使用嵌套解构。无论对象还是目标对象都是一样</span></span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;;</span><br><span class="line"><span class="comment">// foo在源对象上是undefined</span></span><br><span class="line">(&#123;<span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personCopy.<span class="property">bar</span> &#125;&#125; = person); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;bar&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// job在目标对象上是undefined</span></span><br><span class="line">(&#123;<span class="attr">job</span>: &#123; <span class="attr">titilt</span>: personCopy.<span class="property">job</span>.<span class="property">title</span> &#125;&#125; = person); <span class="comment">// Uncaught TypeError: Cannot set property &#x27;title&#x27; of undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="部分解构">部分解构</h3>
<p>涉及多个属性的解构赋值时一个输出无关非顺序化操作。如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name, bar, age;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  (&#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">job</span>: &#123; <span class="attr">bar</span>: bar &#125;,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">  &#125; = person);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, bar, age); <span class="comment">// Kinsiy undefined undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="参数上下文匹配">参数上下文匹配</h3>
<p>在函数参数列表也可以进行解构赋值。对参数的解构赋值不会影响 arguments 对象，但可以在函数签名中声明函数体内使用局部变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPersonInfo</span>(<span class="params">foo, &#123; name, age &#125;, bar</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getPersonInfo</span>(<span class="string">&quot;1st&quot;</span>, person, <span class="string">&quot;2st&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;1st&quot;, &#123;name: &quot;Kinsiy&quot;, age: 23&#125;, &quot;2st&quot;]</span></span><br><span class="line"><span class="comment">// Kinsiy 23</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Object.2[创建对象]</title>
    <url>/Javascript-Object-2/</url>
    <content><![CDATA[<h1>概述</h1>
<p>ECMAscript 5.1 并没有正式支持面向对象的结构，比如类或继承。ECMAscript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模式。不过，无论从那个方面看，ES6 的类都仅仅是封装了 ES5.1 构造函数加原型链继承的语法糖而已。</p>
<span id="more"></span>
<h1>工厂模式</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o.<span class="property">name</span> = name;</span><br><span class="line">  o.<span class="property">age</span> = age;</span><br><span class="line">  o.<span class="property">job</span> = job;</span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">23</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式解决创建多个类似对象的问题，但没有解决对象标识问题(即创建的对象是什么类型)。</p>
<h1>构造函数模式</h1>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 按照惯例，构造函数名称的首字母是要大写的，非构造函数则以小写字母开头 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用函数表达式亦可 let Person = function()&#123; ... &#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">Name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">23</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true     所有自定义对象都继承自Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">sayName</span> == person_2.<span class="property">sayName</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>实际上，Person()内部的代码跟 createPerson()基本是一样的，只是有如下区别</p>
<ul>
<li>没有显式的创建对象</li>
<li>属性和方法直接赋值给了 this</li>
<li>没有 return</li>
</ul>
<p>要创建 Person 的实例，应使用 new 操作符。以这种方式调用构造函数会执行如下操作</p>
<ul>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的[[Prototype]] 特性被赋值为构造函数的 prototype 属性</li>
<li>构造函数内部的 this 被赋值为这个新对象(即 this 指向新对象)</li>
<li>执行构造函数内部的代码(给新对象添加属性)</li>
<li>如果构造函数返回非空对象，则返回该对象；返回刚创建的新对象</li>
</ul>
<h2 id="构造函数也是函数">构造函数也是函数</h2>
<p>构造函数与普通函数唯一的区别就是调用方式不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为构造函数</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">23</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line">person.<span class="title function_">sayName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为函数调用</span></span><br><span class="line"><span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>); <span class="comment">// 添加到window对象</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(o, <span class="string">&quot;Type&quot;</span>, <span class="number">20</span>, <span class="string">&quot;Nurse&quot;</span>);</span><br><span class="line">o.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>
<h2 id="构造函数的问题">构造函数的问题</h2>
<p>构造函数定义的方法会在每个实例上都创建一遍。对前面的例子而言，person_1 和 person_2 都有 sayName()的方法，但这两个方法不是同一个 Function 实例。逻辑上讲，这个构造函数实际上是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用函数表达式亦可 let Person = function()&#123; ... &#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;console.log(this.name)&quot;</span>); <span class="comment">// 逻辑等价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此不同实例上的函数虽然同名却不相等。因为都是做一样的事，所以没必要定义两个不同的 Function 实例。况且，this 对象可以把函数与对象的绑定推迟到运行时。要解决这个问题，可以吧函数定义转移到构造函数外部：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用函数表达式亦可 let Person = function()&#123; ... &#125;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kinsiy&quot;</span>, <span class="number">23</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">person_1.<span class="title function_">sayName</span>(); <span class="comment">// Kissiy</span></span><br><span class="line">person_2.<span class="title function_">sayName</span>(); <span class="comment">// Greg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">sayName</span> == person_2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1>原型模式</h1>
<p>每个函数都会创建一个 prototype 属性，这个属性时一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上这个对象就是通过调用构造函数创建的对象的原型。使用原型的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给他们的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">24</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">jonb</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person_1.<span class="title function_">sayName</span>(); <span class="comment">// Kinsiy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person_2.<span class="title function_">sayName</span>(); <span class="comment">// Kinsiy</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">sayName</span> == person_2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="理解原型">理解原型</h2>
<p>无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性(指向原型对象)。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。对前面的例子而言，Person.prototype.constructor 指向 Person。<br>
在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露<strong>proto</strong>属性，通过这个属性可以访问对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//      constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">//      __proto__: Object&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的原型链都会终止与Object的原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例通过__proto__链接到原型对象，</span></span><br><span class="line"><span class="comment"> * 它实际上指向隐藏特性[[Prototype]]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造函数通过prototype 属性链接到原型对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实例与构造函数没有直接联系，与原型对象有直接联系</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">__proto__</span>.<span class="property">constructor</span> === <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>可以使用 isPrototypeOf()方法确定两个对象之间的[[Prototype]]关系。本质上 isPrototypeOf()会在传入参数的[[Prototype]]指向调用它的对象室返回 true。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(person_1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ECMAScript 的Object类型有一个方法叫Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person_1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object类型还有一个setPrototyprOf()方法，可以向实例的[[Prototype]]写入一个新值。这样可以重写一个对象的原型继承关系 */</span></span><br><span class="line"><span class="keyword">let</span> object_1 = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;kinsiy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(person_2, object_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_2.<span class="property">num</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person_2) === object_1); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object.setPrototyprOf()可能会严重影响代码性能，可以通过Object.create()来创建一个新对象，同时指定为原型 */</span></span><br><span class="line"><span class="keyword">let</span> object_2 = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(object_2);</span><br><span class="line">person_3.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_3.<span class="property">num</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person_3) === object_2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="原型层级">原型层级</h2>
<p>在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。<br>
虽然可以通过实例原型读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮蔽原型对象上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person_1.<span class="property">name</span> = <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">name</span>); <span class="comment">// &quot;Restituo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_2.<span class="property">name</span>); <span class="comment">// &quot;Kinsiy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// hasOwnProperty() 方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// delete 操作符</span></span><br><span class="line"><span class="keyword">delete</span> person_1.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">name</span>); <span class="comment">// &quot;Kinsiy&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_2.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>只要给对象实例添加了一个属性，这个属性就会遮蔽(shadow)原型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为 null，也不会恢复它和原型的联系。不过使用 delete 操作符可以完全删除实例上的这个属性，从而让标识符解释过程能够继续搜索原型对象。<br>
hasOwnProperty()方法用于确定某个属性在实例上还是在原型对象上。这个方法是继承自 Object 的，会在属性存在于调用他的对象实例上时返回 true。</p>
<h2 id="原型和-in-操作符">原型和 in 操作符</h2>
<p>有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在可以通过对象访问指定属性时放回 true，无论该属性是在实例上还是在原型上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 检查属性是否在原型上未被遮蔽</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">object</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; <span class="variable">name</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125; <span class="variable">boolean</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototyProperty</span>(<span class="params">object, name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; name <span class="keyword">in</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototyProperty</span>(person_1, <span class="string">&quot;name&quot;</span>));      <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasPrototyProperty</span>(person_2, <span class="string">&quot;name&quot;</span>));      <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举([[Enumerable]]特性被设置为 false)属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可以枚举的。<br>
要获取对象上所有可枚举的实例属性，可以使用 Object.keys()方法。这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组。<br>
如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person_1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);   <span class="comment">// name age job sayName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Object.keys()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys);  <span class="comment">// [&quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span></span><br><span class="line">keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(person_1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys);  <span class="comment">// [&quot;name&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Object.getOwnPropertyNames()</span></span><br><span class="line">keys = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(keys);  <span class="comment">//  [&quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;job&quot;, &quot;sayName&quot;]</span></span><br></pre></td></tr></table></figure>
<p>在 ECMAscript 6 新增符号类型之后，相应的出现了一个 Object.getOwnPropertyNames()的兄弟方法的需求，因为以符号为键的属性没有名称的概念。因此，Object.getOwnPropertySymbols()方法就出现了，这个方法与 Object.getOwnPropertyNames()类似，只是针对符号而已。</p>
<h2 id="属性枚举顺序">属性枚举顺序</h2>
<p>for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assgin()在属性枚举顺序方面有很大区别。for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 Javascript 引擎，可能因浏览器而异。<br>
Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及 Object.assgin()的枚举顺序是确定的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> k1 = <span class="title class_">Symbol</span>(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> k2 = <span class="title class_">Symbol</span>(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">first</span>: <span class="string">&quot;first&quot;</span>,</span><br><span class="line">  [k1]: <span class="string">&quot;sym1&quot;</span>,</span><br><span class="line">  <span class="attr">second</span>: <span class="string">&quot;second&quot;</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line">o[k2] = <span class="string">&quot;sym2&quot;</span>;</span><br><span class="line">o[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">o.<span class="property">third</span> = <span class="string">&quot;third&quot;</span>;</span><br><span class="line">o[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o)); <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;first&quot;, &quot;second&quot;, &quot;third&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); <span class="comment">// [Symbol(k1), Symbol(k2)]</span></span><br></pre></td></tr></table></figure>
<h1>对象迭代</h1>
<p>在 Javascript 有史以来的大部分时间内，迭代对象属性都是一个难题。ECMAscript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法 Object.values()和 Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值得数组，Object.entries()方法返回键/值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">qux</span>: &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(o)); <span class="comment">// [&quot;bar&quot;, 1, &#123;…&#125;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(o)); <span class="comment">// [[&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 1], [&quot;qux&quot;, &#123;…&#125;]]</span></span><br></pre></td></tr></table></figure>
<p>注意，非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制。符号属性会被忽略。</p>
<h2 id="其他原型语法">其他原型语法</h2>
<p>在前面的例子中，每次定义一个属性或方法都会把 Person.prototype 重写一遍。为了减少代码冗余，也为了从视觉上更好的封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这样重写之后，Person.property的constructor属性就不指向Person了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">constructor</span> == <span class="title class_">Person</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">constructor</span> == <span class="title class_">Object</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果constructor的值很重要，则可以在重写原型对象时专门设置一下它的值</span></span><br><span class="line"><span class="comment">* Person.prototype = &#123;</span></span><br><span class="line"><span class="comment">*    constructor: Person,</span></span><br><span class="line"><span class="comment">*    name: &quot;Kinsiy&quot;,</span></span><br><span class="line"><span class="comment">*    age: 23,</span></span><br><span class="line"><span class="comment">*    sayName()&#123;</span></span><br><span class="line"><span class="comment">*        console.log(this.name);</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">* &#125;</span></span><br><span class="line"><span class="comment">* 但要注意，以这种方式恢复的constructor属性会创建一个[[Enumerable]]为true的属性。而原生constructor属性默认是不可枚举的</span></span><br><span class="line"><span class="comment">* 可以改为使用Object.defineProperty()方法来定义constructor 属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="params">Person.property,<span class="string">&quot;contructor&quot;</span></span>)&#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="原型的动态性">原型的动态性</h2>
<p>因为从原型上搜索值得过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person_1.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>这与重写这个原型是两回事。实例的[[prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person_1.<span class="title function_">sayHi</span>(); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h2 id="原生对象原型">原生对象原型</h2>
<p>所有原生引用类型的构造函数(包括 Object、Array、String 等)都在原型上定义了实例方法。比如，数组实例的 sort 方法就是 Array.prototype 上定义的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">Kinsiy</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">str.<span class="title class_">Kinsiy</span>();</span><br></pre></td></tr></table></figure>
<h2 id="原型的问题">原型的问题</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">friends</span> = [<span class="string">&quot;Kinsiy&quot;</span>, <span class="string">&quot;Restituo&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person_1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">let</span> person_2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">person_1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Type57&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_1.<span class="property">friends</span>); <span class="comment">// [&quot;Kinsiy&quot;, &quot;Restituo&quot;, &quot;Type57&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person_2.<span class="property">friends</span>); <span class="comment">// [&quot;Kinsiy&quot;, &quot;Restituo&quot;, &quot;Type57&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Object</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Proxy[代理模式]</title>
    <url>/Javascript-Proxy-3/</url>
    <content><![CDATA[<h2 id="代理模式">代理模式</h2>
<p>使用代理可以在代码中实现一些有用的编程模式</p>
<h3 id="跟踪属性访问">跟踪属性访问</h3>
<p>通过捕获 get、set 和 has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放在应用中，可以监控这个对象何时在何处被访问过。</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(user, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;property&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;property&#125;</span> = <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">23</span>; <span class="comment">// Setting age = 23</span></span><br></pre></td></tr></table></figure>
<h3 id="隐藏属性">隐藏属性</h3>
<p>代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hiddenProperties = [<span class="string">&quot;King&quot;</span>, <span class="string">&quot;Queen&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> targetObject = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kinsiy&quot;</span>,</span><br><span class="line">  <span class="title class_">King</span>: <span class="string">&quot;青睐&quot;</span>,</span><br><span class="line">  <span class="title class_">Queen</span>: <span class="string">&quot;Restituo&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(targetObject, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hiddenProperties.<span class="title function_">includes</span>(property)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">name</span>); <span class="comment">// Kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">King</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">Queen</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// has</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;King&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Queen&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="属性验证">属性验证</h3>
<p>因为所有属性操作都会触发 set()捕获器，所以可以根据所赋的值决定是允许还是拒绝</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">onlyNumbersGoHere</span>: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br><span class="line">proxy.<span class="property">onlyNumbersGoHere</span> = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">onlyNumbersGoHere</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="函数与构造函数参数验证">函数与构造函数参数验证</h3>
<p>跟保护和验证对象属性类似，也可以对函数和构造函数参数进行审查。比如，可以让函数只接收某种类型的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">median</span>(<span class="params">...nums</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">sort</span>()[<span class="title class_">Math</span>.<span class="title function_">floor</span>(nums.<span class="property">length</span> / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(median, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> arg <span class="keyword">of</span> argumentsList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;参数中存在非数字！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="string">&quot;5&quot;</span>)); <span class="comment">// Error: 参数中存在非数字！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似地，可以要求实例化时必须给构造函数传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Uesr</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_id</span> = id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (argumentsList[<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;用户类必须提供id&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construc</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(); <span class="comment">// Error: 用户类必须提供id</span></span><br></pre></td></tr></table></figure>
<h3 id="数据绑定与可观察对象">数据绑定与可观察对象</h3>
<p>通过代理可以把运行时原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同代码互操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userList = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy_1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(userList, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; property !== <span class="string">&quot;length&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里控制一下新增元素后，数组长度变化的消息无需发送</span></span><br><span class="line">      <span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, property, receiver));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(<span class="title class_">User</span>, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newUser = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    proxy_1.<span class="title function_">push</span>(newUser); <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="keyword">return</span> newUser;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;King&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="string">&quot;Queen&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// User &#123;name: &quot;Kinsiy&quot;&#125;</span></span><br><span class="line"><span class="comment">// User &#123;name: &quot;King&quot;&#125;</span></span><br><span class="line"><span class="comment">// User &#123;name: &quot;Queen&quot;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userList); <span class="comment">// [User, User, User]</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-RegExp</title>
    <url>/Javascript-RegExp/</url>
    <content><![CDATA[<h2 id="RegExp">RegExp</h2>
<p>ECMAscript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>afgls;</span><br></pre></td></tr></table></figure>
<p>这个正则表达式的 pattern(模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、先前查找和反向查找和反向引用、每个正则表达式可以带零个或多个 flags(标记)、用于控制正则表达式的行为。下面给出了表示匹配模式的标记。</p>
<span id="more"></span>
<ul>
<li>g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束</li>
<li>i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写</li>
<li>m：多行模式，表示查到一行文本末尾时会继续查找</li>
<li>y：粘贴模式，表示只查找从 lastIndex 开始及之后的字符串</li>
<li>u：Unicode 模式，启用 Unicode 匹配</li>
<li>s：dotAll 模式，表示元字符。匹配任何字符(包括\n 或\r)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 匹配 ( [ &#123; \ ^ | &#125; ] ) ? * = . 需要使用(\)转义 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用字面量形式定义 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>; <span class="comment">// 匹配字符串中的所有&quot;at&quot;</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>; <span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;,忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/\.at/gi</span>; <span class="comment">// 匹配所有以&quot;.at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用RegExp构造函数定义 </span></span><br><span class="line"><span class="comment">    RegExp构造函数接受两个参数：模式字符串和标记字符串(可选)</span></span><br><span class="line"><span class="comment">    因为RegExp的模式参数是字符串，所以在某些情况下需要二次转义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\.at&quot;</span>, <span class="string">&quot;gi&quot;</span>); <span class="comment">// 与pattern3等价</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern5 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(pattern2, <span class="string">&quot;gi&quot;</span>); <span class="comment">// 基于已有的正则表达式实例，可以选择性的修改它们的标记</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern5); <span class="comment">// /[bc]at/gi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 无论正则表达式是怎么创建的，继承的方法toLocalString() 和toString() 都返回正则表达式的字面量表示 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(patter4.<span class="title function_">toLocalString</span>()); <span class="comment">// /\.at/gi</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(patter4.<span class="title function_">toString</span>()); <span class="comment">// /\.at/gi</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp-实例属性">RegExp 实例属性</h3>
<ul>
<li>global: 布尔值，表示是否设置了 g 标记</li>
<li>ignoreCase: 布尔值，表示是否设置了 i 标记</li>
<li>unicode: 布尔值，表示是否设置了 u 标记</li>
<li>sticky: 布尔值，表示是否设置了 y 标记</li>
<li>lastIndex: 整数，表示在源自符串中下一次搜索的开始位置，始终从 0 开始</li>
<li>multiline: 布尔值，表示是否设置了 m 标记</li>
<li>dotAll: 布尔值，表示是否设置了 s 标记</li>
<li>source：正则表达式的字面量字符串(不是传给构造函数的模式字符串)，没有开头和结尾的斜杠</li>
<li>flags: 正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回(没有前后斜杠)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">global</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">ignoreCase</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">unicode</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">sticky</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">multiline</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">dotAll</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">source</span>); <span class="comment">// \[bc\]at</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">flags</span>); <span class="comment">// i</span></span><br></pre></td></tr></table></figure>
<h3 id="RegExp-实例方法">RegExp 实例方法</h3>
<h4 id="exec">exec()</h4>
<p>RegExp 实例的主要方法是 exec(),主要用于配合捕获组使用。这个方法只接受一个参数，即要应用的模式字符串。如果找到了匹配项。则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回 null。返回的数组虽然是 Array 的实例，但包含两个额外的属性：index 和 input。index 是字符串中匹配模式的起始位置，input 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and bady&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and bady)?)?/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">input</span>); <span class="comment">// mom and dad and baby</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// mom and dad and baby</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">1</span>]); <span class="comment">// and dad and baby</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">2</span>]); <span class="comment">// and bady</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果模式设置了全局模式，则每次调用exec()方法会返回一个匹配的信息。直至搜索到字符串的末尾，此时返回null</span></span><br><span class="line"><span class="comment">    反之，则无论对同一字符串调用了多少次exec(), 也只返回第一个匹配的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;cat, bat, sat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern_2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> matches_2 = pattern_2.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">index</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2[<span class="number">0</span>]); <span class="comment">// cat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">lastIndex</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">matches_2 = pattern_2.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">index</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2[<span class="number">0</span>]); <span class="comment">// bat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">lastIndex</span>); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">matches_2 = pattern_2.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">index</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2[<span class="number">0</span>]); <span class="comment">// sat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2.<span class="property">lastIndex</span>); <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line">matches_2 = pattern_2.<span class="title function_">exec</span>(string);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches_2); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<h4 id="test">test()</h4>
<p>正则表达式的另一个方法是 test(),接收一个字符串参数。如果输入的文本与模式匹配，则参数返回 true，反之返回 false。这个方法适用于只想测试模式是否匹配，而不需要实际匹配内容的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;000-00-0000&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pattern.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;匹配成功！&quot;</span>); <span class="comment">// 匹配成功！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RegExp-构造函数属性">RegExp 构造函数属性</h3>
<p>RegExp 构造函数本身也有几个属性。这些属性适用于作用域中的所有正则表达式，而且会根据最后执行的正则表达式操作而变化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">全名</th>
<th style="text-align:center">简写</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">input</td>
<td style="text-align:center">$_</td>
<td style="text-align:center">最后搜索的字符串</td>
</tr>
<tr>
<td style="text-align:center">lastMatch</td>
<td style="text-align:center">$&amp;</td>
<td style="text-align:center">最后匹配的字符串</td>
</tr>
<tr>
<td style="text-align:center">lastParen</td>
<td style="text-align:center">$+</td>
<td style="text-align:center">最后的捕获组</td>
</tr>
<tr>
<td style="text-align:center">leftContext</td>
<td style="text-align:center">$`</td>
<td style="text-align:center">input 字符串中出现在 lastMatch 前面的文本</td>
</tr>
<tr>
<td style="text-align:center">rightContext</td>
<td style="text-align:center">$’</td>
<td style="text-align:center">input 字符串中出现在 lastMach 后面的文本</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;this has been a short winter&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern_1 = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">let</span> pattern_2 = <span class="regexp">/(..)win/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches_1 = pattern_2.<span class="title function_">exec</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">input</span>); <span class="comment">// this has been a short winter</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">lastMatch</span>); <span class="comment">// t win</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$+&quot;</span>]); <span class="comment">// t (t后边有一个空格)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$`&quot;</span>]); <span class="comment">// this has been a shor</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&#x27;&quot;</span>]); <span class="comment">// ter</span></span><br><span class="line"></span><br><span class="line">pattern_1.<span class="title function_">test</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$&amp;&quot;</span>]); <span class="comment">// short</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property">$1</span>); <span class="comment">// sh</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>[<span class="string">&quot;$2&quot;</span>]); <span class="comment">// t</span></span><br></pre></td></tr></table></figure>
<h3 id="模式局限">模式局限</h3>
<p>下列特性目前还没有得到 EMCAScript 的支持</p>
<ul>
<li>\A 和\Z 锚(分别匹配字符串的开始和结尾)</li>
<li>联合及交叉类</li>
<li>原子组</li>
<li>x(忽略空格)匹配模式</li>
<li>条件式匹配</li>
<li>正则表达式注释</li>
</ul>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-String</title>
    <url>/Javascript-String/</url>
    <content><![CDATA[<h2 id="基本引用类型-原始包装类型">基本引用类型(原始包装类型)</h2>
<p>为了方便操作原始值，EMCAScript 提供了 3 种特殊的引用类型：Boolean、Number 和 String。这些类型具有与其他引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。每当用到某个原始值的方法或属性时，后台都会创建一个相应包装类型的对象，从而暴露出操作原始值得各种方法。<br>
在以读模式访问字符串值得时候，后台都会执行一下三步：</p>
<ul>
<li>创建一个 String 类型的实例</li>
<li>调用实例上的特定方法</li>
<li>销毁实例</li>
</ul>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 可以想象成 */</span></span><br><span class="line"><span class="keyword">let</span> s1_ = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2_ = <span class="keyword">new</span> <span class="title class_">String</span>(s1_).<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s_ = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上三步也会在后台发生，只不过使用的是 Boolean 和 Number 包装类型而已。<br>
引用类型与原始值包装类型的主要区别在于对象的生命周期。在通过 new 实例化引用类型后，得到的实例会在离开作用域是被销毁，而自动创建的原始值包装对象则只存在于访问它执行期间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">color</span>); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Object作为一个工厂方法，能够根据传入值得类型返回相应原始值包装类型的实例 */</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用new调用原始值包装类型的构造函数，与调用同名的转型函数并不一样 */</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> number = <span class="title class_">Number</span>(value);</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<h3 id="Boolean">Boolean</h3>
<p>建议永远不要使用 Boolean 对象<br>
Boolean 的实例会重写 valueof()方法，返回一个原始值 true 或 false。toString()方法在被调用时也会被覆盖，返回字符串&quot;true&quot;或&quot;false&quot;。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseObject); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseValue); <span class="comment">// Boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseObject <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseValue <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="Number">Number</h3>
<p>与 Boolean 类型一样，Number 类型重写了 valueof()、toLocaleString()和 toString()方法。valueof()方法返回对象表示的原始数值，另外两个方法返回数值字符串。toString()方法可选地接收一个表示基数的参数，并返回相应技术形式的数值字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// 1010</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)); <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* toFixed()方法返回包含指定小数点位数的数值字符串 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 10.00</span></span><br><span class="line">num = <span class="number">10.008</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toFixed</span>(<span class="number">2</span>)); <span class="comment">// 10.01        四舍五入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* toExponential(),返回以科学计数法表示的数值字符串 */</span></span><br><span class="line">num = <span class="number">88888</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toExponential</span>(<span class="number">1</span>)); <span class="comment">// 8.9e+4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* toPrecision(),根据情况返回最合理的输出结果 */</span></span><br><span class="line">num = <span class="number">88</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toPrecision</span>(<span class="number">1</span>)); <span class="comment">// 9e+1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toPrecision</span>(<span class="number">2</span>)); <span class="comment">// 88</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toPrecision</span>(<span class="number">3</span>)); <span class="comment">// 88.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上toPrecision()会根据数值和精度来决定调用toFixed()还是toExponential()。为了以正确的小数位精确表示数值，这三个方法都会向上或向下舍入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* isInteger(), 用于辨别一个数值是否保存为整数 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1.0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">1.01</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="String">String</h3>
<p>String 对象的方法可以在所有字符串原始值上调用。上个继承的方法 valueof()、toLocaleString()和 toString()都返回对象的原始字符串值。<br>
每个 String 对象都有一个 length 属性，表示字符串中字符的数量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="property">length</span>);        <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使字符串中包含双字节字符(而不是单字节的ASCII字符)，也仍然会按单字符来计数</span></span><br><span class="line"><span class="keyword">let</span> str_1 = <span class="string">&quot;这串文字的长度是⑨&quot;</span>；</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str_1.<span class="property">length</span>);              <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<h4 id="Javascript-字符">Javascript 字符</h4>
<p>Javascript 字符串有 16 位码元(code unit)组成。对多数字符来说，每 16 位码元对应一个字符。换句话说，字符串的 length 属性表示字符串包含多少 16 位码元。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* charAt()用于返回给定索引位置的字符 */</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* charCodeAt()方法可以查看指定码元的字符编码 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">//  99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fromCharCode(), 用于根据给定的UTF-16码元创建字符串中的字符。 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>, <span class="number">0x64</span>, <span class="number">0x65</span>)); <span class="comment">// abcde</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当字符编码扩展到Unicode增补平面时 */</span></span><br><span class="line"><span class="comment">/* codePointAt(), 接收16位码元的索引并返回改索引位置上的码点 */</span></span><br><span class="line">message = <span class="string">&quot;ab🤣de&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="property">length</span>); <span class="comment">// 6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">1</span>)); <span class="comment">// b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">2</span>)); <span class="comment">// &lt;?\&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">3</span>)); <span class="comment">// &lt;?\&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charAt</span>(<span class="number">4</span>)); <span class="comment">// d</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">1</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">2</span>)); <span class="comment">// 55358</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">3</span>)); <span class="comment">// 56611</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">charCodeAt</span>(<span class="number">4</span>)); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">1</span>)); <span class="comment">// 98</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">2</span>)); <span class="comment">// 129315</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">3</span>)); <span class="comment">// 56611</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">codePointAt</span>(<span class="number">4</span>)); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* fromCodePoint(), 接受任意个码点，返回对应字符拼接起来的字符串 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">55358</span>, <span class="number">56611</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab🤣de</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="title function_">fromCodePoint</span>(<span class="number">97</span>, <span class="number">98</span>, <span class="number">129315</span>, <span class="number">100</span>, <span class="number">101</span>)); <span class="comment">// ab🤣de</span></span><br></pre></td></tr></table></figure>
<h4 id="normalize">normalize()</h4>
<p>某些 Unicode 字符可以有多种编码方式。有的字符即可以通过一个 BMP 字符表示，也可以通过一个代理对表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x00c5</span>),</span><br><span class="line">  b = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x212b</span>),</span><br><span class="line">  c = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">0x0041</span>, <span class="number">0x030a</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`a: <span class="subst">$&#123;a&#125;</span> b: <span class="subst">$&#123;b&#125;</span> c: <span class="subst">$&#123;c&#125;</span>`</span>); <span class="comment">// a: Å b: Å c: Å</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === b); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a === c); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b === c); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用normalize() 规范化，使用时需要传入表示那种形式的字符串：&quot;NFD&quot;,&quot;NFC&quot;,&quot;NFKD&quot;,&quot;NFKC&quot; */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">normalize</span>(<span class="string">&quot;NFC&quot;</span>) === b.<span class="title function_">normalize</span>(<span class="string">&quot;NFC&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串操作方法">字符串操作方法</h4>
<h5 id="拼接-concat">拼接-concat()</h5>
<p>concat(), 用于将一个或多个字符串拼接成一个新字符串。常用(+)替代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = strValue.<span class="title function_">concat</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;World &quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// Hello World !</span></span><br></pre></td></tr></table></figure>
<h5 id="切片-slice-substr-substring">切片-slice(), substr(), substring()</h5>
<p>这三个方法都返回调用他们的字符串的一个字字符串，而且都接收一或两个参数。对 slice()和 substring()而言，第二个参数是提取结束的位置。对 substr()而言，第二个参数表示返回的字符串数量。任何情况下，省略第二个参数都意味着提取到字符串末尾。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// lo World!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">slice</span>(-<span class="number">3</span>)); <span class="comment">// ld!</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">slice</span>(-<span class="number">3</span>, -<span class="number">1</span>)); <span class="comment">// ld</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>)); <span class="comment">// Hel      substring(), 把所有负参数转换为0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">substr</span>(-<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// ld</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">substr</span>(-<span class="number">3</span>, -<span class="number">2</span>)); <span class="comment">// &quot;&quot;(空字符串) substr()，第二个参数若为负数，转换为0</span></span><br></pre></td></tr></table></figure>
<h5 id="定位-indexOf-lastIndexOf">定位-indexOf(), lastIndexOf()</h5>
<p>这两个方法从字符串中搜索传入的字符串，并返回位置(如果没找到，则返回-1)。两者的区别在于，indexof()方法从字符串开头开始查找子字符串，而 lastIndexOf 从字符串末尾开始查找子字符串。这两个方法都可以接收第二个参数，表示开始搜索的位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;slipped the surly bonds of earth to touch the face of God&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">indexOf</span>(<span class="string">&quot;f&quot;</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">lastindexOf</span>(<span class="string">&quot;f&quot;</span>)); <span class="comment">// 52</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> position = [];</span><br><span class="line"><span class="keyword">let</span> pos = strValue.<span class="title function_">indexOf</span>(<span class="string">&quot;f&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">  position.<span class="title function_">push</span>(pos);</span><br><span class="line">  pos = strValue.<span class="title function_">indexOf</span>(<span class="string">&quot;f&quot;</span>, ++pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(position); <span class="comment">// [25,46,52]</span></span><br></pre></td></tr></table></figure>
<h5 id="包含-starstWith-endsWith-includes">包含-starstWith(), endsWith(), includes()</h5>
<p>用于判断字符串中是否包含另一个字符串，这些方法都会从字符串中搜索传入的字符串，并返回表示是否包含的布尔值。区别在于，startsWith()检查目标字符串是否以传入字符串开头，endsWith()检查目标字符串是否以传入字符串结尾，includes()检查目标字符串是否包含传入字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bak&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>, -<span class="number">3</span>)); <span class="comment">// false        可接受第二个参数结束索引</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;oba&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="修剪-trim-trimLeft-trimRight">修剪-trim(), trimLeft(), trimRight()</h5>
<p>创建字符串的一个副本，删除前、后所有空格，再返回结果。原字符串不受影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;   Hello  &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">trim</span>()); <span class="comment">// Hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">trimLeft</span>()); <span class="comment">// Hello__(两空格)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">trimRight</span>()); <span class="comment">// ___Hello</span></span><br></pre></td></tr></table></figure>
<h5 id="重复-repeat">重复-repeat()</h5>
<p>ECMAScript 在所有字符串上都提供 repeat()方法。这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;Kinsiy &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">repeat</span>(<span class="number">5</span>) + <span class="string">&quot;🤣&quot;</span>); <span class="comment">// Kinsiy Kinsiy Kinsiy Kinsiy Kinsiy 🤣</span></span><br></pre></td></tr></table></figure>
<h5 id="填充-padStart-padEnd">填充-padStart(), padEnd()</h5>
<p>padStatr()和 padEnd()方法会复制字符串，如果小于指定长度，则在相应的一边填充字符直至满足长度条件。这个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格(U+0020)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&quot;🤣&quot;</span>)); <span class="comment">// 🤣🤣Kinsiy 别忘了前面说的Unicode代理对</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">padEnd</span>(<span class="number">10</span>, <span class="string">&quot;🤣&quot;</span>)); <span class="comment">// Kinsiy🤣🤣</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可选的第二个参数不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。</span></span><br><span class="line"><span class="comment">    此外，如果长度小于或等于字符串长度，则会返回原始字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">strValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">padStart</span>(<span class="number">10</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// barbarbfoo</span></span><br></pre></td></tr></table></figure>
<h5 id="迭代与解构-iterator">迭代与解构-@@iterator()</h5>
<p>字符串的原型上暴露了一个@@iterator()方法，表示可以迭代字符串的每个字符。可以向下面这样手动使用迭代器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> stringIterator = strValue[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">//&#123;value: &quot;a&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">//&#123;value: &quot;b&quot;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringIterator.<span class="title function_">next</span>()); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在for-of 循环中可以通过这个迭代器按序访问每个字符 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">&quot;abcde&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用解构操作符解构为数组 */</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...name]); <span class="comment">// [&quot;K&quot;, &quot;i&quot;, &quot;n&quot;, &quot;s&quot;, &quot;i&quot;, &quot;y&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="大小写-toLowerCase-toUpperCase">大小写-toLowerCase(), toUpperCase()</h5>
<p>还有 toLocaleLowerCase(),toLocaleUpperCase(), 旨在基于特定地区实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strValue = <span class="string">&quot;Kinsiy &quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">toLowerCase</span>()); <span class="comment">// kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strValue.<span class="title function_">toUpperCase</span>()); <span class="comment">// KINSIY</span></span><br></pre></td></tr></table></figure>
<h5 id="正则">正则</h5>
<h6 id="match">match()</h6>
<p>本质上跟 RegExp 对象的 exec()方法相同。match()方法接收一个参数，可以是一个正则表达式字面量，也可以是一个 RegExp 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]); <span class="comment">// cat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h6 id="search">search()</h6>
<p>这个方法唯一的参数和 match()一样：正则表达式字面量或 RegExp 对象。这个方法返回模式第一个匹配位置的位置索引，如果没找到则返回-1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/at/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="title function_">search</span>(pattern)); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h6 id="replace">replace()</h6>
<p>这个方法接收两个参数，第一个参数可以是一个 RegExp 对象或一个字符串(这个字符串不会转换为正则表达式)，第二个参数可以是一个字符串或一个函数。如果第一个参数是字符串，那么只会替换第一个字字符串。想要替换所有子字符串，第一个参数必须为正则表达式并且带全局标记。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="string">&quot;at&quot;</span>, <span class="string">&quot;ond&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// cond, bat, sat, fat</span></span><br><span class="line"></span><br><span class="line">result = text.<span class="title function_">replace</span>(<span class="regexp">/at/g</span>, <span class="string">&quot;ond&quot;</span>); <span class="comment">// cond, bond, sond, fond</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure>
<p>在第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符序列</th>
<th style="text-align:left">替换文本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$$</td>
<td style="text-align:left">$</td>
</tr>
<tr>
<td style="text-align:center">$&amp;</td>
<td style="text-align:left">匹配整个模式的子字符串。与 RegExp.lastMatch 相同</td>
</tr>
<tr>
<td style="text-align:center">&amp;’</td>
<td style="text-align:left">匹配的子字符串之前的字符串。与 RegExp.rightContext 相同</td>
</tr>
<tr>
<td style="text-align:center">&amp;`</td>
<td style="text-align:left">匹配的子字符串之后的字符串。与 RegExp.leftContext 相同</td>
</tr>
<tr>
<td style="text-align:center">&amp;n</td>
<td style="text-align:left">匹配第 n 个捕获组的字符串，其中 n 是 0~9</td>
</tr>
<tr>
<td style="text-align:center">&amp;nn</td>
<td style="text-align:left">匹配第 nn 个捕获组的字符串，其中 nn 是 01~99</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = text.<span class="title function_">replace</span>(<span class="regexp">/(.at)/g</span>, <span class="string">&quot;word ($1)&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// word (cat), word (bat), word (sat), word (fat)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* replace() 第二个参数可以是一个函数</span></span><br><span class="line"><span class="comment">    在只有一个匹配项时，这个函数会收到3个参数：与整个模式匹配的字符串，匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数。但最后两个参数还是与整个模式匹配的开始位置和原始字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">htmlEscape</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> text.<span class="title function_">replace</span>(<span class="regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="keyword">function</span> (<span class="params">match, pos, originalText</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;lt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&gt;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;gt;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;&amp;&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;amp;&quot;</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&amp;quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">htmlEscape</span>(<span class="string">&#x27;&lt;p class=&quot;greeting&quot;&gt;Hello World!&lt;/p&gt;&#x27;</span>));</span><br><span class="line"><span class="comment">// &amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello World!&amp;lt;/p&amp;gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="split">split()</h6>
<p>这个方法会根据传入的分隔符将字符串拆分成数组。作为分隔符的参数可以是字符串，也可以是 RegExp 对象。还可以传入第二个参数，即数组大小，确保返回的数组不会超过指定大小。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorText = <span class="string">&quot;ref,bule,green,yellow&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> colors1 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors1); <span class="comment">//[&quot;ref&quot;, &quot;bule&quot;, &quot;green&quot;, &quot;yellow&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors2 = colorText.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">//[&quot;ref&quot;, &quot;bule&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors3 = colorText.<span class="title function_">split</span>(<span class="regexp">/[^,]+/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">//[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</span></span><br></pre></td></tr></table></figure>
<h5 id="比较—localeCompare">比较—localeCompare()</h5>
<p>这个方法比价两个字符串，返回如下 3 个值中的一个</p>
<ul>
<li>如果按照字母表顺序，字符串应该排在字符串参数前头，则返回负值</li>
<li>如果字符串与字符串参数相等，则返回 0</li>
<li>如果按照字母表顺序，字符串应该排在字符串参数后头，则返回正值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;brick&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;yellow&quot;</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">localeCompare</span>(<span class="string">&quot;zoo&quot;</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<h5 id="html-方法">html 方法</h5>
<p>略</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-Proxy[捕获器与反射]</title>
    <url>/Javascript-Proxy-2/</url>
    <content><![CDATA[<h2 id="代理捕获器与反射方法">代理捕获器与反射方法</h2>
<h3 id="get">get()</h3>
<p>get()捕获器会在获取属性值得操作中被调用。对应的反射 API 方法为 Reflect.get()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">id</span>; <span class="comment">// get()</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ol>
<li>返回值
<ul>
<li>返回值无限制</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>proxy.property</li>
<li>proxy[property]</li>
<li>Object.create(proxy)[property]</li>
<li>Reflect.get(proxy, property, receiver)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
<li>receiver：代理对象或继承代理对象的对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target.property 不可写且不可配置，则处理程序返回值必须与 target.property 匹配。</li>
<li>如果 target.property 不可配置且[[Get]]特性为 undefined，处理程序的返回值也必须是 undefined。</li>
</ul>
</li>
</ol>
<h3 id="set">set()</h3>
<p>set()捕获器会在设置属性值得操作中被调用。对应的反射 API 方法为 Reflect.set()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">id</span> = <span class="string">&quot;Kinsiy&quot;</span>; <span class="comment">// set()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>proxy.property = value</li>
<li>proxy[property] = value</li>
<li>Object.create(proxy)[property] = value</li>
<li>Reflect.set(proxy, property, value, receiver)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
<li>value: 要赋给属性的值</li>
<li>receiver：代理对象或继承代理对象的对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target.property 不可写且不可配置，则不能修改目标属性的值</li>
<li>如果 target.property 不可配置且[[Set]]特性为 undefined，则不能修改目标属性的值</li>
<li>在严格模式下，处理程序中返回 false 会抛出 TypeError</li>
</ul>
</li>
</ol>
<h3 id="has">has()</h3>
<p>set()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;has()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;id&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">//has() false</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>has()必须返回布尔值，表示属性是否存在。返回非布尔值会被转型为布尔值</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>property in proxy</li>
<li>property in Object.create(proxy)</li>
<li>With(proxy){(property;)}</li>
<li>Reflect.has(proxy, property)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target.property 存在且不可配置，则处理程序必须返回 false</li>
<li>如果 target.property 存在且目标对象不可扩展，则处理程序必须返回 true</li>
</ul>
</li>
</ol>
<h3 id="defineProperty">defineProperty()</h3>
<p>defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为 Reflect.defineProperty()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, property, descriptor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;defineProperty()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(proxy, <span class="string">&quot;id&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Queen&quot;</span>,</span><br><span class="line">&#125;); <span class="comment">// defineProperty()</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">id</span>); <span class="comment">// Queen</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>defineProperty()必须返回布尔值，表示属性是否成功定义。返回非布尔值会被转型为布尔值</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.defineProperty(peoxy, property, descriptor)</li>
<li>Reflect.defineProperty(peoxy, property, descriptor)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
<li>descriptor: 包含可选的 enumerable、configurable、writable、value、get 和 set 定义的对象。</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果目标对象不可扩展，则无法定义属性</li>
<li>如果目标对象有一个可配置的属性，则不能添加同名的不可配置属性</li>
<li>如果目标对象有一个不可配置的属性，则不能添加同名的可配置属性</li>
</ul>
</li>
</ol>
<h3 id="getOwnPropertyDescriptor">getOwnPropertyDescriptor()</h3>
<p>getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getOwnPropertyDescriptor()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getOwnPropertyDescriptor</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(proxy, <span class="string">&quot;id&quot;</span>); <span class="comment">// getOwnperpertyDescriptor()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>getOwnPropertyDescriptor()必须返回对象，或者属性不存在时返回 undefined。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.getOwnPropertyDescriptor(peoxy, property)</li>
<li>Reflect.getOwnPropertyDescriptor(peoxy, property)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果自有的 target.property 存在且不可配置，则处理程序必须返回一个表示该属性存在的对象</li>
<li>如果自有的 target.property 存在且可配置，则处理程序必须返回表示该属性可配置的对象</li>
<li>如果自有的 target.property 存在且 target 不可扩展，则处理程序必须返回一个表示该属性存在的对象</li>
<li>如果自有的 target.property 不存在，则处理程序不能返回表示该属性可配置的对象</li>
</ul>
</li>
</ol>
<h3 id="deleteProperty">deleteProperty()</h3>
<p>deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect.deleteProperty()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;deleteProperty()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">id</span>; <span class="comment">// deleteProperty()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>defineProperty()必须返回布尔值，表示删除属性是否成功。返回非布尔值会被转型为布尔值。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>delete proxy.property</li>
<li>delete proxy[property]</li>
<li>Reflect.deleteProperty(peoxy, property)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>property: 引用的目标对象上的字符串属性</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果自有的 target.property 存在且不可配置，则处理程序不能删除这个属性</li>
</ul>
</li>
</ol>
<h3 id="ownKeys">ownKeys()</h3>
<p>ownKeys()捕获器会在 Object.keys() 及类似方法中被调用。对应的反射 API 方法为 Reflect.ownKeys()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ownKeys()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy); <span class="comment">// ownKeys()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>ownKeys()必须返回包含字符串或符号的可枚举对象</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.getOwnPropertyNames(proxy)</li>
<li>Object.getOwnPropertySymbols(proxy)</li>
<li>Object.keys(proxy)</li>
<li>Reflect.ownKeys(peoxy)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>返回的可枚举对象必须包含 target 的所有不可配置的自有属性</li>
<li>如果 target 不可扩展，则返回可枚举对象必须准确地包含自有属性键</li>
</ul>
</li>
</ol>
<h3 id="getPrototypeOf">getPrototypeOf()</h3>
<p>getPrototypeOf()捕获器会在 Object.getPrototypeOf() 中被调用。对应的反射 API 方法为 Reflect.getPrototypeOf()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getPrototypeOf()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object.getPrototypeOf() 返回指定对象的原型，内部[[prototype]]属性的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy); <span class="comment">// getPrototypeOf()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>getPrototypeOf()必须返回对象或 null。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.getPrototypeOf(proxy)</li>
<li>Reflect.getPrototypeOf(proxy)</li>
<li>proxy.<em>_proto</em>_</li>
<li>Object.prototype.isPrototypeOf(proxy)</li>
<li>proxy instanceof Object</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target 不可扩展，则 Object.getPrototypeOf(proxy)唯一有效的返回值就是 Object.getPrototypeOf(target)的返回值</li>
</ul>
</li>
</ol>
<h3 id="setPrototypeOf">setPrototypeOf()</h3>
<p>setPrototypeOf()捕获器会在 Object.setPrototypeOf() 中被调用。对应的反射 API 方法为 Reflect.setPrototypeOf()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">setPrototypeOf</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setPrototypeOf()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object.setPrototypeOf() 向实例的私有特性[[Prototype]]写入一个新值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPropertypeOf</span>(proxy, <span class="title class_">Object</span>); <span class="comment">// setPrototypeOf()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>setPrototypeOf()必须返回布尔值，表示值原型赋值是否成功。返回非布尔值会被转型为布尔值。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.setPrototypeOf(proxy, prototype)</li>
<li>Reflect.setPrototypeOf(proxy, prototype)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>prototype: target 的替代原型，如果是顶级原型则为 null</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target 不可扩展，则唯一有效的 prototype 参数就是 Object.getPrototypeOF(target)的返回值</li>
</ul>
</li>
</ol>
<h3 id="isExtensible">isExtensible()</h3>
<p>isExtensible()捕获器会在 Object.isExtensible() 中被调用。对应的反射 API 方法为 Reflect.isExtensible()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isExtensible()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</span></span><br><span class="line"><span class="comment"> * Object.preventExtensions，Object.seal 或 Object.freeze 方法都可以标记一个对象为不可扩展（non-extensible）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy); <span class="comment">// isExtensible()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>isExtensible()必须返回布尔值，表示 target 是否可扩展。返回非布尔值会被转型为布尔值。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.isExtensible(proxy)</li>
<li>Reflect.isExtensible(proxy)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 target 可扩展，则处理程序必须返回 true</li>
<li>如果 target 不可扩展，则处理程序必须返回 false</li>
</ul>
</li>
</ol>
<h3 id="preventExtensions">preventExtensions()</h3>
<p>preventExtensions()捕获器会在 Object.preventExtensions() 中被调用。对应的反射 API 方法为 Reflect.preventExtensions()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;preventExtensions()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object.preventExtensions()方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy); <span class="comment">// preventExtensions()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>preventExtensions()必须返回布尔值，表示 target 是否已经不可扩展。返回非布尔值会被转型为布尔值。</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>Object.preventExtensions(proxy)</li>
<li>Reflect.preventExtensions(proxy)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>如果 Object.isExtensible(proxy)是 false，则处理程序必须返回 true</li>
</ul>
</li>
</ol>
<h3 id="apply">apply()</h3>
<p>apply()捕获器会在调用函数时被调用。对应的反射 API 方法为 Reflect.apply()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myTarget</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">target, thisArg, argumentsList</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;apply()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">apply</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">proxy</span>(); <span class="comment">// apply()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>无限值</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>proxy(…argumentsList)</li>
<li>Function.prototype.apply(thisArg, argumentsList)</li>
<li>Function.prototype.call(thisArg, …argumentsList)</li>
<li>Reflect.apply(target, thisArgument, argumentsList)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>thisArg: 调用函数时的 this 参数</li>
<li>argumentsList: 调用函数时的参数列表</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>target 必须是一个函数对象</li>
</ul>
</li>
</ol>
<h3 id="construct">construct()</h3>
<p>construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myTarget = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(myTarget, &#123;</span><br><span class="line">  <span class="title function_">construct</span>(<span class="params">target, argumentsList, newTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;construct()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">proxy</span>(); <span class="comment">// construct()</span></span><br></pre></td></tr></table></figure>
<ol>
<li>返回值
<ul>
<li>construct()必须返回一个对象</li>
</ul>
</li>
<li>拦截的操作
<ul>
<li>new proxy(…argumentsList)</li>
<li>Reflect.construct(target, argumentsList, newTarget)</li>
</ul>
</li>
<li>捕获器处理程序函数
<ul>
<li>target: 目标对象</li>
<li>argumentsList: 调用函数时的参数列表</li>
<li>newTarget: 最初被调用的构造函数</li>
</ul>
</li>
<li>捕获器不变式
<ul>
<li>target 必须可以用作构造函数</li>
</ul>
</li>
</ol>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-变量、作用域与内存</title>
    <url>/Javascript-Variables/</url>
    <content><![CDATA[<p>相比于其他语言，Javascript 中的变量可谓独树一帜。正如 ECMA-262 所规定的，Javascript 变量是松散类型的，而且变量不过就是特定时间点的一个特定值而已。由于没有规定变量必须包含什么数据类型，变量的值和数据类型在脚本生命期间可以改变。这样的变量很有意思，很强大，当然也有不少问题。本章会剖析错综复杂的变量。</p>
<span id="more"></span>
<h2 id="原始值与引用值">原始值与引用值</h2>
<p>EMCAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。再把一个值赋给变量是，Javascript 引擎必须确定这个值是原始值还是引用值。《语言基础》一章讨论了 6 种原始值：undefined、Null、Boolean、Number、String、Symbol。保存原始值的变量是按值访问的。引用值是保存在内存中的对象，Javascript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用。为此保存引用值的变量是按引用访问的。</p>
<h3 id="动态属性">动态属性</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 引用值 */</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Kinsiy&quot;</span></span><br><span class="line"><span class="comment">/* 原始值 */</span></span><br><span class="line"><span class="comment">// 原始值不能有属性，尽管尝试给原始值添加属性不会报错</span></span><br><span class="line">ler name = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">name.<span class="property">age</span> = <span class="number">23</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="复制值">复制值</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 原始值复制 */</span></span><br><span class="line"><span class="comment">// num1 与 num2 完全独立</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用值复制 */</span></span><br><span class="line"><span class="comment">// obj1 与 obj2 指向同一个对象</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// &quot;Kinsiy&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="传递参数">传递参数</h3>
<p>ECMAscript 中所有函数的参数都是按值传递的。在按值传递参数时，值会被复制到一个局部变量中。在按引用传递参数时，值在内存中的位置会被保存在一个局部变量中，这意味着对本地变量的修改会反映到函数外部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count  = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addTen</span>(count);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  obj = <span class="title class_">New</span> <span class="title class_">Object</span>();</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Kinsiy&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="确定类型">确定类型</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">56</span>;</span><br><span class="line"><span class="keyword">let</span> d;</span><br><span class="line"><span class="keyword">let</span> e = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* typeof */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">//String</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> c); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> d); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> e); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* instanceof </span></span><br><span class="line"><span class="comment">    result = variable instanceof constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;粉色&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> patter = <span class="regexp">/.d/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(patter <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="执行上下文与作用域">执行上下文与作用域</h2>
<p>全局上下文是最外层的上下文。在浏览器中，全局上下文就是我们常说的 window 对象，因此所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;bule&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">swapColor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ler tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以访问color、anotherColor、tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以访问color、anotherColor, 无法访问tempColor</span></span><br><span class="line">  <span class="title function_">swapColor</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内部上下文可以通过作用域链访问外部上下文的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的 */</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域增强">作用域增强</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">testWith</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> qs = <span class="string">&quot;?debug=ture&quot;</span>;</span><br><span class="line">  <span class="keyword">with</span> (location) &#123;</span><br><span class="line">    <span class="keyword">let</span> url = href + qs; <span class="comment">// 相当于location.href</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url; <span class="comment">// ReferenceError: url is not defined   使用let定义把url限制在了&#123;&#125;中，换做var可增强作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">testWith</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">/* try/catch 语句的catch块、with语句 会导致在作用域的前端临时添加一个上下文，这个上下文在代码执行后会被删除 */</span></span><br></pre></td></tr></table></figure>
<h3 id="变量声明">变量声明</h3>
<p>使用 var 的函数作用域声明<br><br>
在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中最接近的上下文也是函数上下文。如果变量未经声明就被初始化了那么它就会自动添加到全局上下文</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* var */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = num1 + num2; <span class="comment">//若省略var，下方console.log不会报错</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">//ReferenceError: sum is not defined</span></span><br><span class="line"><span class="comment">/* 变量提升 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">//不会报错，而是undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Kinsiy&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>使用 let 的快级作用域声明<br><br>
ES6 新增的 let 关键字与 var 很相似，但它作用域是块级的，这也是 Javascript 中的新概念。块级作用域由最近的一对花括号{}界定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//ReferenceError: a is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不能重复声明 */</span></span><br><span class="line"><span class="keyword">let</span> c;</span><br><span class="line"><span class="keyword">let</span> c; <span class="comment">//SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>使用 const 的常量声明<br><br>
使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值、</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="comment">/* cosnt除了要遵守以上规则，其它方面与let声明一样</span></span><br><span class="line"><span class="comment">    const声明只应用到顶级原语或对象，换句话说，赋值为对象的const变量不能再被重新赋值为其他引用值，但对象的键则不收限制</span></span><br><span class="line"><span class="comment">    若想让整个对象都不能修改，可以使用Object.freeze(),这样再给属性赋值时虽然不会报错，但会静默失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">//TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.<span class="property">name</span> = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">name</span>); <span class="comment">//Kinsiy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o3 = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line">o3.<span class="property">name</span> = <span class="string">&quot;Restituo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">name</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="标识符查找">标识符查找</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> color = <span class="string">&quot;pink&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getColor</span>()); <span class="comment">//green</span></span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收">垃圾回收</h2>
<p>Javascript 最常用的垃圾回收策略是标记清理。</p>
<p>垃圾回收程序在运行的时候，会标记内存中存储的所有变量(标记方法有很多种)。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存。</p>
<h3 id="内存管理">内存管理</h3>
<p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不在必要，那么把它设置为 null，从而释放其引用。这也可以叫做解除引用。这个建议最适合全局变量和全局对象。局部变量在超出作用域后会被自动解除引用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> locatPerson = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  locatPerson.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grobalPerson = <span class="title function_">createPerson</span>(<span class="string">&quot;Kinsiy&quot;</span>);</span><br><span class="line"><span class="comment">//  ....</span></span><br><span class="line"></span><br><span class="line">grobalPerson = <span class="literal">null</span>;        <span class="comment">//解除grobalPerson 对值得引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过const和let 声明提升性能</span></span><br><span class="line"><span class="comment">    因为const和let 都以块(而非)函数为作用域，所以相比于var，使用这两个新关键字可能会更早的让垃圾回收程序介入,尽早的回收应该回收的内存</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 隐藏类和删除操作</span></span><br><span class="line"><span class="comment">    V8 Javascript 引擎</span></span><br><span class="line"><span class="comment">    运行期间，V8 会将创建的对象和隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">opt_authour</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&quot;V8 Javascript&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">authour</span> = opt_authour;     <span class="comment">//避免“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;someone&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&quot;otherSomeone&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete a1.author                 //避免使用delete ,最佳实践是把不想要的属性设置为null</span></span><br><span class="line">a1.<span class="property">author</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存泄露 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params"></span>)&#123;</span><br><span class="line">  name = <span class="string">&quot;Kinsiy&quot;</span>;                <span class="comment">//最常见，解释器会把变量name当做window属性来创建。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;, <span class="number">100</span>;)                            <span class="comment">//定时器导致内存泄露</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">&quot;Kinsiy&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;                                  <span class="comment">//闭包导致内存泄露</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 静态分配与对象池 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//略</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
  </entry>
  <entry>
    <title>Javascript-XHR</title>
    <url>/Javascript-XHR/</url>
    <content><![CDATA[<h2 id="XMLHttpRequest-对象">XMLHttpRequest 对象</h2>
<p>所有现代浏览器都通过 XMLHttpRequest 构造函数原生支持 XHR 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="使用-XHR">使用 XHR</h3>
<p>使用 XHR 对象首先要调用 open()方法，这个方法接收 3 个参数：请求类型（“get”、&quot;post&quot;等）、请求 URL，以及表示请求是否异步的布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码就可以向 example.php 发送一个同步的 GET 请求。关于这行代码需要说明几点。首先，这里的 URL 是相对于代码所在页面的，当然也可以使用绝对 URL。其次，调用 open()不会实际发送请求，只是为发送请求做好准备。</p>
<p>要发送定义好的请求，必须像下面这样调用 send()方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>send()方法接收一个参数，是作为请求体发送的数据。如果不需要发送请求体，则必须传 null，因为这个参数在某些浏览器中是必需的。调用 send()之后，请求就会发送到服务器</p>
<p>因为这个请求是同步的，所以 JavaScript 代码会等待服务器响应之后再继续执行。收到响应后，XHR 对象的以下属性会被填充上数据</p>
<ul>
<li>responseText：作为响应体返回的文本。</li>
<li>responseXML：如果响应的内容类型是&quot;text/xml&quot;或&quot;application/xml&quot;，那就是包含响应数据的 XML DOM 文档。</li>
<li>status：响应的 HTTP 状态。</li>
<li>statusText：响应的 HTTP 状态描述</li>
</ul>
<p>收到响应后，第一步要检查 status 属性以确保响应成功返回。一般来说，HTTP 状态码为 2xx 表示成功。此时，responseText 或 responseXML（如果内容类型正确）属性中会有内容。如果 HTTP 状态码是 304，则表示资源未修改过，是从浏览器缓存中直接拿取的。当然这也意味着响应有效。为确保收到正确的响应，应该检查这些状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可能显示服务器返回的内容，也可能显示错误消息，取决于 HTTP 响应的状态码。为确定下一步该执行什么操作，最好检查 status 而不是 statusText 属性，因为后者已经被证明在跨浏览器的情况下不可靠。无论是什么响应内容类型，responseText 属性始终会保存响应体，而 responseXML 则对于非 XML 数据是 null。</p>
<p>虽然可以像前面的例子一样发送同步请求，但多数情况下最好使用异步请求，这样可以不阻塞 JavaScript 代码继续执行。XHR 对象有一个 readyState 属性，表示当前处在请求/响应过程的哪个阶段</p>
<ul>
<li>0：未初始化（Uninitialized）。尚未调用 open()方法。</li>
<li>1：已打开（Open）。已调用 open()方法，尚未调用 send()方法。</li>
<li>2：已发送（Sent）。已调用 send()方法，尚未收到响应。</li>
<li>3：接收中（Receiving）。已经收到部分响应。</li>
<li>4：完成（Complete）。已经收到所有响应，可以使用了。</li>
</ul>
<p>每次 readyState 从一个值变成另一个值，都会触发 readystatechange 事件。可以借此机会检查 readyState 的值。一般来说，我们唯一关心的 readyState 值是 4，表示数据已就绪。为保证跨浏览器兼容，onreadystatechange 事件处理程序应该在调用 open()之前赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>在收到响应之前如果想取消异步请求，可以调用 abort()方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure>
<p>调用这个方法后，XHR 对象会停止触发事件，并阻止访问这个对象上任何与响应相关的属性。中 断请求后，应该取消对 XHR 对象的引用。由于内存问题，不推荐重用 XHR 对象。</p>
<h3 id="HTTP-头部">HTTP 头部</h3>
<p>每个 HTTP 请求和响应都会携带一些头部字段，这些字段可能对开发者有用。XHR 对象会通过一些方法暴露与请求和响应相关的头部字段。</p>
<p>默认情况下，XHR 请求会发送以下头部字段</p>
<ul>
<li>Accept：浏览器可以处理的内容类型。</li>
<li>Accept-Charset：浏览器可以显示的字符集。</li>
<li>Accept-Encoding：浏览器可以处理的压缩编码类型。</li>
<li>Accept-Language：浏览器使用的语言。</li>
<li>Connection：浏览器与服务器的连接类型。</li>
<li>Cookie：页面中设置的 Cookie。</li>
<li>Host：发送请求的页面所在的域。</li>
<li>Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容性也必须将错就错。（正确的拼写应该是 Referrer。）</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p>虽然不同浏览器发送的确切头部字段可能各不相同，但这些通常都是会发送的。如果需要发送额外的请求头部，可以使用 setRequestHeader()方法。这个方法接收两个参数：头部字段的名称和值。 为保证请求头部被发送，必须在 open()之后、send()之前调用 setRequestHeader()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;MyHeader&quot;</span>, <span class="string">&quot;MyValue&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myHeader = xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;MyHeader&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> allHeaders xhr.<span class="title function_">getAllResponseHeaders</span>();</span><br></pre></td></tr></table></figure>
<p>可以使用 getResponseHeader()方法从 XHR 对象获取响应头部，只要传入要获取头部的名称即可。如果想取得所有响应头部，可以使用 getAllResponseHeaders()方法，这个方法会返回包含所有响应头部的字符串</p>
<h3 id="GET-请求">GET 请求</h3>
<p>最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL 后面添加查询字符串参数。对 XHR 而言，查询字符串必须正确编码后添加到 URL 后面，然后再传给 open()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addURLParam</span>(<span class="params">url, name, value</span>) &#123;</span><br><span class="line">  url += url.<span class="title function_">indexOf</span>(<span class="string">&quot;?&quot;</span>) == -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">  url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&quot;=&quot;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&quot;example.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加参数</span></span><br><span class="line">url = <span class="title function_">addURLParam</span>(url, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line">url = <span class="title function_">addURLParam</span>(url, <span class="string">&quot;book&quot;</span>, <span class="string">&quot;Professional JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化请求</span></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="POST-请求">POST 请求</h3>
<p>第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在 请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据 可以是任意格式。要初始化 POST 请求，open()方法的第一个参数要传&quot;post&quot;，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;example.php&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>接下来就是要给 send()方法传入要发送的数据。因为 XHR 最初主要设计用于发送 XML，所以可 以传入序列化之后的 XML DOM 文档作为请求体。当然，也可以传入任意字符串。</p>
<p>默认情况下，对服务器而言，POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST 数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把 Content-Type 头部设置为&quot;application/x-www-formurlencoded&quot;，这是提交表单时使用的内容类型。第二 步是创建对应格式的字符串。POST 数据此时使用与查询字符串相同的格式。如果网页中确实有一个表 单需要序列化并通过 XHR 发送到服务器，则可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Serialization">serialize()</a>函数来创建相应的字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">submitData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(<span class="title function_">serialize</span>(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="XMLHttpRequest-Level-2">XMLHttpRequest Level 2</h3>
<p>XHR 对象作为事实标准的迅速流行，也促使 W3C 为规范这一行为而制定了正式标准。 XMLHttpRequest Level 1 只是把已经存在的 XHR 对象的实现细节明确了一下。XMLHttpRequest Level 2 又进一步发展了 XHR 对象。并非所有浏览器都实现了 XMLHttpRequest Level 2 的所有部分，但所有浏览器都实现了其中部分功能</p>
<h4 id="FromData-类型">FromData 类型</h4>
<p>现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了 FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR 发送</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *        append()方法接收两个参数：键和值，相当于表单字段名称和该字段的值。可以像这样添加任意多个键/值对数据。此外，* 通过直接给 FormData 构造函数传入一个表单元素，也可以将表单中的数据作为键/值对填充进去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="keyword">new</span> <span class="title class_">FormData</span>(form));</span><br></pre></td></tr></table></figure>
<p>使用 FormData 的另一个方便之处是不再需要给 XHR 对象显式设置任何请求头部了。XHR 对象能够识别作为 FormData 实例传入的数据类型并自动配置相应的头部</p>
<h4 id="超时">超时</h4>
<p>IE8 给 XHR 对象增加了一个 timeout 属性，用于表示发送请求后等待多少毫秒，如果响应不成功就中断请求。之后所有浏览器都在自己的 XHR 实现中增加了这个属性。在给 timeout 属性设置了一个时间且在该时间过后没有收到响应时，XHR 对象就会触发 timeout 事件，调用 ontimeout 事件处理程序。这个特性后来也被添加到了 XMLHttpRequest Level 2 规范</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123; <span class="comment">// ontimeout readyState 仍然会变成 4</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="comment">// 假设由 ontimeout 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;timeout.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">timeout</span> = <span class="number">1000</span>; <span class="comment">// 设置 1 秒超时</span></span><br><span class="line">xhr.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;Request did not return in a second.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="overrideMimeType-方法">overrideMimeType() 方法</h4>
<p>Firefox 首先引入了 overrideMimeType()方法用于重写 XHR 响应的 MIME 类型。这个特性后来也被添加到了 XMLHttpRequest Level 2。因为响应返回的 MIME 类型决定了 XHR 对象如何处理响应，所以如果有办法覆盖服务器返回的类型，那么是有帮助的。</p>
<p>假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text/plain。结果就会导致虽然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType()可以保证将响应当成 XML 而不是纯文本来处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;text.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">overrideMimeType</span>(<span class="string">&quot;text/xml&quot;</span>); <span class="comment">// 子强制让 XHR 把响应当成 XML 而不是纯文本来处理</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>为了正确覆盖响应的 MIME 类型，必须在调用 send()之前调用 overrideMimeType()</p>
<h2 id="进度事件">进度事件</h2>
<p>Progress Events 是 W3C 的工作草案，定义了客户端-服务器端通信。这些事件最初只针对 XHR，现在也推广到了类似的 API。有以下 6 个进度相关的事件</p>
<ul>
<li>loadstart：在接收到响应的第一个字节时触发</li>
<li>progress：在接收响应期间反复触发</li>
<li>error：在请求出错时触发</li>
<li>abort：在调用 abort()终止连接时触发</li>
<li>load：在成功接收完响应时触发</li>
<li>loadend：在通信完成时，且在 error、abort 或 load 之后触发</li>
</ul>
<p>每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort 或 load 中的一个，最后 loadend 事件结束</p>
<h3 id="load-事件">load 事件</h3>
<p>Firefox 最初在实现 XHR 的时候，曾致力于简化交互模式。最终，增加了一个 load 事件用于代替 readystatechane 事件。load 事件在响应接收完成后立即触发，这样就不用检查 readystate 属性了。onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。不过并不是所有浏览器都实现了这个事件的 event 对象。考虑到跨浏览器兼容，还是需要像下面这样使用 XHR 对象变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h3 id="progress-事件">progress 事件</h3>
<p>Mozilla 在 XHR 对象上另一个创新是 progress 事件，在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress 事件处理程序都会收到 event 对象，其 target 属性是 XHR 对象，且包含 3 个额外属性：lengthComputable、posotion 和 totalSize。其中，lengthComputable 是一个布尔值，表示进度信息是否可用；position 是接收到的字节数；totalSize 是响应的 Content-Length 头部定义的总字节数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) || xhr.<span class="property">statu</span> == <span class="number">304</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.<span class="property">status</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> divStatus = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">    divStatus.<span class="property">innerHTML</span> = <span class="string">&quot;Received &quot;</span> + event.<span class="property">position</span> + <span class="string">&quot; of &quot;</span> + event.<span class="property">totalSize</span> + <span class="string">&quot; bytes.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;altevents.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>为了保证正确执行，必须在调用 open()之前添加 onprogress 事件处理程序。</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>XHR</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-async/await</title>
    <url>/Javascript-async-await/</url>
    <content><![CDATA[<p>异步函数，也称为&quot;async/await&quot;(语法关键字)，是 ES6 期约模式在 ECMAScript 函数中的引用。async/await 是 ES8 规范新增的。</p>
<h2 id="异步函数">异步函数</h2>
<p>ES8 的 async/await 旨在解决利用异步结构组织代码的问题。为此，ECMAScript 对函数进行就扩展，为其增加了两个新关键字: async 和 await。</p>
<span id="more"></span>
<h3 id="async">async</h3>
<p>async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上。使用 async 关键字可以让函数具有异步特性，但总体上其代码仍然是同步求值的。而在参数或闭包方面，异步函数仍然具有普通 Javascript 函数的正常行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// foo()函数仍然会在后面的指令之前被求值</span></span><br></pre></td></tr></table></figure>
<p>不过，异步函数如果使用 return 关键字返回了值(如果没有 return 则会返回 undefined)，这个值会被 Promise.resolve()包装成一个期约对象。异步函数始终会返回期约对象。在函数外部调用这个函数可以得到它返回的期约</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给返回的期约添加一个解决处理程序</span></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>异步函数的返回值期待(但实际上并不要求)一个实现 thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由提供给 then()的处理程序&quot;解包&quot;。如果不是，则返回值就被当作已经解决的期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个实现了thenable接口的非期约对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> thenable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>().<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在异步函数中抛出错误会返回拒绝的期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">king</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">king</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拒绝期约的错误不会被捕获</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">queen</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 -&gt; 5</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) 6</span></span><br></pre></td></tr></table></figure>
<h3 id="await">await</h3>
<p>因为异步函数主要针对不会马上完成的任务，所以自然需要哦一种暂停和恢复执行的能力、使用 await 关键字可以暂停异步函数代码的执行，等待期约解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>注意，await 关键字会暂停执行异步函数后面的代码，让出 Javascript 运行时的执行线程。这个行为与生成器函数中的 yeild 关键字是一样的。await 关键字同样是尝试&quot;解包&quot;对象的值，然后将这个值传给表达式，再异步恢复异步函数的行为。await 关键字的用法与 Javascript 的一元操作一样。它可以单独使用，也可以在表达式中使用。</p>
<p>await 关键字期待(但实际上并不要求)一个实现 thenable 接口的对象，但常规的值也可以。如果返回的是实现 thenable 接口的对象，则这个对象可以由 await 来&quot;解包&quot;。如果不是，则返回值就被当作已经解决的期约。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待一个原始值</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个实现了thenable接口的对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    <span class="title function_">then</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> thenable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">//baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待一个期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">king</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;king&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">king</span>(); <span class="comment">// king</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待会抛出错误的同步操作，会返回拒绝的期约</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">3</span>;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">queen</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>单独的 Promise.reject()不会被异步函数捕获，而会抛出未捕获错误。不过，对拒绝的期约使用 await 则会释放(unwrap)错误值(将拒绝期约返回)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">kinsiy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>); <span class="comment">// 这行代码不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">kinsiy</span>().<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 1 -&gt; 2 -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h3 id="await-的限制">await 的限制</h3>
<p>await 关键字必须在异步函数中使用，不能在顶级上下文如&lt;Script&gt;标签或模块中使用。不过，定义并立即调用异步函数是没问题的。此外，异步函数的特质不会扩展到嵌套函数。因此，await 关键字也只能直接出现在异步函数的定义中。在同步函数内部使用 await 会抛出 SyntaxError。</p>
<h2 id="停止和恢复执行">停止和恢复执行</h2>
<p>async/await 中真正起作用的是 await。async 关键字，无论从哪方面来看，都不过是一个标识符。毕竟，异步函数如果不包含 await 关键字，其执行基本上跟普通函数没有什么区别。<br>
Javascript 运行时碰到 await 关键字时，会记录在哪里暂停执行。等到 await 右边的值可用了，Javascript 运行时会向消息队列中推送一个任务，这个任务会恢复异步函数的执行。因此，即使 await 后面跟着一个立即可用的值，函数的其余部分也会被异步求值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; 4</span></span><br></pre></td></tr></table></figure>
<h2 id="异步函数策略">异步函数策略</h2>
<h3 id="实现-sleep">实现 sleep()</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">delay</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>() - t0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 3014</span></span><br></pre></td></tr></table></figure>
<h3 id="利用平行执行">利用平行执行</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">randomDelay</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="comment">// 延迟0~1000ms</span></span><br><span class="line">  <span class="keyword">const</span> delay = <span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;id&#125;</span> 完成`</span>);</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> t0 = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">const</span> promises = <span class="title class_">Array</span>(<span class="number">5</span>)</span><br><span class="line">    .<span class="title function_">fill</span>(<span class="literal">null</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function">(<span class="params">_, i</span>) =&gt;</span> <span class="title function_">randomDelay</span>(i));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`共耗时<span class="subst">$&#123;<span class="built_in">Date</span>.now() - t0&#125;</span>ms`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">//4 完成</span></span><br><span class="line"><span class="comment">//1 完成</span></span><br><span class="line"><span class="comment">//2 完成</span></span><br><span class="line"><span class="comment">//0 完成</span></span><br><span class="line"><span class="comment">//3 完成</span></span><br><span class="line"><span class="comment">//共耗时921ms</span></span><br></pre></td></tr></table></figure>
<h3 id="串行执行期约">串行执行期约</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTwo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addThree</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addFive</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> [addTwo, addThree, addFive]) &#123;</span><br><span class="line">    x = <span class="keyword">await</span> <span class="title function_">fn</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addTen</span>(<span class="number">9</span>).<span class="title function_">then</span>(<span class="variable language_">console</span>.<span class="property">log</span>); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>
<h3 id="栈追踪与内存管理">栈追踪与内存管理</h3>
<p>略</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35175321/">JavaScript高级程序设计(第4版).</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖-节流-深拷贝</title>
    <url>/Js-debounce-thorttle&amp;deepCopy/</url>
    <content><![CDATA[<h2 id="防抖函数">防抖函数</h2>
<p>防抖，也叫去抖动，就是当事件快速连续不断触发时，动作只会执行一次。触发事件 delay 时间后再执行回调函数，如果在 delay 时间内又触发了事件，则重新计时</p>
<p>防抖函数分为，延迟防抖 和 前缘防抖，区别就是是否会立即执行。</p>
<div class="note primary"><p>简单实现, 生产环境可以使用 <a href="https://lodash.com/docs/">Lodash 库函数</a>,  <a href="http://demo.nimius.net/debounce_throttle/">可视化查看 原生 - 防抖 - 节流 三种处理方式的不同</a></p>
</div>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缘防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounceBefore</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p><a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L10304">Lodash _.debounce</a></p>
</div>
<h2 id="节流函数">节流函数</h2>
<p>节流，就是当事件快速连续不断触发时，每隔 delay 时间间隔执行一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">thorttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> working = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (working) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    working = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      working = <span class="literal">false</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前缘节流</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">thorttleBefore</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> working = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (working) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!working) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    working = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      working = <span class="literal">false</span>;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info"><p><a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L10897">Lodash _.throttle</a></p>
</div>
<h2 id="深拷贝">深拷贝</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isPrimitive</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&quot;symbol&quot;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&quot;boolean&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">&quot;[object Object]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isRegExp</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(value) === <span class="string">&quot;[object RegExp]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="comment">// debugger;</span></span><br><span class="line">  <span class="keyword">let</span> memo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">baseCopy</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isPrimitive</span>(value) || <span class="title function_">isRegExp</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      res = [...value];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObject) &#123;</span><br><span class="line">      res = &#123; ...value &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(res).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> res[key] === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> res[key] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[res[key]]) &#123;</span><br><span class="line">          res[key] = memo[res[key]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          memo[res[key]] = res[key];</span><br><span class="line">          res[key] = <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(res[key]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">baseCopy</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://juejin.cn/post/6844904144466083853">重拾 JS——防抖与节流</a></p>
<p>[2] <a href="https://segmentfault.com/a/1190000015455662">Javascriipt 深拷贝</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>debounce</tag>
        <tag>thorttle</tag>
        <tag>deepClone</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引知识点总结</title>
    <url>/MySQL-index/</url>
    <content><![CDATA[<blockquote>
<p>文章原出处为 &lt;腾讯技术工程&gt; 公众号，个人觉得写的非常好，故搬运过来，以便日后查阅。<br>作者：fanili，腾讯 WXG 后台开发工程师</p>
</blockquote>
<span id="more"></span>
<h1>什么是索引</h1>
<p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。（百度百科）<br><br><br>
索引的目的是提高查找效率，对数据表的值集合进行了排序，并按照一定数据结构进行了存储。<br><br><br>
本文将从一个案例开始，从索引的数据结构、分类、关键概念及如何使用索引提高查找效率等方面对索引知识进行总结。</p>
<h1>从一个案例开始</h1>
<h2 id="现象">现象</h2>
<p>业务中有个既存的历史 SQL 语句在运行时会导致 DB 服务器过载，进而导致相关服务阻塞无法及时完成。CPU 监控曲线如下：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%E4%BC%98%E5%8C%96%E5%89%8DCPU%E4%BD%BF%E7%94%A8%E7%8E%87.png" alt="优化前CPU使用率"><br><br><br>
从 DB 的 CPU 使用率曲线可以看到业务运行一直处于“亚健康”状态（1），随着业务的增长随时都可能出现问题。这种问题（2）在 11 月 11 日凌晨出现，当时 DB CPU 一直处于 100%高负荷状态，且存在大量的慢查询语句。最终以杀死进程降低 DB 负载、减少业务进程（3）的方式恢复业务。<br><br><br>
在 11 月 11 日下午，对该业务的 SQL 语句进行了优化，优化的效果如下。业务运行时的 CPU 使用率峰值有很大的降低（对比图 2 的 1，2，3 可见）；慢查询语句几乎在监控曲线上也无法明显观察到（对比图 3 的 1，2，3 可见）。<br><br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%E4%BC%98%E5%8C%96%E5%89%8D%E5%90%8E%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87.png" alt="优化前后的CUP使用率"><br><br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%E4%BC%98%E5%8C%96%E5%89%8D%E5%90%8E%E7%9A%84%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%95%B0%E9%87%8F.png" alt="优化前后的慢查询数量"><br><br></p>
<h2 id="分析">分析</h2>
<p>表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FStatDate</span> <span class="operator">%</span>&#125; <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">19700101</span> COMMENT <span class="string">&#x27;统计日期&#x27;</span>,</span><br><span class="line">&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FMerchantId</span> <span class="operator">%</span>&#125; <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;商户ID&#x27;</span>,</span><br><span class="line">&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FVersion</span> <span class="operator">%</span>&#125; <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;数据版本号&#x27;</span>,</span><br><span class="line">&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FBatch</span> <span class="operator">%</span>&#125; <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;统计批次&#x27;</span>,</span><br><span class="line">&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FTradeAmount</span> <span class="operator">%</span>&#125; <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;交易金额&#x27;</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FStatDate</span> <span class="operator">%</span>&#125;,&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FMerchantId</span> <span class="operator">%</span>&#125;,&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FVersion</span> <span class="operator">%</span>&#125;),</span><br><span class="line">INDEX i_FStatDate_FVersion (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FStatDate</span> <span class="operator">%</span>&#125;,&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@FVersion</span> <span class="operator">%</span>&#125;))</span><br><span class="line"><span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 ENGINE <span class="operator">=</span> InnoDB;</span><br></pre></td></tr></table></figure>
<p>从建表语句可以知道该表有两个索引：<br></p>
<ol>
<li>主键索引，是一个组合索引，由字段 FStateDate、FMerchantId 和 FVersion 组成；</li>
<li>普通索引，是一个组合索引，由字段 FStateDate 和 FVersion 组成；</li>
</ol>
<p>优化前的 SQL 语句（做了部分裁剪）A：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_CALC_FOUND_ROWS FStatDate,</span><br><span class="line">    FMerchantId,</span><br><span class="line">    FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line"><span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020</span><br><span class="line"><span class="keyword">WHERE</span> FStatDate <span class="operator">=</span> <span class="number">20201020</span></span><br><span class="line">    <span class="keyword">AND</span> FVersion <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">AND</span> FMerchantId <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> LIMIT <span class="number">0</span>, <span class="number">8000</span></span><br></pre></td></tr></table></figure>
<p>对该 SQL 进行 explain 得到如下结果，Extra 字段的值为 using where，说明并没有使用到索引。<br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql1.png" alt="sql1"><br><br><br>
优化后的 SQL 语句（做了部分裁剪）B：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_CALC_FOUND_ROWS a1.FStatDate,</span><br><span class="line">    a1.FMerchantId,</span><br><span class="line">    a1.FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line"><span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020 a1, (</span><br><span class="line">    <span class="keyword">SELECT</span> FStatDate, FMerchantId, FVersion</span><br><span class="line">    <span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020</span><br><span class="line">    <span class="keyword">WHERE</span> FStatDate <span class="operator">=</span> <span class="number">20201020</span></span><br><span class="line">        <span class="keyword">AND</span> FVersion <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">AND</span> FMerchantId <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> LIMIT <span class="number">0</span>, <span class="number">8000</span> ) a2</span><br><span class="line"><span class="keyword">where</span> a1.FStatDate <span class="operator">=</span> a2.FStatDate</span><br><span class="line">    <span class="keyword">and</span> a1.FVersion <span class="operator">=</span> a2.FVersion</span><br><span class="line">    <span class="keyword">and</span> a1.FMerchantId <span class="operator">=</span> a2.FMerchantId;</span><br></pre></td></tr></table></figure>
<p>优化关键步骤为：</p>
<ul>
<li>新增一个子查询，select 字段只有主键字段；</li>
</ul>
<p>该 SQL 的 explain 结果如下，子查询语句使用了索引，而最终在线上运行结果也证明了优化效果显著。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql2.png" alt="sql2"><br><br></p>
<h2 id="疑问">疑问</h2>
<p>优化后的 SQL 语句 B 比原来的 SQL 语句 A 复杂的多（子查询，临时表关联等），怎么效率会提升，违反直觉？有三个疑问：</p>
<ol>
<li>SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？</li>
<li>SQL 语句 B 的子查询为什么能够用到索引？</li>
<li>前后两条语句执行流程的差异是什么？</li>
</ol>
<h1>索引的数据结构</h1>
<p>在 MySQL 中，索引是在存储引擎层实现的，而不同的存储引擎根据其业务场景特点会有不同的实现方式。这里会先介绍我们常见的有序数组、Hash 和搜索树，最后看下 Innodb 的引擎支持的 B+树。</p>
<h2 id="有序数组">有序数组</h2>
<p>数组是在任何一本数据结构和算法的书籍都会介绍到的一种重要的数据结构。有序数组如其字面意思，以 Key 的递增顺序保存数据在数组中。非常适合等值查询和范围查询。</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID:1</th>
<th style="text-align:center">ID:2</th>
<th style="text-align:center">…</th>
<th style="text-align:center">ID:N</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">name1</td>
<td style="text-align:center">name2</td>
<td style="text-align:center">…</td>
<td style="text-align:center">nameN</td>
</tr>
</tbody>
</table>
<p>在 ID 值没有重复的情况下，上述数组按照 ID 的递增顺序进行保存。这个时候如果需要查询特定 ID 值的 name，用二分法就可以快速得到，时间复杂度是 O(logn)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找递归实现方式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(const <span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, start, mid - <span class="number">1</span>, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">        <span class="keyword">return</span> binary_search(arr, mid + <span class="number">1</span>, end, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序数组的优点很明显，同样其缺点也很明显。其只适合静态数据，如遇到有数据新增插入，则就会需要数据移动（新申请空间、拷贝数据和释放空间等动作），这将非常消耗资源。</p>
<h2 id="Hash">Hash</h2>
<p>哈希表是一种以键-值（K-V）存储数据的结构，我们只需要输入键 K，就可以找到对应的值 V。哈希的思路是用特定的哈希函数将 K 换算到数组中的位置，然后将值 V 放到数组的这个位置。如果遇到不同的 K 计算出相同的位置，则在这个位置拉出一个链表依次存放。哈希表适用于等值查询的场景，对应范围查询则无能为力。<br><br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/Hash.png" alt="Hsah"></p>
<h2 id="二叉搜索树">二叉搜索树</h2>
<p>二叉搜索树，也称为二叉查找树、有序二叉树或排序二叉树，是指一颗空树或者具有以下性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%e4%bc%98%e5%8c%96%e5%89%8d%e5%90%8e%e7%9a%84%e6%85%a2%e6%9f%a5%e8%af%a2%e6%95%b0%e9%87%8f.png" alt="二叉搜索树"><br>
<br>二叉搜索树相比于其它数据结构的优势在于查找、插入的时间复杂度较低，为 O(logn)。为了维持 O(logn)的查询复杂度，需要保持这棵树是平衡二叉树。<br><br>
二叉搜索树的查找算法：</p>
<ol>
<li>若 b 是空树，则搜索失败，否则：</li>
<li>若 x 等于 b 的根节点的值，则查找成功；否则：</li>
<li>若 x 小于 b 的根节点的值，则搜索左子树；否则：</li>
<li>查找右子树。</li>
</ol>
<p>相对于有序数组和 Hash，二叉搜索树在查找和插入两端的表现都非常不错。后续基于此不断的优化，发展出 N 叉树等。</p>
<h2 id="B-树">B+树</h2>
<p>Innodb 存储引擎支持 B+树索引、全文索引和哈希索引。其中 Innodb 存储引擎支持的哈希索引是自适应的，Innodb 存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预。B+树索引是关系型数据库中最常见的一种索引，也将是本文的主角。</p>
<h3 id="数据结构">数据结构</h3>
<p>在前文简单介绍了有序数组和二叉搜索树，对二分查找法和二叉树有了基本了解。B+树的定义相对复杂，在理解索引工作机制上无须深入、只需理解数据组织形式和查找算法即可。我们可以简单的认为 B+树是一种 N 叉树和有序数组的结合体。<br><br>
<br>例如:<br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/B%2b%e6%a0%91%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.png" alt="B+树数据结构"><br>
B+树的 3 个优点:</p>
<ol>
<li>层级更低，IO 次数更少</li>
<li>每次都需要查询到叶子节点，查询性能稳定</li>
<li>叶子节点形成有序链表，范围查询方便</li>
</ol>
<h3 id="操作算法">操作算法</h3>
<ul>
<li>查找</li>
</ul>
<p>由根节点自顶向下遍历树，根据分离值在要查找的一边的指针；在节点内使用二分查找来确定位置。</p>
<ul>
<li>插入</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%e6%8f%92%e5%85%a5.jpg" alt="插入"></p>
<ul>
<li>删除</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%e5%88%a0%e9%99%a4.jpg" alt="删除"></p>
<p>填充因子（innodb_fill_factor）：索引构建期间填充的每个 B-tree 页面上的空间百分比，其余空间保留给未来索引增长。从插入和删除操作中可以看到填充因子的值会影响到数据页的 split 和 merge 的频率。将值设置小些，可以减少 split 和 merge 的频率，但是索引相对会占用更多的磁盘空间；反之，则会增加 split 和 merge 的频率，但是可以减少占用磁盘空间。Innodb 对于聚集索引默认会预留 1/16 的空间保证后续的插入和升级索引。</p>
<h1>Innodb B+树索引</h1>
<p>前文介绍了索引的基本数据结构，现在开始我们从 Innodb 的角度了解如何使用 B+树构建索引，索引如何工作和如何使用索引提升查找效率。</p>
<h2 id="聚集索引和非聚集索引">聚集索引和非聚集索引</h2>
<p>数据库中的 B+树索引可以分为聚集索引和非聚集索引。聚集索引和非聚集索引的不同点在于叶子节点是否是完整行数据。<br><br><br>
Innodb 存储引擎表是索引组织表，即表中的数据按照主键顺序存放。聚集索引就是按照每张表的主键构造一棵 B+树，叶子节点存放的是表的完整行记录。非聚集索引的叶子节点不包含行记录的全部数据。Innodb 存储引擎的非聚集索引的叶子节点的内容为主键索引值。<br><br><br>
若数据表没有主键聚集索引是怎么建立的？在没有主键时 Innodb 会给数据表的每条记录生成一个 6 个字节长度的 RowId 字段，会以此建立聚集索引。</p>
<h2 id="Select-语句查找记录的过程">Select 语句查找记录的过程</h2>
<p>下面例子将展示索引数据的组织形式及 Select 语句查询数据的过程。</p>
<ul>
<li>建表语句：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">    ID <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    k <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    s <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    index k(k)</span><br><span class="line">) engine<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>, <span class="number">1</span>, <span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>, <span class="number">2</span>, <span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>, <span class="number">3</span>, <span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>, <span class="number">5</span>, <span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>索引结构示意</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84%e7%a4%ba%e6%84%8f.png" alt="索引结构示意"><br>
左边是以主键 ID 建立起的聚集索引，其叶子节点存储了完整的表记录信息；右边是以普通字段 K 建立的普通索引，其叶子节点的值是主键 ID。</p>
<ul>
<li>Select 语句执行过程</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> k <span class="keyword">between</span> <span class="number">3</span> <span class="keyword">and</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>执行流程如下:</p>
<ol>
<li>在 K 索引树上找到 k=3 的记录，取得 ID=300；</li>
<li>再到 ID 索引树上查找 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。<br>
上述查找记录的过程中引入了一个重要的概念：<b>回表</b>，即回到主键索引树搜索的过程。避免回表操作是提升 SQL 查询效率的常规思路及重要方法。那么如何避免回表？</li>
</ol>
<h2 id="覆盖索引">覆盖索引</h2>
<p>MySQL 5.7,建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@employees</span> <span class="operator">%</span>&#125; (</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@emp</span>_no <span class="operator">%</span>&#125; <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@birth</span>_date <span class="operator">%</span>&#125; <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@first</span>_name <span class="operator">%</span>&#125; <span class="type">varchar</span>(<span class="number">14</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@last</span>_name <span class="operator">%</span>&#125; <span class="type">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@gender</span> <span class="operator">%</span>&#125; enum(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;F&#x27;</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@hire</span>_date <span class="operator">%</span>&#125; <span class="type">date</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@emp</span>_no <span class="operator">%</span>&#125;),</span><br><span class="line">  KEY &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@i</span>_first_name <span class="operator">%</span>&#125; (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@first</span>_name <span class="operator">%</span>&#125;),</span><br><span class="line">  KEY &#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@i</span>_hire_date <span class="operator">%</span>&#125; (&#123;<span class="operator">%</span> label <span class="keyword">primary</span><span class="variable">@hire</span>_date <span class="operator">%</span>&#125;)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL 语句 A</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>explain 结果：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql3.png" alt="sql3"></p>
<ul>
<li>SQL 语句 B</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> emp_no <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>explain 结果：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql4.png" alt="sql4"></p>
<ul>
<li>分析</li>
</ul>
<p>从前后两次 explain 的结果可以看到 SQL 语句 A 的 extra 为 using where，SQL 语句 B 的 extra 为 using where;using index。这说明 A 没有使用索引，而 B 使用了索引。<br><br><br>
索引 K 中包含了查询语句所需要的字段 ID 的值，无需再次回到主键索引树查找，也就是“覆盖”了我们的查询需求，我们称之为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能。</p>
<h2 id="最左匹配">最左匹配</h2>
<ul>
<li>SQL 语句 A</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>explain 结果：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql5.png" alt="sql5"></p>
<ul>
<li>SQL 语句 B</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>explain 结果：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql6.png" alt="sql6"></p>
<ul>
<li>分析</li>
</ul>
<p>在上述测试的 SQL 语句 A 使用了极端方式: first_name like ‘%Hi%’，前后都增加模糊匹配使得 SQL 语句无法使用到索引；当去掉最左边的‘%’后，SQL 语句 B 就使用了索引。最左匹配可以是字符串索引的最左 N 个字符，也可以是联合索引的最左 M 的字段。合理规划、使用最左匹配可以减少索引，从而节约磁盘空间。</p>
<h2 id="索引下推">索引下推</h2>
<p>何为索引下推？我们先从下面这组对比测试开始，将在 MySQL5.5 版本和 MySQL5.7 版本中执行同一条 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 MySQL 5.5 执行 explain，extra 字段的值显示没有使用索引</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql7.png" alt="sql7"><br>
执行查询花费时间为 0.12s<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql8.png" alt="sql8"></p>
<ul>
<li>在 MySQL 5.7 执行 explain，extra 字段的值显示使用了索引下推</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql9.png" alt="sql9"><br>
执行查询花费时间为 0.02s<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql10.png" alt="sql10"></p>
<ul>
<li>索引下推</li>
</ul>
<p>explain 结果中的 extra 字段值包含 using index condition，则说明使用了索引下推。索引下推功能是从 5.6 版本开始支持的。在 5.6 版本之前，i_first_name 索引是没有使用上的，需要每次去主键索引表取完整的记录值进行比较。从 5.6 版本开始，由于索引 i_first_name 的存在，可以直接取索引的 first_name 值进行过滤，这样不符合&quot;first_name like ‘Hi%’&quot;条件的记录就不再需要回表操作。</p>
<h2 id="MRR-优化">MRR 优化</h2>
<p>MySQL 5.6 版本开始支持 Multi-Range Read(MRR)优化，MRR 优化的目的是为减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于 IO-bound 类型的 SQL 查询语句可带来性能极大提升。我们先看下对比测试，以下测试语句在同一个 MySQL 实例下执行，执行前均进行 mysql 服务重启，以保证缓存此没被预热。</p>
<ul>
<li>关闭 MRR</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@optimizer</span>_switch<span class="operator">=</span><span class="string">&#x27;mrr=off&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>执行耗时为 0.90s<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql11.png" alt="sql11"></p>
<ul>
<li>开启 MRR</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="variable">@optimizer</span>_switch<span class="operator">=</span><span class="string">&#x27;mrr=off&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@optimizer</span>_switch<span class="operator">=</span><span class="string">&#x27;mrr=on,mrr_cost_based=off&#x27;</span>;</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1990-01-14&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;Hi%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>执行耗时为 0.03s<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql12.png" alt="sql12"></p>
<ul>
<li>分析</li>
</ul>
<p>从测试结果可以发现在 mrr 从关闭到开启，耗时从 0.90s 减少到 0.03s，查询速率达到 30 倍的提升。</p>
<h1>常见的索引失效场景</h1>
<p>在 MySQL 表中建立了索引，SQL 查询语句就会一定使用到索引么？不一定，存在着索引失效的场景。我们给 employees 表增一个组合索引，后续例子均基于此表进行分析、测试。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> index i_b_f_l(birth_date, first_name, last_name)</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> index i_h(hire_date);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql13.png" alt="sql13"></p>
<h2 id="失效场景">失效场景</h2>
<ul>
<li>范围查询（&gt;,&lt;,&lt;&gt;）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1989-06-02&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql14.png" alt="sql14"></p>
<ul>
<li>查询条件类型不一致</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employees <span class="keyword">add</span> index i_first_name (first_name);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> first_name <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql15.png" alt="sql15"></p>
<ul>
<li>查询条件使用了函数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> <span class="keyword">CHAR_LENGTH</span>(hire_date) <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql16.png" alt="sql16"></p>
<ul>
<li>模糊查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date  <span class="keyword">like</span>  <span class="string">&#x27;%1995&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql17.png" alt="sql17"></p>
<ul>
<li>不使用组合索引的首个字段当条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="operator">=</span> <span class="string">&#x27;Kalloufi&#x27;</span> <span class="keyword">and</span> first_name <span class="operator">=</span> <span class="string">&#x27;Saniya&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql18.png" alt="sql18"></p>
<h2 id="为什么会失效">为什么会失效</h2>
<ul>
<li>顺序读比离散读性能要好<br><br>
范围查询一定会导致索引失效么？<br><br>
并不会！稍微更改下查询条件看下 explain 的对比结果，可以看到新语句用到索引下推，说明索引并未失效。为什么？<br><br>
在不使用覆盖索引的情况下，优化器只有在数据量小的时候才会选择使用非聚集索引。受制于传统的机械磁盘特性，通过聚集索引顺序读数据行的性能会比通过非聚集索引离散读数据行要好。所以，优化器在即使有非聚集索引、但是访问数据量可能达到送记录数的 20%时会选择聚集索引。当然也可以用 Force index 强制使用索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> hire_date <span class="operator">&gt;</span> <span class="string">&#x27;1999-06-02&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql19.png" alt="sql19"></p>
<ul>
<li>无法使用 B+索引快速查找<br><br>
B+树索引支持快速查询的基本要素是因为其索引键值是有序存储的，从左到右由小到大，这样就可以在每个层级的节点中快速查并进入下一层级，最终在叶子节点找到对应的值。<br><br>
使用函数会使得 MySQL 无法使用索引进行快速查询，因为对索引字段做函数操作会破坏索引值的有序性，所以优化器选择不使用索引。而查询条件类型不一致其实也是同样的情况，因为其使用了隐式类型转换*。</li>
</ul>
<p>模糊匹配和不使用组合索引的首字段作为查询条件均是无法快速定位索引位置从而导致无法使用索引。模糊匹配当查询条件是 lwhere A ike ‘a%’，a 是 A 的最左前缀时是可能用上索引的（最左匹配），是否用上最终还是依赖优化器对查询数据量的评估。</p>
<h1>回到初始的案例</h1>
<p>让我们回到文章初的案例，尝试回答下当时提出的 3 个问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- A语句</span></span><br><span class="line"><span class="keyword">SELECT</span> FStatDate, FMerchantId, FVersion, FBatch, FTradeAmount, FTradeCount <span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020 <span class="keyword">WHERE</span> FStatDate <span class="operator">=</span> <span class="number">20201020</span>     <span class="keyword">AND</span> FVersion <span class="operator">=</span> <span class="number">0</span>     <span class="keyword">AND</span> FMerchantId <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> LIMIT <span class="number">0</span>, <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- B语句</span></span><br><span class="line"><span class="keyword">SELECT</span> SQL_CALC_FOUND_ROWS a1.FStatDate,</span><br><span class="line">    a1.FMerchantId,</span><br><span class="line">    a1.FVersion,</span><br><span class="line">    FBatch,</span><br><span class="line">    FTradeAmount,</span><br><span class="line">    FTradeCount</span><br><span class="line"><span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020 a1, (</span><br><span class="line">    <span class="keyword">SELECT</span> FStatDate, FMerchantId, FVersion</span><br><span class="line">    <span class="keyword">FROM</span> T_Mch<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span>Stat_1020</span><br><span class="line">    <span class="keyword">WHERE</span> FStatDate <span class="operator">=</span> <span class="number">20201020</span></span><br><span class="line">        <span class="keyword">AND</span> FVersion <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">AND</span> FMerchantId <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> FMerchantId <span class="keyword">ASC</span> LIMIT <span class="number">0</span>, <span class="number">8000</span> ) a2</span><br><span class="line"><span class="keyword">where</span> a1.FStatDate <span class="operator">=</span> a2.FStatDate</span><br><span class="line">    <span class="keyword">and</span> a1.FVersion <span class="operator">=</span> a2.FVersion</span><br><span class="line">    <span class="keyword">and</span> a1.FMerchantId <span class="operator">=</span> a2.FMerchantId;</span><br></pre></td></tr></table></figure>
<p><b>SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？</b><br></p>
<ul>
<li>主键索引其实是有被使用的：索引的范围查询，只是其需要逐条读取和解析所有记录才导致慢查询。<br></li>
</ul>
<p><b>SQL 语句 B 的子查询为什么能够用到索引？</b><br></p>
<ol>
<li>前文中我们介绍了聚集索引，其索引键值就是主键。</li>
<li>两条 SQL 语句的不同之处在于 B 语句的子查询语句的 Select 字段都包含在主键字段中，而 A 语句还有其它字段（例如 FBatch 和 FTradeAmount 等）。这种情况下只凭主键索引的键值就能满足 B 语句的字段要求；A 语句则需要逐条取整行记录进行解析。<br></li>
</ol>
<p><b>前后两条语句执行流程的差异是什么？</b><br></p>
<ul>
<li>SQL 语句 A 的执行过程：
<ol>
<li>逐条扫描索引表并比较查询条件</li>
<li>遇到符合查询条件的则读取整行数据返回</li>
<li>回到 a 步骤，直至完成所有索引记录的比较</li>
<li>对返回的所有符合条件的记录（完整的记录）进行排序</li>
<li>选取前 8000 条数据返回</li>
</ol>
</li>
<li>SQL 语句 B 的执行过程：
<ol>
<li>逐条扫描索引表并比较查询条件</li>
<li>遇到符合查询条件的则从索引键中取相关字段值返回</li>
<li>回到 a 步骤，直至完成所有索引记录的比较</li>
<li>对返回的所有符合条件的记录（每条记录只有 3 个主键）进行排序</li>
<li>选取前 8000 条数据返回形成临时表</li>
<li>关联临时表与主表，使用主键相等比较查询 8000 条数据</li>
</ol>
</li>
<li>对比两个 SQL 语句的执行过程，可以发现差异点集中在步骤 2 和步骤 4。在步骤 2 中 SQL 语句 A 需要随机读取整行数据并解析非常耗资源；步骤 4 涉及 MySQL 的排序算法，这里也会对执行效率有影响，排序效果上看 SQL 语句 B 比 SQL 语句 A 好。</li>
</ul>
<p><img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/sql20.png" alt="sql20"></p>
<h1>名词解释</h1>
<ul>
<li>主键索引</li>
<li>顾名思义该类索引由表的主键组成，从左到右由小到大排序。一个 Innodb 存储表只有一张主键索引表（聚集索引）。</li>
<li>普通索引</li>
<li>最为平常的一种索引，没有特别限制。</li>
<li>唯一索引</li>
<li>该索引的字段不能有相同值，但允许有空值。</li>
<li>组合索引</li>
<li>由多列字段组合而成的索引，往往是为了提升查询效率而设置。</li>
</ul>
<h1>总结</h1>
<p>在文章开始时介绍了常见的几种索引数据结构，适合静态数据的有序数组、适合 KV 结构的哈希索引及兼顾查询及插入性能的搜索二叉树；然后介绍了 Innodb 的常见索引实现方式 B+树及 Select 语句使用 B+树索引查找记录的执行过程，在这个部分我们了解了几个关键的概念，回表、覆盖索引、最左匹配、索引下推和 MMR；之后还总结了索引的失效场景及背后的原因。最后，我们回到最初的案例，分析出优化前后 SQL 语句在使用索引的差异，进而导致执行效率的差异。<br><br><br>
本文介绍了索引的一些粗浅知识，希望能够对读者有些许帮助。作为阶段性学习的一个总结，文章对 MySQL 索引的相关知识基本上是浅藏辄止，日后还需多多使用和深入学习。<br><br><br>
何以解忧？唯有学习。<br><br><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/%e6%80%9d%e7%bb%b4%e5%af%bc%e5%9b%be.png" alt="思维导图"></p>
<h1>餐卡书目和资料</h1>
<ul>
<li>《MySQL 技术内幕-InnoDB 存储引擎》第二版，作者：姜承尧</li>
<li>《MySQL 实战 45 讲》，作者：林晓斌</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/">https://dev.mysql.com/doc/refman/8.0/en/</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">https://zh.wikipedia.org/wiki/二元搜尋樹</a></li>
<li>重温数据结构：理解 B 树、B+ 树特点及使用场景 - Android</li>
<li><a href="https://github.com/zhangyachen/zhangyachen.github.io/issues/117">https://github.com/zhangyachen/zhangyachen.github.io/issues/117</a></li>
</ul>
]]></content>
      <categories>
        <category>转发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/RegExp/</url>
    <content><![CDATA[<div class="note primary"><p>文章原出处为 &lt;腾讯技术工程&gt; 公众号<br>
作者：mathe，腾讯 QQ 音乐前端开发工程师</p>
</div>
<h1>正则常见规则</h1>
<h2 id="字符匹配">字符匹配</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">|转义符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">[0-9]。表示是一位数字。</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">[^0-9]。表示除数字外的任意字符。</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">[0-9a-zA-Z_]。表示数字、大小写字母和下划线。</td>
</tr>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">[^0-9a-za-z_]。非单词字符。</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">[\t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">[^\t\v\n\r\f]。非空白符。</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">[^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。</td>
</tr>
<tr>
<td style="text-align:left">\uxxxx</td>
<td style="text-align:left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
<tr>
<td style="text-align:left">\f</td>
<td style="text-align:left">匹配一个换页符 (U+000C)。</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">匹配一个换行符 (U+000A)。</td>
</tr>
<tr>
<td style="text-align:left">\r</td>
<td style="text-align:left">匹配一个回车符 (U+000D)。</td>
</tr>
<tr>
<td style="text-align:left">\t</td>
<td style="text-align:left">匹配一个水平制表符 (U+0009)。</td>
</tr>
<tr>
<td style="text-align:left">\v</td>
<td style="text-align:left">匹配一个垂直制表符 (U+000B)。</td>
</tr>
<tr>
<td style="text-align:left">\0</td>
<td style="text-align:left">匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 \0 是一个八进制转义序列。</td>
</tr>
<tr>
<td style="text-align:left">[\b]</td>
<td style="text-align:left">匹配一个退格(U+0008)。（不要和\b 混淆了。）</td>
</tr>
<tr>
<td style="text-align:left">[abc]</td>
<td style="text-align:left">any of a, b, or c</td>
</tr>
<tr>
<td style="text-align:left">[^abc]</td>
<td style="text-align:left">not a, b, or c</td>
</tr>
<tr>
<td style="text-align:left">[a-g]</td>
<td style="text-align:left">character between a &amp; g</td>
</tr>
</tbody>
</table>
<h2 id="位置匹配">位置匹配</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">是单词边界，具体就是\w 和\W 之间的位置，也包括\w 和 ^ 之间的位置，也包括\w 和$之间的位置。\b 匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在) \w</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">是\b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B 的。</td>
</tr>
<tr>
<td style="text-align:left">^abc$</td>
<td style="text-align:left">字符串开始、结束的位置</td>
</tr>
</tbody>
</table>
<h2 id="组">组</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(abc)</td>
<td style="text-align:left">capture group，捕获组</td>
</tr>
<tr>
<td style="text-align:left">\n</td>
<td style="text-align:left">backreference to group #n，分组引用，引用第 n 个捕获组匹配的内容,其中 n 是正整数</td>
</tr>
<tr>
<td style="text-align:left">(?:abc)</td>
<td style="text-align:left">non-capturing group，非捕获组</td>
</tr>
</tbody>
</table>
<h2 id="先行断言">先行断言</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a(?=b)</td>
<td style="text-align:left">positive lookahead，先行断言，a 只有在 b 前面才匹配</td>
</tr>
<tr>
<td style="text-align:left">a(?!b)</td>
<td style="text-align:left">negative lookahead，先行否定断言，a 只有不在 b 前面才匹配</td>
</tr>
</tbody>
</table>
<h2 id="后行断言">后行断言</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">(?&lt;=b)a</td>
<td style="text-align:left">positive lookbehind，后行断言，a 只有在 b 后面才匹配</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;!b)a</td>
<td style="text-align:left">negative lookbehind，后行否定断言，a 只有不在 b 后面才匹配</td>
</tr>
</tbody>
</table>
<h2 id="量词和分支">量词和分支</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a*</td>
<td style="text-align:left">0 or more</td>
</tr>
<tr>
<td style="text-align:left">a+</td>
<td style="text-align:left">1 or more</td>
</tr>
<tr>
<td style="text-align:left">a?</td>
<td style="text-align:left">0 or 1</td>
</tr>
<tr>
<td style="text-align:left">a{5}</td>
<td style="text-align:left">exactly five</td>
</tr>
<tr>
<td style="text-align:left">a{2,}</td>
<td style="text-align:left">two or more</td>
</tr>
<tr>
<td style="text-align:left">a{1,3}</td>
<td style="text-align:left">between one &amp; three</td>
</tr>
<tr>
<td style="text-align:left">a+?,a{2,}?</td>
<td style="text-align:left">match as few as possible，惰性匹配，就是尽可能少的匹配</td>
</tr>
</tbody>
</table>
<p>以下都是惰性匹配:</p>
<table><thead><tr><th style="text-align:center">{m,n}?</th><th style="text-align:center">{m,}?</th><th style="text-align:center">??</th><th style="text-align:center">+?</th><th style="text-align:center">*?</th></tr></thead></table>
<h2 id="分支">分支</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ab | cd</td>
<td style="text-align:left">match ab or cd，匹配’ab’或者’cd’字符子串</td>
</tr>
</tbody>
</table>
<h2 id="修饰符">修饰符</h2>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td style="text-align:left">g</td>
<td style="text-align:left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td style="text-align:left">m</td>
<td style="text-align:left">执行多行匹配。</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">开启&quot;Unicode 模式&quot;，用来正确处理大于\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">允许 . 匹配换行符。</td>
</tr>
<tr>
<td style="text-align:left">y</td>
<td style="text-align:left">y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是&quot;粘连&quot;的涵义</td>
</tr>
</tbody>
</table>
<h1>运算符优先级</h1>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">|转义符</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">(), (?:), (?=), []</td>
<td style="text-align:left">圆括号和方括号</td>
</tr>
<tr>
<td style="text-align:center">*, +, ?, {n}, {n,}, {n,m}</td>
<td style="text-align:left">限定符</td>
</tr>
<tr>
<td style="text-align:center">^, $, \任何元字符、任何字符</td>
<td style="text-align:left">定位点和序列（即：位置和顺序）</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:left">替换，“或&quot;操作字符具有高于替换运算符的优先级，使得&quot;m|food&quot;匹配&quot;m&quot;或&quot;food”。若要匹配&quot;mood&quot;或&quot;food&quot;，请使用括号创建子表达式，从而产生&quot;(m|f)ood&quot;。</td>
</tr>
</tbody>
</table>
<h1>正则回溯</h1>
<h2 id="什么是回溯算法">什么是回溯算法</h2>
<p>以下是来自摘自维基百科的部分解释：</p>
<blockquote>
<p>回溯法是一种通用的计算机算法，用于查找某些计算问题的所有（或某些）解决方案，特别是约束满足问题，逐步构建候选解决方案，并在确定候选不可能时立即放弃候选（“回溯”）完成有效的解决方案。<br>
回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
</blockquote>
<h2 id="什么是正则回溯">什么是正则回溯</h2>
<p>正则引擎主要可以分为两大类：一种是 DFA(Deterministic finite automaton 确定型有穷自动机)，另一种是 NFA（NFA Non-deterministic finite automaton 　非确定型有穷自动机）。NFA 速度较 DFA 更慢，并且实现复杂，但是它又有着比 DFA 强大的多的功能，比如支持反向引用等。像 javaScript、java、php、python、c#等语言的正则引擎都是 NFA 型，NFA 正则引擎的实现过程中使用了回溯。</p>
<h3 id="没有回溯的正则">没有回溯的正则</h3>
<p>举一个网上常见的例子，正则表达式/ab{1,3}c/g 去匹配文本’abbc’，我们接下来会通过 RegexBuddy 分析其中的匹配过程，后续的一个章节有关于 RegexBuddy 的使用介绍。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp1.png" alt=""><br>
如上图所示，让我们一步一步分解匹配过程：</p>
<ol>
<li>正则引擎先匹配 a。</li>
<li>正则引擎尽可能多地(贪婪)匹配 b。</li>
<li>正则引擎匹配 c，完成匹配。</li>
</ol>
<p>在这之中，匹配过程都很顺利，并没发生意外(回溯)。</p>
<h3 id="有正则回溯的正则">有正则回溯的正则</h3>
<p>让我们把上面的正则修改一下，/ab{1,3}c/g 改成/ab{1,3}bc/g，接下再通过 RegexBuddy 查看分析结果。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp2.png" alt=""><br>
我们再一步一步分解匹配过程：</p>
<ol>
<li>正则引擎先匹配 a。</li>
<li>正则引擎尽可能多地(贪婪)匹配 b{1,3}中的 b。</li>
<li>正则引擎去匹配 b，发现没 b 了，糟糕！赶紧回溯！</li>
<li>返回 b{1,3}这一步，不能这么贪婪，少匹配个 b。</li>
<li>正则引擎去匹配 b。</li>
<li>正则引擎去匹配 c，完成匹配。<br>
以上，就是一个简单的回溯过程。</li>
</ol>
<h2 id="正则回溯的几种常见形式">正则回溯的几种常见形式</h2>
<p>从上面发生正则回溯的例子可以看出来，正则回溯的过程就是一个试错的过程，这也是回溯算法的精髓所在。回溯会增加匹配的步骤，势必会影响文本匹配的性能，所以，要想提升正则表达式的匹配性能，了解回溯出现的场景(形式)是非常关键的</p>
<h3 id="贪婪量词">贪婪量词</h3>
<p>在 NFA 正则引擎中，量词默认都是贪婪的。当正则表达式中使用了下表所示的量词，正则引擎一开始会尽可能贪婪的去匹配满足量词的文本。当遇到匹配不下去的情况，就会发生回溯，不断试错，直至失败或者成功。</p>
<table>
<thead>
<tr>
<th style="text-align:left">量词</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a*</td>
<td style="text-align:left">0 or more</td>
</tr>
<tr>
<td style="text-align:left">a+</td>
<td style="text-align:left">1 or more</td>
</tr>
<tr>
<td style="text-align:left">a?</td>
<td style="text-align:left">0 or 1</td>
</tr>
<tr>
<td style="text-align:left">a{5}</td>
<td style="text-align:left">exactly five</td>
</tr>
<tr>
<td style="text-align:left">a{2,}</td>
<td style="text-align:left">two or more</td>
</tr>
<tr>
<td style="text-align:left">a{1,3}</td>
<td style="text-align:left">between one &amp; three</td>
</tr>
</tbody>
</table>
<p>当多个贪婪量词挨着存在，并相互有冲突时，秉持的是&quot;先到先得&quot;的原则，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/(\d&#123;1,3&#125;)(\d&#123;1,3&#125;)/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">match</span>(regex));</span><br><span class="line"><span class="comment">// =&gt; [&quot;12345&quot;, &quot;123&quot;, &quot;45&quot;, index: 0, input: &quot;12345&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="惰性量词">惰性量词</h3>
<p>贪婪是导致回溯的重要原因，那我们尽量以懒惰匹配的方式去匹配文本，是否就能避免回溯了呢？答案是否定的。<br>
让我们还是看回最初的例子，/ab{1,3}c/g 去匹配 abbc。接下来，我们再把正则修改一下，改成/ab{1,3}?c/g 去匹配 abbc，以懒惰匹配的方式去匹配文本，RegexBuddy 执行步骤如下图所示：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp3.png" alt=""></p>
<ol>
<li>正则引擎先匹配 a。</li>
<li>正则引擎尽可能少地(懒惰)匹配 b{1,3}中的 b。</li>
<li>正则引擎去匹配 c，糟糕！怎么有个 b 挡着，匹配不了 c 啊！赶紧回溯！</li>
<li>返回 b{1,3}这一步，不能这么懒惰，多匹配个 b。</li>
<li>正则引擎再去匹配 c，糟糕！怎么还有 b 挡着，匹配不了 c 啊！赶紧回溯！</li>
<li>返回 b{1,3}这一步，不能这么懒惰，再多匹配个 b。</li>
<li>正则引擎再去匹配 c，匹配成功，棒棒哒！</li>
</ol>
<p>本来是好端端不会发生回溯的正则，因为使用了惰性量词进行懒惰匹配后，反而产生了回溯了。所以说，惰性量词也不能瞎用，关键还是要看场景。</p>
<h3 id="分组">分组</h3>
<p>分支的匹配规则是：按照分支的顺序逐个匹配，当前面的分支满足要求了，则舍弃后面的分支。<br>
举个简单的分支栗子，使用正则表达式去匹配 /abcde|abc/g 文本 abcd，还是通过 RegexBuddy 查看执行步骤：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp4.png" alt=""></p>
<ol>
<li>正则引擎匹配 a。</li>
<li>正则引擎匹配 b。</li>
<li>正则引擎匹配 c。</li>
<li>正则引擎匹配 d。</li>
<li>正则引擎匹配 e，糟糕！下一个并不是 e，赶紧回溯！</li>
<li>上一个分支走不通，切换分支，第二个分支正则引擎匹配 a。</li>
<li>第二个分支正则引擎匹配 b。</li>
<li>第二个分支正则引擎匹配 c，匹配成功！<br>
由此，可以看出，分组匹配的过程，也是个试错的过程，中间是可能产生回溯的。</li>
</ol>
<h1>正则的分析与调试</h1>
<p>RegexBuddy 是个十分强大的正则表达式学习、分析及调试工具。RegexBuddy 支持 C++、Java、JavaScript、Python 等十几种主流编程语言。通过 RegexBuddy，能看到正则一步步创建的过程。结合测试文本，你能看到正则一步步执行匹配的过程，这对于理解正则回溯和对正则进行进一步优化，都有极大的帮助。</p>
<h2 id="安装分析调试工具">安装分析调试工具</h2>
<p>可以在 RegexBuddy 的<a href="https://www.regexbuddy.com/">官方网站</a>下载及获取 RegexBuddy。<br>
下载完后，一步步点击安装即可。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp5.png" alt=""></p>
<h2 id="工具界面介绍">工具界面介绍</h2>
<p>下图便是 RegexBuddy 界面的各个面板及相关功能。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp6.png" alt=""></p>
<h2 id="创建正则">创建正则</h2>
<p>为了方便使用，可以在布局设置那里将布局设置成 Side by Side Layout。<br>
在正则输入区输入你的正则 regex1，查看 Create 面板，就会发现面板上显示了正则的创建过程(或者说是匹配规则)，在 Test 面板区域输入你的测试文本，满足 regex1 匹配规则的部分会高亮显示，如下图所示。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp7.jpg" alt=""></p>
<h2 id="使用-RegexBuddy-的-Debug-功能">使用 RegexBuddy 的 Debug 功能</h2>
<p>选中测试文本，点击 debug 就可以进入 RegexBuddy 的 debug 模式，个人觉得这是 RegexBuddy 最强大地方，因为它可以让你清楚地知道你输入的正则对测试文本的匹配过程，执行了多少步，哪里发生了回溯，哪里需要优化，你都能一目了然。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp8.png" alt=""></p>
<h2 id="使用-RegexBuddy-的-Library-功能">使用 RegexBuddy 的 Library 功能</h2>
<p>RegexBuddy 的正则库内置了很多常用正则，日常编码过程中需要的很多正则表达式都能在该正则库中找到。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp9.png" alt=""></p>
<h2 id="更多工具推荐">更多工具推荐</h2>
<ul>
<li>正则可视化-regexper</li>
<li>正则可视化-regulex</li>
<li>正则在线调试</li>
</ul>
<h1>正则性能优化</h1>
<p>正则是个很好用的利器，如果使用得当，如有神助，能省掉大量代码。当如果使用不当，则是处处埋坑。所以，本章节的重点就是总结如何写一个高性能的正则表达式。</p>
<h2 id="避免量词嵌套">避免量词嵌套</h2>
<p>举个简单的例子对比：<br>
我们使用正则表达式/a<em>b/去匹配字符串 aaaaa，看下图 RegexBuddy 的执行过程：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp10.png" alt=""><br>
我们将以上正则修改成/(a</em>)*b/去匹配字符串 aaaaa，再看看 RegexBuddy 的执行结果过程：<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp11.png" alt=""><br>
以上两个正则的基本执行步骤可以简单认为是：</p>
<ol>
<li>贪婪匹配</li>
<li>回溯</li>
<li>直至发现匹配失败<br>
但令人惊奇的是，第一个正则的从开始匹配到匹配失败这个过程只有 14 步。而第二个正则却有 128 步之多。可想而知，嵌套量词会大大增加正则的执行过程。因为这其中进行了两层回溯，这个执行步骤增加的过程就如同算法复杂度从 O(n)上升到 O(n^2)的过程一般。<br>
所以，面对量词嵌套，我们需作出适当的转化消除这些嵌套</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a*)* &lt;=&gt; (a+)* &lt;=&gt; (a*)+ &lt;=&gt; a*</span><br><span class="line">(a+)+ &lt;=&gt; a+</span><br></pre></td></tr></table></figure>
<h2 id="使用非捕获组">使用非捕获组</h2>
<p>NFA 正则引擎中的括号主要有两个作用：</p>
<ol>
<li>主流功能，提升括号中内容的运算优先级</li>
<li>反向引用</li>
</ol>
<p>反向引用这个功能很强大，强大的代价是消耗性能。所以，当我们如果不需要用到括号反向引用的功能时，我们应该尽量使用非捕获组，也就是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 捕获组与非捕获组</span><br><span class="line">() =&gt; (?:)</span><br></pre></td></tr></table></figure>
<h2 id="分支优化">分支优化</h2>
<p>分支也是导致正则回溯的重要原因，所以，针对正则分支，我们也需要作出必要的优化。</p>
<h3 id="减少分支数量">减少分支数量</h3>
<p>首先，需要减少分支数量。比如不少正则在匹配 http 和 https 的时候喜欢写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/^http|https/;</span><br></pre></td></tr></table></figure>
<p>其实上面完全可以优化成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/^https?/;</span><br></pre></td></tr></table></figure>
<p>这样就能减少没必要的分支回溯</p>
<h3 id="缩小分支内的内容">缩小分支内的内容</h3>
<p>缩小分支中的内容也是很有必要的，例如我们需要匹配 this 和 that ，我们也许会写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/this|that/;</span><br></pre></td></tr></table></figure>
<p>但上面其实完全可以优化成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/th(?:is|at)/;</span><br></pre></td></tr></table></figure>
<p>有人可能认为以上没啥区别，实践出真知，让我们用以上两个正则表达式去匹配一下 that。<br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp12.png" alt=""><br>
<img data-src="https://cdn.jsdelivr.net/gh/Kinsiy/cdn/KINSIY-PIC/RegExp13.png" alt=""><br>
我们会发现第一个正则的执行步骤比第一个正则多两步，那是因为第一个正则的回溯路径比第二个正则的回溯路径更长了，最终导致执行步骤变长。</p>
<h2 id="锚点优化">锚点优化</h2>
<p>在能使用锚点的情况下尽量使用锚点。大部分正则引擎会在编译阶段做些额外分析, 判断是否存在成功匹配必须的字符或者字符串。类似^、$ 这类锚点匹配能给正则引擎更多的优化信息。<br>
例如正则表达式 hello(hi)?$ 在匹配过程中只可能从字符串末尾倒数第 7 个字符开始, 所以正则引擎能够分析跳到那个位置, 略过目标字符串中许多可能的字符, 大大提升匹配速度。</p>
<h1>参考</h1>
<ul>
<li><a href="https://loveky.github.io/2017/05/31/regular-expressions-catastrophic-backtracking/?from=singlemessage">正则表达式中的悲观回溯</a></li>
<li><a href="https://mp.weixinbridge.com/mp/wapredirect?url=https%3A%2F%2Fjuejin.im%2Fentry%2F59f7f41ef265da4322407f37%3Ffrom%3Dsinglemessage&amp;action=appmsg_redirect&amp;uin=MjEyMjYyMzcxNg==&amp;biz=MjM5ODYwMjI2MA==&amp;mid=2649749963&amp;idx=1&amp;type=0&amp;scene=0">小心别落入正则回溯陷阱</a></li>
<li><a href="">正则匹配原理解析</a></li>
<li><a href="https://learncodethehardway.org/regex/">learncodethehardway</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27653434">正则表达式系列总结</a></li>
<li><a href="https://en.wikipedia.org/wiki/Backtracking">wikipedia Backtracking</a></li>
<li><a href="https://book.douban.com/subject/11589967/">精通正则表达式</a></li>
</ul>
]]></content>
      <categories>
        <category>转发</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript - Classes</title>
    <url>/Typescript-Classes/</url>
    <content><![CDATA[<p>Ts完全支持Es2015中的<mark class="label primary">class</mark>关键字.</p>
<div class="note info"><p>学习ES6中的类<a href="https://kinsiy.github.io/Javascript-Class/?highlight=%E7%B1%BB">Javascript - Class</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">MDN. Classes</a></p>
<p>本文参考Typescript官网<a href="https://www.typescriptlang.org/docs/handbook/2/classes.html">Docs - Handbook - Classes</a>自翻译而来, 仅供个人参考学习使用.一切请以官网为准!</p>
</div>
<h2 id="类成员">类成员</h2>
<p>来看示例(–strictPropertyInitialization)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">  y						<span class="comment">// [1] Error: Member &#x27;y&#x27; implicitly has an &#x27;any&#x27; type.</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span> 	<span class="comment">// [2] Property &#x27;y&#x27; has no initializer and is not definitely assigned in the constructor</span></span><br><span class="line">  z = <span class="number">0</span></span><br><span class="line">  <span class="attr">i</span>: <span class="built_in">string</span> = <span class="string">&quot;kinsiy&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">j</span> = <span class="number">2</span>	<span class="comment">// [3] Error: Property &#x27;j&#x27; does not exist on type &#x27;Point&#x27;.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point = <span class="keyword">new</span> <span class="title class_">Point</span>()</span><br><span class="line"></span><br><span class="line">point.<span class="property">z</span> = <span class="string">&quot;3&quot;</span> <span class="comment">// [4] Error: Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line">point.<span class="property">j</span> = <span class="string">&quot;xxx&quot;</span> <span class="comment">// [3] Error: Property &#x27;j&#x27; does not exist on type &#x27;Point&#x27;.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>通过示例中的四个错误, 学习 Ts 类</p>
<ol>
<li>Ts中对于未声明类型的成员, 会隐式的得到一个<mark class="label primary">any</mark>类型</li>
<li>成员变量必须初始化(配置strictPropertyInitialization)</li>
<li>不能对未声明的变量进行初始化</li>
<li>与普通的变量声明一样, 具有<a href="https://kinsiy.github.io/Typescript-TypeGuards/">类型推断</a></li>
</ol>
<p>对于第二个错误, 必须在定义成员时或<strong>构造方法中</strong>进行初始化,才不会报错,Ts不会检查构造方法调用的方法,因为这些方法可能会被派生类重新.从而导致未初始化. 如果你确定该变量一定会被初始化可以使用非空断言进行声明</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OKGreeter</span> &#123;</span><br><span class="line">  name!: <span class="built_in">string</span> <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问修饰符">访问修饰符</h3>
<h4 id="readonly">readonly</h4>
<p>只读成员,通过readonly修饰符声明. 只读成员在任何地方可读</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">otherName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (otherName !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = otherName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">err</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;not ok&quot;</span>;	<span class="comment">// Error: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="property">name</span> = <span class="string">&quot;also not ok&quot;</span>;	<span class="comment">// Error: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>
<h4 id="public">public</h4>
<p>公有成员,通过public修饰符声明.默认修饰符. 公有成员在任何地方都可以被读/写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>
<h4 id="protected">protected</h4>
<p>保护成员,通过protected修饰符声明. 保护成员<strong>只能在自身及其派生类内部读/写</strong>(实例不可见)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">getName</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialGreeter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Greeter</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">howdy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// OK to access protected member here</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Howdy, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">SpecialGreeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>(); <span class="comment">// OK</span></span><br><span class="line">g.<span class="title function_">_getName</span>()</span><br><span class="line">g.<span class="title function_">getName</span>();	<span class="comment">// Error: Property &#x27;getName&#x27; is protected and only accessible within class &#x27;Greeter&#x27; and its subclasses.</span></span><br></pre></td></tr></table></figure>
<h4 id="private">private</h4>
<p>私有成员, 通过private修饰符声明. 私有成员<strong>只能在该类内部读/写</strong>(实例不可见)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对实例不可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>)	<span class="comment">// Error: Property &#x27;x&#x27; is private and only accessible within class &#x27;Base&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对派生类不可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>) <span class="comment">// Error:Property &#x27;x&#x27; is private and only accessible within class &#x27;Base&#x27;.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能被派生类改变可见性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  <span class="comment">// Error: Class &#x27;_Derived&#x27; incorrectly extends base class &#x27;Base&#x27;.</span></span><br><span class="line">  <span class="comment">//				  Property &#x27;x&#x27; is private in type &#x27;Base&#x27; but not in type &#x27;_Derived&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ts与Java/C#/C++/Swift/PHP一样可以跨实例访问私有成员</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 能够跨实例访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sameAs</span>(<span class="params">other: A</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> other.<span class="property">x</span> === <span class="variable language_">this</span>.<span class="property">x</span>;	<span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意">注意</h4>
<p>上述修饰符仅在类型检查期间起作用,在编译成 Js 运行时你还是能够在对应实例上找到被<mark class="label primary">protected</mark>/<mark class="label primary">private</mark>的成员.被<mark class="label primary">readonly</mark>修饰的成员也能在运行时进行写操作.</p>
<p>并且在Ts类型检查阶段, 对于<mark class="label primary">protected</mark>/<mark class="label primary">private</mark>修饰的成员,可以通过中括号(obj[key])的方式逃过类型检查(<mark class="label primary">readonly</mark>不行)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">  <span class="keyword">protected</span> kinsiy = <span class="number">2212</span></span><br><span class="line">  <span class="keyword">readonly</span> qinglai = <span class="number">333</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">MySafe</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">secretKey</span>) <span class="comment">// Error: Property &#x27;secretKey&#x27; is private and only accessible within class &#x27;MySafe&#x27;.</span></span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="string">&quot;secretKey&quot;</span>]) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="string">&quot;kinsiy&quot;</span>]) <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">kinsiy</span>)</span><br><span class="line"></span><br><span class="line">s[<span class="string">&quot;qinglai&quot;</span>] = <span class="number">3333</span> <span class="comment">// Error: Cannot assign to &#x27;qinglai&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>
<p>要想实现硬私有,可以直接使用JS中的私有成员修饰符**(#)**</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">  #barkAmount = <span class="number">0</span>;</span><br><span class="line">  personality = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数">构造函数</h3>
<p>构造函数声明与一般函数声明几乎一样.只有两个小小的不同.</p>
<ul>
<li>不能使用泛型, 类的泛型在class关键字上声明,后面会介绍</li>
<li>不能有返回类型注解, 构造函数永远返回类实例</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重载</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>);</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">any</span>, y?: <span class="built_in">any</span></span>)  &#123;</span><br><span class="line">    x = <span class="title class_">Number</span>(x)</span><br><span class="line">    y = <span class="title class_">Number</span>(y)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以把成员声明放在构造函数中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">protected</span> y: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    <span class="keyword">private</span> z: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// No body necessary</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Params</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>) <span class="comment">// (property) Params.x: number</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">z</span>) <span class="comment">// Property &#x27;z&#x27; is private and only accessible within class &#x27;Params&#x27;.</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>与Js一样,在类构造函数中,不能在调用super()之前引用this</p>
</div>
<h3 id="方法">方法</h3>
<p>Ts中声明方法与Js中声明方法除类型注解外,其余部分完全一样.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">  y = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">scale</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> *= n;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> *= n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getters-Setters">Getters/Setters</h3>
<p>设置类成员的Getters/Setters时,需要注意几点</p>
<ul>
<li>仅设置getters, 成员自动变为仅读成员</li>
<li>如果未注解setters的参数类型,则其类型与getters返回类型一致</li>
<li>Getters/Setters必须拥有一样的成员可见性</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">  _size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">size</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="title class_">Number</span>(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t allow NaN, Infinity, etc</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(num)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="索引签名">索引签名</h3>
<p>与Interface等对象类型一样,类也支持索引签名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  [<span class="attr">s</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">check</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承-实现">继承/实现</h2>
<h3 id="implements">implements</h3>
<p>使用implements实现一个或多个接口.需要注意的是接口仅检查类是否可以被视为接口类型,不会更改类声明的类型.举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> _Checkable&#123;</span><br><span class="line">  <span class="title function_">_check</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">  <span class="title function_">check</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameChecker</span> <span class="keyword">implements</span> <span class="title class_">Checkable</span>, _Checkable &#123;</span><br><span class="line">  <span class="title function_">_check</span>(<span class="params">s</span>) &#123;	<span class="comment">// [1] Error: Parameter &#x27;s&#x27; implicitly has an &#x27;any&#x27; type.</span></span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toLowerCase</span>() === <span class="string">&quot;ok&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">check</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;	<span class="comment">// [2] Error</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="title class_">String</span>(n)</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">toLowerCase</span>() === <span class="string">&quot;ok&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Property &#x27;check&#x27; in type &#x27;NameChecker&#x27; is not assignable to the same property in base type &#x27;Checkable&#x27;.</span></span><br><span class="line"><span class="comment">  Type &#x27;(n: number) =&gt; boolean&#x27; is not assignable to type &#x27;(name: string) =&gt; boolean&#x27;.</span></span><br><span class="line"><span class="comment">    Types of parameters &#x27;n&#x27; and &#x27;name&#x27; are incompatible.</span></span><br><span class="line"><span class="comment">      Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>注意看[1][2]两个报错, [1]报的是‘s’是any类型而不是[2]的类型不符,也就是说_check()是符合接口约束的,但是参数’s’的类型并不会被接口改写为要求的<mark class="label primary">string</mark></p>
<h3 id="extends">extends</h3>
<p>与Js一样,Ts使用extends实现继承. 除类型注解外.差异不大</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(name?: <span class="built_in">string</span>):<span class="built_in">void</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类重写方法需要注意方法签名要与基类一致</p>
<h4 id="declare">declare</h4>
<p>当编译目标大于等于ES2022或–useDefineForClassFields时, 派生类声明的任何成员都会覆盖基类声明的值,当我们仅想在派生类中更具体化成员类型时.会直接覆盖基类初始值.这时可以使用<mark class="label primary">declare</mark>表面派生类声明不会产生任何运行时影响</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">dateOfBirth</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">breed</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="attr">resident</span>: <span class="title class_">Animal</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">animal: Animal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">resident</span> = animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogHouse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AnimalHouse</span> &#123;</span><br><span class="line">  <span class="comment">// Does not emit JavaScript code,</span></span><br><span class="line">  <span class="comment">// only ensures the types are correct</span></span><br><span class="line">  <span class="keyword">declare</span> <span class="attr">resident</span>: <span class="title class_">Dog</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">dog: Dog</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(dog);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化顺序">初始化顺序</h4>
<ol>
<li>基类成员初始化</li>
<li>执行基类构造函数</li>
<li>派生类成员初始化</li>
<li>执行派生类构造函数</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Prints &quot;base&quot;, not &quot;derived&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure>
<h2 id="静态成员">静态成员</h2>
<p>使用<mark class="label primary">static</mark>修饰符可声明静态成员.其性质与JS原生实现别无二致. 并且可以与<mark class="label primary">public</mark>,<mark class="label primary">protected</mark>,<mark class="label primary">private</mark>同时使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> x = <span class="number">0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> y = <span class="number">1</span>	<span class="comment">// 与 private 同时使用</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);	<span class="comment">// 0</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();	<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">y</span>) <span class="comment">// Error: Property &#x27;y&#x27; is private and only accessible within class &#x27;MyClass&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可被继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">MyClass</span> &#123;</span><br><span class="line">  _printX = <span class="title class_">MyClass</span>.<span class="property">printX</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mc = <span class="keyword">new</span> <span class="title function_">_MyClass</span>()</span><br><span class="line"></span><br><span class="line">mc.<span class="title function_">_printX</span>() <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>由于在JS中,类就是一个特殊的函数.所以在声明静态类成员时,需要注意,不允许覆盖<mark class="label primary">Function</mark>原型链上的属性,比如<mark class="label primary">name</mark>,<mark class="label primary">length</mark>,<mark class="label primary">call</mark>…等</p>
</div>
<h2 id="静态块">静态块*</h2>
<p>可以在类中声明静态块,可以访问所以的类内部成员</p>
<div class="note info"><p>暂不理解,这么做的目的是什么? 但确实可以这么干</p>
</div>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> #count = <span class="number">0</span> <span class="comment">// 注意这里是硬私有哦</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">count</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Foo</span>.#count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> lastInstances = <span class="title function_">loadLastInstances</span>()</span><br><span class="line">      <span class="title class_">Foo</span>.#count += lastInstances.<span class="property">length</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="title class_">Foo</span>.#count ++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型类">泛型类</h2>
<p>正如前面构造函数提到的,类的泛型在<mark class="label primary">class</mark>关键字上声明.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">  <span class="attr">contents</span>: <span class="title class_">Type</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">contents</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&quot;hello!&quot;</span>) <span class="comment">// const b: Box&lt;string&gt;</span></span><br><span class="line">b.<span class="property">contents</span> <span class="comment">// (property) Box&lt;string&gt;.contents: string</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>不要在静态成员上使用泛型, 谨记一点, 在编译后所有的类型注解都会去掉. 我们知道JS中的类是基于原型链实现继承的, 修改原型链上的任何属性都会影响到所有实例.在静态类上使用泛型<mark class="label danger">Box&lt;string&gt;</mark>与<mark class="label danger">Box&lt;number&gt;</mark>在编译后其实并无差别,更改他们中的任意一个的原型链都会影响到另一个.</p>
</div>
<h2 id="this-参数">this 参数</h2>
<p>我们知道,在JS中,<mark class="label primary">this</mark>的值是动态绑定的.比如,下面的例子</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>()</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: c.<span class="property">getName</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Prints &quot;obj&quot;, not &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>
<p>这并不是一种错误的行为,当我们清楚我们的在做什么时,可以使用箭头函数,bind等绑定回 MyClass 实例.</p>
<p>但这样还是有一点小小的隐患,可能会出现误用.有没有办法在类型检查阶段就限制该方法只能在该类实例中调用呢?</p>
<p>答案是: 有!  使用Ts中特有的<mark class="label primary">this</mark>参数进行限制</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: MyClass</span>) &#123; <span class="comment">// 注意这里这个this参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">c.<span class="title function_">getName</span>() <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>()); <span class="comment">// Error: The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;MyClass&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>可以当直接调用getName()时,Ts检查到<mark class="label primary">this</mark>类型不同会给出错误.</p>
<mark class="label primary">this</mark>参数在编译成Js时会被去掉
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeScript input with &#x27;this&#x27; parameter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: SomeType, x: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JavaScript output</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类">抽象类</h2>
<p>在JS中我们无法直接声明抽象类,但是很容易可以通过 new.target 来达到目的.Ts中则是直接支持使用<mark class="label primary">abstract</mark>关键字声明抽象类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">getName</span>(): <span class="built_in">string</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>() <span class="comment">// Error: Cannot create an instance of an abstract class.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建派生类实现抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;world&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>() <span class="comment">// ok</span></span><br><span class="line">d.<span class="title function_">printName</span>()	<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>注意: 在类型检查中,不要直接检查类型是否与抽象类一致,而是检查构造函数返回的类型是否属于该抽象类,举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">new</span> () =&gt; Base</span>) &#123;	<span class="comment">// 不要写成  Base 或 typeof Base</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">  instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Derived</span>)</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Argument of type &#x27;typeof Base&#x27; is not assignable to parameter of type &#x27;new () =&gt; Base&#x27;.</span></span><br><span class="line"><span class="comment">  Cannot assign an abstract constructor type to a non-abstract constructor type.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</div>
<h2 id="鸭子类型">鸭子类型</h2>
<p>Ts的类型检查是一种鸭子类型的检查.只要两个类的结构相同,我们完全可以对这两种类型的变量进行相互赋值.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point1</span> &#123;</span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">  y = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> &#123;</span><br><span class="line">  x = <span class="number">3</span></span><br><span class="line">  y = <span class="number">4</span></span><br><span class="line">  z = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point1</span> = <span class="keyword">new</span> <span class="title class_">Point2</span>()	<span class="comment">// 反过来不行</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.typescriptlang.org/docs/handbook/2/classes.html">Typescriptlang.org. Classes</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>Classes</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript - Function</title>
    <url>/Typescript-Function/</url>
    <content><![CDATA[<p>本文学习如何在Ts中声明函数类型</p>
<div class="note info"><p>学习<a href="https://kinsiy.github.io/Javascript-Function/">JavaScript - Function</a></p>
<p>本文参考Typescript官网<a href="https://www.typescriptlang.org/docs/handbook/2/functions.html">Docs - Handbook - More onFunction</a>自翻译而来, 仅供个人参考学习使用.一切请以官网为准!</p>
</div>
<h2 id="函数声明">函数声明</h2>
<h3 id="函数类型表达式">函数类型表达式</h3>
<p>函数类型表达式是Ts中最简单的声明函数的方法.它看起来和ES6中的箭头函数很是相像.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printToConsole</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">greeter</span>(printToConsole);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GreetFunction</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: GreetFunction</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<mark class="label info">(a: string) => void</mark>的意思是, 一个拥有一个string类型的参数a,不返回任何值的函数.
<h3 id="调用签名">调用签名</h3>
<p>我们知道在Js中函数是一个对象, 可以像下面这样往函数中添加属性. (当然我们很少这么做,只是使用Function原有的属性<mark class="label info">name</mark>,<mark class="label info">length</mark>等)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">kinsiy</span>)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="property">kinsiy</span> = <span class="string">&quot;qinglai&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>
<p>这意味着我们需要声明的是一个可以调用的对象.这时候函数表达式的类型声明方法无法满足我们的要求,需要用到<strong>调用签名</strong>这一声明方法,这种方式声明也很简单,只需把函数类型表达式中的箭头 <mark class="label danger">=></mark>换成冒号 <mark class="label danger">:</mark> 即可</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DescribableFunction</span> = &#123;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">  (<span class="attr">someArg</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>  <span class="comment">// &quot;=&gt;&quot; to &quot;:&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">fn: DescribableFunction</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">description</span> + <span class="string">&quot; returned &quot;</span> + <span class="title function_">fn</span>(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造签名">构造签名</h3>
<p>在Js中,还可以使用<mark class="label info">new</mark>操作符调用函数.这时候我们可以在调用签名前添加一个<mark class="label info">new</mark>,便可以声明构造函数的目的.对于调用时<mark class="label info">new</mark>操作符是可选的函数(对象),比如 <mark class="label info">Date</mark>, 需要同时声明调用签名,与构造签名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">SomeConstructor</span> = &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">SomeObject</span>  <span class="comment">// new</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ctor: SomeConstructor</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时声明构造签名与调用签名</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CallOrConstruct</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Date</span>;</span><br><span class="line">  (n?: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型函数">泛型函数</h2>
<p>通常我们会写一些,输入类型与输出类型相关或者两个参数之间存在某种关联的函数.举个栗子,返回任意数组中的第一个元素</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">firstElement</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数很简单,我们希望函数能够根据我们输入的类型自动得出返回值的类型,当我输入<mark class="label info">string[]</mark>类型时,返回值就是<mark class="label info">string</mark>类型的,其他类型同理.但实际上由于是任意数组,无法事先知道参数的类型,目前为止只能使用<mark class="label info">any[]</mark>类型,这时候返回类型自然也就是<mark class="label info">any</mark>类型.不满足我们的要求! 这就轮到<strong>泛型函数</strong>登场了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]) <span class="comment">// const s: string</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// const n: number</span></span><br><span class="line"><span class="keyword">const</span> u = <span class="title function_">firstElement</span>([]) <span class="comment">// const u: never</span></span><br></pre></td></tr></table></figure>
<p>可以看到,我们在函数名后方声明了类型<mark class="label info">Type</mark>,并在参数中使用<mark class="label info">Type[]</mark>对arr进行注解,函数返回类型也是<mark class="label info">Type</mark>类型.这样我们就得到了一个通用的类型函数(<strong>泛型函数</strong>).函数的返回类型会根据参数类型自动推断出来.</p>
<div class="note info"><p>注意: 不需要主动去指定<mark class="label info">Type</mark>.Ts会自动推断出正确的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;<span class="title class_">Input</span>, <span class="title class_">Output</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Input</span>[], <span class="attr">func</span>: <span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Output</span>): <span class="title class_">Output</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">map</span>(func)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const parsed: number[]</span></span><br><span class="line"><span class="comment">// (parameter) n: string</span></span><br><span class="line"><span class="keyword">const</span> parsed = <span class="title function_">map</span>([<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n))</span><br></pre></td></tr></table></figure>
</div>
<h3 id="泛型约束">泛型约束</h3>
<p>当函数需要处理不同类型的对象时,在函数中我们可能只需要读/写特定的属性.只要某对象存在这些属性,就应该可以成为函数的合法参数.举例来说, 比较两个参数的<mark class="label info">length: number</mark>属性, 只要参数存在<mark class="label info">length: number</mark>属性即可比较,无其他约束.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> longest&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: <span class="title class_">Type</span>, <span class="attr">b</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> longerArray = <span class="title function_">longest</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// const longerArray: number[]</span></span><br><span class="line"><span class="keyword">const</span> longerString = <span class="title function_">longest</span>(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>) <span class="comment">// const longerString: &quot;alice&quot; | &quot;bob&quot;</span></span><br><span class="line"><span class="keyword">const</span> notOK = <span class="title function_">longest</span>(<span class="number">10</span>, <span class="number">100</span>) <span class="comment">// Argument of type &#x27;number&#x27; is not assignable to parameter of type &#x27;&#123; length: number; &#125;&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>另外对于返回泛型<mark class="label info">Type</mark>的函数, 返回值满足约束条件并不一定能满足类型<mark class="label info">Type</mark>, <mark class="label info">Type</mark>是由入参决定的,<mark class="label info">Type</mark>是“约束”的超集.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> minimumLength&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">  <span class="attr">minimum</span>: <span class="built_in">number</span></span><br><span class="line">): <span class="title class_">Type</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">length</span> &gt;= minimum) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;; <span class="comment">// Error &quot;约束&quot;不能满足其超集 Type</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Type &#x27;&#123; length: number; &#125;&#x27; is not assignable to type &#x27;Type&#x27;.</span></span><br><span class="line"><span class="comment">  &#x27;&#123; length: number; &#125;&#x27; is assignable to the constraint of type &#x27;Type&#x27;, but &#x27;Type&#x27; could be instantiated with a different subtype of constraint &#x27;&#123; length: number; &#125;&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="指定类型">指定类型</h3>
<p>对于泛型函数,若指定多个入参均为泛型<mark class="label info">Type</mark>,这些入参的类型应完全一样.对于不一样的类型,可以在调用函数时指定通用泛型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]) <span class="comment">// Error: Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]) <span class="comment">// const arr: (string | number)[]</span></span><br></pre></td></tr></table></figure>
<h3 id="最佳实践">最佳实践</h3>
<ol>
<li>
<p>尽可能的使用类型参数本身,而不是“约束”拓展</p>
<blockquote>
<p>When possible, use the type parameter itself rather than constraining it</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// don&#x27;t do this</span></span><br><span class="line"><span class="keyword">function</span> firstElement2&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">firstElement1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// const a: number</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">firstElement2</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// const b: any</span></span><br></pre></td></tr></table></figure>
<p>Ts必须在函数调用之前推断出它的返回类型,而不是在函数调用的时候动态决定.</p>
</li>
<li>
<p>尽可能的少用泛型</p>
<blockquote>
<p>Always use as few type parameters as possible</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> filter1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[], <span class="attr">func</span>: <span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> filter2&lt;<span class="title class_">Type</span>, <span class="title class_">Func</span> <span class="keyword">extends</span> (<span class="attr">arg</span>: <span class="title class_">Type</span>) =&gt; <span class="built_in">boolean</span>&gt;(</span><br><span class="line">  <span class="attr">arr</span>: <span class="title class_">Type</span>[],</span><br><span class="line">  <span class="attr">func</span>: <span class="title class_">Func</span></span><br><span class="line">): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比<mark class="label info">filter1</mark>与<mark class="label info">filter2</mark>,不难发现两种写法,在不指定类型其实是没差别的,但当指定类型时,<mark class="label info">filter2</mark>却需要多指定一个泛型.多此一举</p>
</li>
<li>
<p>泛型<mark class="label info">Type</mark>至少应该出现两次</p>
<blockquote>
<p>If a type parameter only appears in one location, strongly reconsider if you actually need it</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> greet&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">s</span>: <span class="title class_">Str</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用&quot;约束类型&quot;即可</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于只出现一次的类型,完全没有必要使用泛型.记住,泛型用于关联多个值的类型</p>
</li>
</ol>
<h2 id="可选参数">可选参数</h2>
<p>在参数前使用<mark class="label info">?</mark>修饰,可以使参数变为可选参数.对于未指定默认值的可选参数,其类型永远都是声明类型本身与<mark class="label info">undefined</mark>的联合类型.因为在Js中未赋值的参数的值就是<mark class="label info">undefined</mark>.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// (parameter) x: number | undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()  <span class="comment">// underfined</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">g</span>(<span class="params">x = <span class="number">10</span></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">// (parameter) x: number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与ES6一样,可以对参数设定默认值,设定默认值后,改参数变为可选参数,但不传该值或传入的值为undefined时,参数获得改默认值,并且值的类型为其本身类型,不会存在<mark class="label info">undefined</mark></p>
<h3 id="回调函数">回调函数</h3>
<p>注意,尽量不要在回调函数中使用可选参数.除非你打算在不传递参数的情况下进行回调. 具有较少参数(相同类型)的函数总是可以代替具有更多参数的函数.所以在回调中定义多个参数即可,传入<strong>回调函数</strong>定义的参数可以比<strong>定义的函数</strong>定义的参数的参数少</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="title function_">callback</span>(arr[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))  <span class="comment">// ok</span></span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a, i)) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h2 id="函数重载">函数重载</h2>
<p>针对Js中同名函数可以传入不同数量/类型的用法,除了可选/默认参数外.Ts中还可以使用函数重载实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title class_">Date</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title class_">Date</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(y, mOrTimestamp, d)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(mOrTimestamp)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d1 = <span class="title function_">makeDate</span>(<span class="number">12345678</span>)</span><br><span class="line"><span class="keyword">const</span> d2 = <span class="title function_">makeDate</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> d3 = <span class="title function_">makeDate</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.</span></span><br></pre></td></tr></table></figure>
<div class="note warning"><h3 id="注意">注意</h3>
<p>需要区分<strong>重载函数</strong>和<strong>实现函数</strong>, 重载函数指没有函数体的函数声明,实现函数则指拥有函数体的函数.实现函数要求写在所有重载函数后,并且实现函数是兼容所有重载函数的.但是实现函数对<strong>外部</strong>不可见,这里外部指不能直接调用实现函数,只能通过重载函数签名对函数进行调用.举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// Error: Expected to be able to call with zero arguments</span></span><br></pre></td></tr></table></figure>
<p>这里直接对实现函数进行调用,无法通过编译</p>
</div>
<h3 id="最佳实践-2">最佳实践</h3>
<p>尽可能使用联合类型而不是函数重载.</p>
<blockquote>
<p>Always prefer parameters with union types instead of overloads when possible</p>
</blockquote>
<p>举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]) <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">No overload matches this call.</span></span><br><span class="line"><span class="comment">  Overload 1 of 2, &#x27;(s: string): number&#x27;, gave the following error.</span></span><br><span class="line"><span class="comment">    Argument of type &#x27;number[] | &quot;hello&quot;&#x27; is not assignable to parameter of type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">      Type &#x27;number[]&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"><span class="comment">  Overload 2 of 2, &#x27;(arr: any[]): number&#x27;, gave the following error.</span></span><br><span class="line"><span class="comment">    Argument of type &#x27;number[] | &quot;hello&quot;&#x27; is not assignable to parameter of type &#x27;any[]&#x27;.</span></span><br><span class="line"><span class="comment">      Type &#x27;string&#x27; is not assignable to type &#x27;any[]&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]) <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<div class="note info"><p>对于重载,我个人理解,在Js中与可选参数差别不大,重载能做到的可选参数一样可以做到.对于不同类型,Ts中则是建议使用联合类型.</p>
<p>那么在实践中就是尽量不要使用重载.</p>
<ul>
<li>
<p>对相同数量参数的函数,尽量使用联合类型</p>
</li>
<li>
<p>对不同数量参数的函数,用可选参数代替</p>
</li>
<li>
<p>对参数数量/类型均不同的函数,结合联合类型与可选参数实现.</p>
</li>
</ul>
</div>
<h2 id="Void">Void</h2>
<p>对于<strong>拥有类型为返回void的函数类型</strong>的函数,Ts不会禁止该函数返回值,但返回值赋值给变量时,变量获取到的类型始终是void.举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: voidFunc = <span class="function">() =&gt;</span> <span class="literal">true</span> <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v1 = <span class="title function_">f1</span>() <span class="comment">// const v1: void</span></span><br></pre></td></tr></table></figure>
<p>这对于定义回调很有用,使得我们可以在形如 <mark class="label info">Array.prototype.forEach, Array.prototype.push</mark>这样返回函数的值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> dst = [<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">src.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> dst.<span class="title function_">push</span>(el));</span><br></pre></td></tr></table></figure>
<p>但当我们声明一个函数拥有void返回类型时,则禁止返回任何值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = (): <span class="function"><span class="params">void</span> =&gt;</span> <span class="literal">true</span> <span class="comment">// Type &#x27;boolean&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Type &#x27;boolean&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// Type &#x27;boolean&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.typescriptlang.org/docs/handbook/2/functions.html">Typescriptlang.org. More onFunction</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript - 类型推断</title>
    <url>/Typescript-TypeGuards/</url>
    <content><![CDATA[<div class="note info"><p>本文参考Typescript官网<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">Docs - Handbook - Narrowing</a>自翻译而来, 仅供个人参考学习使用.一切请以官网为准!</p>
</div>
<p>考虑下面这段代码，能否通过Ts编译？</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.<span class="title function_">repeat</span>(padding) + input;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> padding.<span class="title function_">slice</span>(<span class="number">0</span>) + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>答案是可以。为什么？我们明明指定 padding 的类型是 number | string ，而 number 类型是没有 slice 方法的，却能通过编译？关键在于<mark class="label primary">typeof padding === number</mark>这一句，这一特殊的检查被TypeScript称作<strong>类型保护(type guards)</strong>。</p>
<p>在<mark class="label primary">typeof padding === number</mark> 分支中，padding 的类型缩小至 number ，并发现最后一句<mark class="label primary">return padding.slice(0) + input;</mark>是不可到达的，则在分支外去掉 padding 的 number 类型。在调用 slice 方法时， padding 的类型已经被缩小至 string ，自然也就能够通过编译。</p>
<h2 id="typeof-操作符">typeof 操作符</h2>
<p>正如上面 padLeft 所示，可以通过 typeof 类型保护缩小类型范围。TypeScript可以理解 typeof 返回的值，对类型范围进行缩小。 typeof 会返回下列结果之一</p>
<ul>
<li>“string”</li>
<li>“number”</li>
<li>“bigint”</li>
<li>“boolean”</li>
<li>“symbol”</li>
<li>“undefined”</li>
<li>“object”</li>
<li>“function”</li>
</ul>
<h2 id="真值推断">真值推断</h2>
<p>typeof  在检查基本类型时很好用，但当检查包含 null 得类型时，由于在 Javascript 中 typeof null 会返回&quot;object&quot;。如下，单检查  typeof strs === “object” 并不能排除 null , 这时候就需要利用真值来进行类型缩小</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">      <span class="comment">// Object is possibly &#x27;null&#x27;.</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 null 、undefined等会转化为假值的特性(<a href="https://kinsiy.github.io/JavaScript-Basics/#Boolean-%E7%B1%BB%E5%9E%8B">Boolean 类型</a>)，很容易就可以排除 null 等类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;        <span class="comment">// ok</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相等性推断">相等性推断</h2>
<p>TypeScript 还可以使用相等性来进行类型缩小，如 ===、!==、==、!= 操作符</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">// We can now call any &#x27;string&#x27; method on &#x27;x&#x27; or &#x27;y&#x27;.</span></span><br><span class="line">    x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">    y.<span class="title function_">toLowerCase</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//(parameter) x: string | number</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">//(parameter) y: string | boolean</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，由于只有 x y 都是 string 类型时才存在严格相等的可能，TypeScript 能够依据这个信息推断出在if 这个分支上 x y的类型均是 string 类型</p>
<p>另外由于在 JavaScript中 undefined 和 null 是<strong>相等</strong>(不是严格相等哦)的，我们可以利用这个特性一次去除两个类型，相应的只需要两者之一时需要使用严格相等</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyValue</span>(<span class="params">container: Container, factor: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="comment">// Remove both &#x27;null&#x27; and &#x27;undefined&#x27; from the type.</span></span><br><span class="line">  <span class="keyword">if</span> (container.<span class="property">value</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">value</span>); <span class="comment">// (property) Container.value: number</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Now we can safely multiply &#x27;container.value&#x27;.</span></span><br><span class="line">    container.<span class="property">value</span> *= factor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="in-运算符">in 运算符</h2>
<p>我们知道在JavaScript中，如果指定的属性在指定的对象或其原型链中，则 <strong><mark class="label primary">in</mark> 运算符</strong> 返回 true。在Ts中也可以利用这个特性来缩小类型范围。举例来说</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="title function_">swim</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> animal.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形如 <mark class="label primary">"value" in x</mark>， value是一段字符串，x是某种联合类型，对于真值，x 缩小为包含&quot;value&quot;属性的<strong>联合类型</strong>(不一定缩小至唯一，因为 x 中不一定只有一种类型包含 “value” 属性)，反之，假值这缩小为不含&quot;value&quot;属性的联合属性。若value 是某类型的可选属性，这两分支中均包含 该类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Human</span> = &#123; swim?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; fly?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird | Human</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    animal; <span class="comment">// (parameter) animal: Fish | Human</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    animal; <span class="comment">// (parameter) animal: Bird | Human</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="instanceof-运算符">instanceof 运算符</h2>
<p>typeof、in 都可以用来推断类型，instanceof自然也不会缺席!</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUTCString</span>()); <span class="comment">// (parameter) x: Date</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUpperCase</span>()); <span class="comment">// (parameter) x: string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值推断">赋值推断</h2>
<p>当赋值给变量时，Ts会根据值的类型对变量的类型进行推断</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// let x: string | number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// let x: number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="string">&quot;goodbye!&quot;</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// let x: string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值判断的是最初的类型，这就是为什么当第一次赋值推断出number类型后，仍可以赋值string类型的&quot;goodbye&quot;</span></span><br><span class="line">x = <span class="literal">true</span> </span><br><span class="line"><span class="comment">// Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br></pre></td></tr></table></figure>
<h2 id="控制流分析">控制流分析</h2>
<p>正如开篇的例子一般，Ts判断<mark class="label primary">if</mark>分支外能否到达来推断变量的类型。Ts可以通过分析<mark class="label primary">if</mark>、<mark class="label primary">while</mark>等控制流进行类型推断。变量可以通过一遍又一遍的控制流分析在程序的不同的位置展现出不同的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"> </span><br><span class="line">  x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// let x: boolean</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    x = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// let x: string</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">//let x: number</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x; <span class="comment">// let x: string | number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型谓语">类型谓语</h2>
<p>到目前为止，我们已经使用现有的 JavaScript 结构来处理类型推断，但是有时我们希望可以更直接地控制类型在整个代码中的变化方式。这时候就需要文明自定义类型保护</p>
<p>要自定义类型保护，我们只需要定义一个返回类型为<strong>类型谓词</strong> 的函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">zoo</span>: (<span class="title class_">Fish</span> | <span class="title class_">Bird</span>)[] = [<span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>()];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater1</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish);</span><br><span class="line"><span class="comment">// or, equivalently</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater2</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish) <span class="keyword">as</span> <span class="title class_">Fish</span>[];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The predicate may need repeating for more complex examples</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater3</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>((pet): pet is <span class="title class_">Fish</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (pet.<span class="property">name</span> === <span class="string">&quot;sharkey&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">isFish</span>(pet);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="可辨识联合">可辨识联合</h2>
<p>目前为止我们主要都是对简单的基本类型进行推断。考虑下面这样一个结构，我们有一个 Shape 接口，对于 circle,  必有radius，对于 square 则必有 sideLength。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  radius?: <span class="built_in">number</span>;</span><br><span class="line">  sideLength?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个方法求 Shape 的面积</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// Object is possibly &#x27;undefined&#x27;.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管我们用 kind 进行了判断，分支内 Shape 必是circle，我们知道radius必然存在。但Ts无法知道这个信息，strictNullChecks下会给出我们 radius 可能不存在的错误。对于这种我们比Ts更清楚的情况，可以使用 <strong>非空断言(添加!后缀)</strong> 告诉Ts某个值必然存在。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span>! ** <span class="number">2</span>; <span class="comment">//ok</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然不报错了，但在&quot;circle&quot;分支内还是可以选择sideLength属性并且后续每次使用radius属性仍然要继续使用非空断言。还是会有出错的可能！这就轮到到可辨识类型登场了</p>
<blockquote>
<p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 <em>可辨识联合</em>的高级模式，它也称做 <em>标签联合</em>或 <em>代数数据类型</em>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p>
<ol>
<li>具有普通的单例类型属性— <em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合— <em>联合</em>。</li>
<li>此属性上的类型保护</li>
</ol>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新定义Shape</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">  <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用任何非空断言重新实现getArea()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>; <span class="comment">// (parameter) shape: Circle</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>; <span class="comment">// (parameter) shape: Square</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> shape; <span class="comment">//(parameter) shape: never</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在每个case分支中，联合类型shape的类型都能推断正确，属性提示也没问题。对于 default 分支，由于前两个分支已经将 Shape 穷举完毕。default 分支内将得到一个 never 类型</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">Typescriptlang.org. Narrowing</a></p>
<p>[2]<a href="https://www.tslang.cn/docs/handbook/advanced-types.html">Tslang.cn. 高级类型</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树 - 定义</title>
    <url>/binaryTree-define/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<blockquote>
<p>二叉树(Binary Tree) 是 n (n ≥ 0)个结点的有限集合，该集合或者为空集(称为空二叉树), 或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<p>——程杰. 《大话数据结构》</p>
</blockquote>
<div class="note primary"><p>文章未指明出处的引用均出自 程杰. 《大话数据结构》</p>
</div>
<span id="more"></span>
<h2 id="特殊二叉树">特殊二叉树</h2>
<h3 id="斜树">斜树</h3>
<blockquote>
<p>所有的节点都只有左子树的二叉树叫左斜树。所有节点都是只有右子树的二叉树叫右斜树。这两者通称为斜树</p>
</blockquote>
<h3 id="满二叉树">满二叉树</h3>
<blockquote>
<p>在一颗二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树</p>
</blockquote>
<h3 id="完全二叉树">完全二叉树</h3>
<blockquote>
<p>对一颗具有 n 个节点的二叉树按层序编号，如果编号为 i (0 ≤ i ≤ n) 的节点与同样深度的满二叉树中编号为 i 的节点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树</p>
</blockquote>
<h2 id="性质">性质</h2>
<ul>
<li>在二叉树的第 i 层上至多有 2<sup>i - 1</sup> 个节点 (i ≥ 1)</li>
<li>深度为 k 的二叉树至多有 2<sup>k + 1</sup> - 1 个节点(定义根节点所在深度 k<sub>0</sub> = 0, k ≥ 0)</li>
<li>对任何一颗非空二叉树 T, 如果其终端节点数为 n<sub>0</sub>, 度为 2 的节点数为 n<sub>2</sub>, 则 n<sub>0</sub> = n<sub>2</sub> + 1</li>
<li>具有 n 个结点的完全二叉树的深度为 ⌊log<sub>2</sub>n⌋ + 1 (⌊ x ⌋ 表示不大于 x 的最大整数)</li>
<li>如果对一颗有 n 个节点的完全二叉树的节点按层序编号，对任一节点 i (0 ≤ i ≤ n)有：
<ol>
<li>如果 i = 0，则节点 i 是二叉树的根，无双亲；如果 i ＞ 0, 则其双亲是节点 ⌊ (i - 1) / 2 ⌋</li>
<li>如果 2i + 1 ＞ n, 则节点 i 无左孩子；否则其左孩子是节点是 2i + 1</li>
<li>如果 2i + 2 ＞ n, 则节点 i 无右孩子；否则其左孩子是节点是 2i + 2</li>
</ol>
</li>
</ul>
<h2 id="存储结构">存储结构</h2>
<h3 id="顺序存储">顺序存储</h3>
<p>二叉树可以用数组或链接串列来存储，若是满二叉树就能紧凑排列而不浪费空间。这种方法更有利于紧凑存储和更好的访问局部性，特别是在前序遍历中。然而，它需要连续的存储空间，这样在存储高度为 h 的 n 个节点所组成的一般树时，将浪费很多空间。在最糟糕的情况下，如果深度为 h 的二叉树其每个节点都只有右孩子，则该存储结构需要占用 2<sup>h</sup> - 1 的空间，实际上却只有 h 个节点，浪费了不少空间，是顺序存储结构的一大缺点</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Binary_tree_in_array.svg" alt=""></p>
<h3 id="二叉链表">二叉链表</h3>
<p>二叉树每个节点最多有两个孩子，节点可以设计一个数据域和两个指针域。这样子就可以使用链表的方式存储</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitNode</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">parent</span> = <span class="literal">null</span>; <span class="comment">// 按需添加</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有需要，可以添加一个指向其双亲的指针域，称为三叉链表</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Eclb.jpg" alt=""></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">Wikipedia. 二叉树.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>斜树</tag>
        <tag>二叉树</tag>
        <tag>满二叉树</tag>
        <tag>完全二叉树</tag>
        <tag>二叉链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript - 类型</title>
    <url>/Typescript-Types/</url>
    <content><![CDATA[<h2 id="基本类型">基本类型</h2>
<h3 id="boolean、string、number">boolean、string、number</h3>
<p>这三种数据类型与JavaScript中的同名类型一致，唯一不同的也是 TypeScript  与 JavaScript 的不同，Typescript 是静态类型语言，无法将某种数据类型的数据赋值给另一种数据类型的变量。如下，将 number 类型 17 赋值给 string 类型的kinsiyName，无法通过编译</p>
<span id="more"></span>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">kinsiyName</span>: <span class="built_in">string</span> = <span class="string">&quot;Kinsiy&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">kinsiyAge</span>: <span class="built_in">number</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">kinsiyName = <span class="number">17</span></span><br><span class="line"><span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure>
<h3 id="null、undefined">null、undefined</h3>
<p>在JavaScript中一般用null表示空对象指针，undefined 表示值未进行初始化，它两均只有一个值。在TypeScript中一样，特殊点在于null与undefined能够赋给任意类型的变量。<em>可以配置 strictNullChecks 强制检查</em></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">isDone = <span class="literal">undefined</span></span><br><span class="line">age = <span class="literal">null</span></span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h3 id="any、void">any、void</h3>
<p>any 表示任意类型，用于为在编程阶段还不清楚类型的变量指定一个类型。void 则相反，它表示没有任意类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="string">&quot;kinsiy&quot;</span></span><br><span class="line">notSure = <span class="number">24</span>        </span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>): <span class="built_in">void</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;return void&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unknown、never">unknown、never</h3>
<p>unknown表示一种<strong>匿名</strong>类型，某个值存在某种类型，只是我不知道它是什么类型，所有类型都可以赋值给unknown类型，unknown类型只能赋值给 any 或 unknown 类型本身，对unknown类型变量进行任何操作都无法通过编译。never则表示从未观察到的值，比如走不到终点的函数返回值，联合类型中无剩余类型的条件分支</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notKnown</span>: <span class="built_in">unknown</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="built_in">number</span> = notKnown + <span class="number">1</span></span><br><span class="line"><span class="comment">// Operator &#x27;+&#x27; cannot be applied to types &#x27;unknown&#x27; and &#x27;1&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">notSure = notKnown</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;        <span class="comment">// 走不到终点的函数</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x; <span class="comment">// has type &#x27;never&#x27;!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组类型">数组类型</h3>
<p>指定某一类型的数组有两种方式，注意不要和元组搞混了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">array1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">array2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="元组类型">元组类型</h3>
<p>元组类型是另一种数组类型，它确切地知道它包含多少元素，以及在特定位置包含哪些类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">24</span>, <span class="string">&#x27;kinsiy&#x27;</span>]</span><br><span class="line">tuple[<span class="number">1</span>] = <span class="number">17</span></span><br><span class="line"><span class="comment">// 类型不匹配</span></span><br><span class="line"><span class="comment">// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line"></span><br><span class="line">tuple[<span class="number">2</span>] = <span class="string">&#x27;lai&#x27;</span></span><br><span class="line"><span class="comment">// 越界类型为undefin</span></span><br><span class="line"><span class="comment">// Type &#x27;&quot;lai&quot;&#x27; is not assignable to type &#x27;undefined&#x27;.</span></span><br><span class="line"><span class="comment">// 越界</span></span><br><span class="line"><span class="comment">// Tuple type &#x27;[number, string]&#x27; of length &#x27;2&#x27; has no element at index &#x27;2&#x27;.</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举类型-Enum">枚举类型(Enum)</h3>
<p>枚举类型是少部分不是JavaScript类型级拓展的特性之一。枚举允许我们定义一组命名常量 <a href="https://www.typescriptlang.org/docs/handbook/enums.html">enums</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="number">1</span>,        <span class="comment">// 后续枚举值递增</span></span><br><span class="line">  <span class="title class_">Down</span>,</span><br><span class="line">  <span class="title class_">Left</span>,</span><br><span class="line">  <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  <span class="title class_">Up</span> = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  <span class="title class_">Down</span> = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  <span class="title class_">Left</span> = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  <span class="title class_">Right</span> = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异构枚举 避免使用</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">BooleanLikeHeterogeneousEnum</span> &#123;</span><br><span class="line">  <span class="title class_">No</span> = <span class="number">0</span>,</span><br><span class="line">  <span class="title class_">Yes</span> = <span class="string">&quot;YES&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型断言">类型断言</h2>
<p>有时候我们会比Typescript更清楚一个值的类型。可以使用类型断言去更改其类型。比如<mark class="label primary">let kinsiyEle = document.getElementById(kinsiy)</mark> Typescript只知道 <mark class="label primary">kinsiyEle</mark>  是一个<mark class="label primary">HTMLElement</mark>类型的变量，但我们可能清楚的知道他是一个<mark class="label primary">HTMLCanvasElement</mark>类型的元素。在使用<mark class="label primary">HTMLCanvasElement</mark>的属性或方法时我们就需要用到类型断言。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> kinsiyEle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;kinsiy&quot;</span>)        </span><br><span class="line">kinsiyEle.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="comment">//Property &#x27;getContext&#x27; does not exist on type &#x27;HTMLElement&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方式使用 as</span></span><br><span class="line"><span class="keyword">let</span> kinsiyEle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;kinsiy&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLCanvasElement</span></span><br><span class="line">kinsiyEle.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="comment">// 使用时再声明也是可以的</span></span><br><span class="line">(kinsiyEle <span class="keyword">as</span> <span class="title class_">HTMLCanvasElement</span>).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式使用尖括号</span></span><br><span class="line"><span class="keyword">let</span> kinsiyEle = &lt;<span class="title class_">HTMLCanvasElement</span>&gt;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;kinsiy&quot;</span>);</span><br><span class="line">kinsiyEle.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">(&lt;<span class="title class_">HTMLCanvasElement</span>&gt;kinsiyEle).<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在使用 querySelector 等带泛型的选择器使用泛型也是可以的</span></span><br><span class="line"><span class="keyword">let</span> kinsiyEle = <span class="variable language_">document</span>.<span class="property">querySelector</span>&lt;<span class="title class_">HTMLCanvasElement</span>&gt;(<span class="string">&quot;#kinsiy&quot;</span>);</span><br><span class="line">kinsiyEle.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>类型断言只允许断言一个类型更具体或更不具体，可以理解为缩放两者(A, B)中必须存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊂</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\subset B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>⊂</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">B \subset A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>(硬要改也是可以的)。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> kinsiy = <span class="string">&#x27;kinsiy&#x27;</span> <span class="keyword">as</span> <span class="built_in">number</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Conversion of type &#x27;string&#x27; to type &#x27;number&#x27; may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to &#x27;unknown&#x27; first.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_ inherited__">A</span>&#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">B</span>() <span class="keyword">as</span> A        <span class="comment">// ok 缩小</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>() <span class="keyword">as</span> B  <span class="comment">// ok 放大</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _c = <span class="keyword">new</span> <span class="title function_">C</span>() <span class="keyword">as</span> B        <span class="comment">// error miss b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = (<span class="keyword">new</span> C <span class="keyword">as</span> <span class="built_in">any</span>) <span class="keyword">as</span> B        <span class="comment">// 强制更改。any 与 unknown 是任何类型的超集</span></span><br></pre></td></tr></table></figure>
<h2 id="交叉类型">交叉类型</h2>
<p>交叉类型可以将多个类型合并为一个类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ColorfulCircle</span> = <span class="title class_">Colorful</span> &amp; <span class="title class_">Circle</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">circle: ColorfulCircle</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Color was <span class="subst">$&#123;circle.color&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Radius was <span class="subst">$&#123;circle.radius&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// okay</span></span><br><span class="line"><span class="title function_">draw</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span>, <span class="attr">radius</span>: <span class="number">42</span> &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// oops</span></span><br><span class="line"><span class="title function_">draw</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">raidus</span>: <span class="number">42</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Argument of type &#x27;&#123; color: string; raidus: number; &#125;&#x27; is not assignable to parameter of type &#x27;ColorfulCircle&#x27;.</span></span><br><span class="line"><span class="comment">  Object literal may only specify known properties, but &#x27;raidus&#x27; does not exist in type &#x27;ColorfulCircle&#x27;. Did you mean to write &#x27;radius&#x27;?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="联合类型">联合类型</h2>
<p>联合类型表示一个值可以是几种类型之一</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">numAndStr</span>: <span class="built_in">number</span> | <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">numAndStr = <span class="string">&quot;kinsiy&quot;</span>        <span class="comment">// ok</span></span><br><span class="line">numAndStr = <span class="number">24</span>        <span class="comment">// ok</span></span><br><span class="line">numAndStr = <span class="literal">true</span></span><br><span class="line"><span class="comment">//Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">layEggs</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">  <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">layEggs</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">result</span>: <span class="title class_">Fish</span> | <span class="title class_">Bird</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>)&#123;</span><br><span class="line">    result =  &#123;</span><br><span class="line">      <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bird fly&quot;</span>),</span><br><span class="line">      <span class="attr">layEggs</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Bird layEggs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    result =  &#123;</span><br><span class="line">      <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fish fly&quot;</span>),</span><br><span class="line">      <span class="attr">layEggs</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fish layEggs&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>();</span><br><span class="line">pet.<span class="title function_">layEggs</span>(); <span class="comment">// okay        </span></span><br><span class="line">pet.<span class="title function_">swim</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Property &#x27;swim&#x27; does not exist on type &#x27;Bird | Fish&#x27;.</span></span><br><span class="line"><span class="comment">  Property &#x27;swim&#x27; does not exist on type &#x27;Bird&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="类型别名">类型别名</h2>
<p>可以使用<mark class="label primary">type</mark>关键字对类型设置别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Exactly the same as the earlier example</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.<span class="property">x</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<div class="note info no-icon"><h3 id="type与interface的区别">type与interface的区别</h3>
<p>一般来说用interface描述<strong>数据结构</strong>，用type描述<strong>类型关系</strong></p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
<li>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</li>
<li>interface 能够声明合并</li>
</ul>
</div>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.typescriptlang.org/docs/">TypeScriptLang.org Docs</a></p>
<p>[2]<a href="https://www.tslang.cn/docs/home.html">Tslang.cn Docs</a></p>
<p>[3]<a href="https://juejin.cn/post/6844903749501059085">掘金. Typescript 中的 interface 和 type 到底有什么区别</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树 - 线索化</title>
    <url>/binaryTree-thread/</url>
    <content><![CDATA[<h2 id="定义">定义</h2>
<blockquote>
<p>线索二叉树（threaded binary tree，保留遍历时结点在任一序列的前驱和后继的信息）：若结点有左子树，则其 lchild 域指示其左孩子，否则令 lchild 域指示其前驱；若结点有右子树，则其 rchild 域指示其右孩子，否则令 rchild 指示其后继。</p>
<p>还需在结点结构中增加两个标志域 LTag 和 RTag。LTag=0 时，lchild 域指示结点的左孩子，LTag=1 时，lchild 域指示结点的前驱；RTag=0 时，rchild 域指示结点的右孩子，RTag=1 时，rchild 域指示结点的后继。</p>
<span id="more"></span>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表，其中指向结点前驱和后继的指针叫做线索，加上线索的二叉树称为线索二叉树。</p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。</p>
<p>若对二叉树进行中序遍历，则所得的线索二叉树称为中序线索二叉树，线索链表称为为中序线索链表。</p>
<p>线索二叉树是一种物理结构。</p>
<p>——Wikipedia. 二叉树</p>
</blockquote>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Tbt1.jpg" alt=""></p>
<h2 id="节点结构">节点结构</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BithrNode</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lchild</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rchild</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">LTag</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">RTag</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索化-中序">线索化(中序)</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BithrNode</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lchild</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rchild</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">LTag</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">RTag</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BithrTree</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tree</span>)&#123;        <span class="comment">// tree 是以二叉链表存储的二叉树，tree指向根节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="keyword">new</span> <span class="title class_">BithrNode</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">RTag</span> = <span class="number">1</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">lchild</span> = tree</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">inThreading</span>(tree)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inThreading</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> preNode = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">fn</span>(root)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">rchild</span> = preNode</span><br><span class="line">    preNode.<span class="property">RTag</span> = <span class="number">1</span></span><br><span class="line">    preNode.<span class="property">rchild</span> = <span class="variable language_">this</span>.<span class="property">head</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">root</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">fn</span>(root.<span class="property">lchild</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(root.<span class="property">lchild</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        root.<span class="property">LTag</span> = <span class="number">1</span></span><br><span class="line">        root.<span class="property">lchild</span> = preNode</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(preNode.<span class="property">rchild</span> === <span class="literal">null</span>)&#123;</span><br><span class="line">        preNode.<span class="property">RTag</span> = <span class="number">1</span></span><br><span class="line">        preNode.<span class="property">rchild</span> = root</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      preNode = root</span><br><span class="line"></span><br><span class="line">      <span class="title function_">fn</span>(root.<span class="property">rchild</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前序与后序的线索化类似</p>
<h2 id="遍历">遍历</h2>
<p>对线索二叉树进行遍历，其实就等于是操作一个双向链表结构</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraverseThr</span>(<span class="params">head</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = head.<span class="property">lchild</span></span><br><span class="line">  <span class="keyword">while</span>(root !== head)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(root.<span class="property">LTag</span> === <span class="number">0</span>)&#123;   <span class="comment">// 中序序列第一个节点</span></span><br><span class="line">      root = root.<span class="property">lchild</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(root.<span class="property">RTag</span> === <span class="number">1</span> &amp;&amp; root.<span class="property">rchild</span> !== head)&#123;</span><br><span class="line">      root = root.<span class="property">rchild</span></span><br><span class="line">      result.<span class="title function_">push</span>(root.<span class="property">val</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root = root.<span class="property">rchild</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果所用的二叉树需经常遍历或查找节点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">Wikipedia. 二叉树.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>线索二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-双向链表</title>
    <url>/dataStructure-Doubly-Linked-Lists/</url>
    <content><![CDATA[<blockquote>
<p>双向链表，又称为双链表，是链表的一种，它的每个数据结点都有两个指针，分别指向直接后继和直接前驱。所有，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表</p>
<p>——Wikipedia. 双向链表</p>
</blockquote>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/610px-Doubly-linked-list.svg.png" alt=""></p>
<span id="more"></span>
<h3 id="存储结构">存储结构</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prior</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作">操作</h3>
<div class="note primary"><p>代码和单向链表差不多，增加了链表尾属性。选用size进行循环</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>; <span class="comment">// first/head/root 结点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>; <span class="comment">// 结点总数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在单向链表末端新增结点, 返回新的链表长度</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> args) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">head</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = node;</span><br><span class="line">        node.<span class="property">prior</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prior</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表末端删除结点, 返回结点值</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> popNode = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">if</span> (popNode) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = popNode.<span class="property">prior</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prior</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">      <span class="keyword">return</span> popNode.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表开端新增结点, 返回新链表长</span></span><br><span class="line">  <span class="title function_">unshift</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = args.<span class="property">length</span> - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(args[index]);</span><br><span class="line">      node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prior</span> = node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prior</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表开端删除结点, 返回结点值</span></span><br><span class="line">  <span class="title function_">shift</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> head = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">const</span> tail = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> !== <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = head.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">prior</span> = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">    <span class="keyword">return</span> head.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值搜索结点，返回其索引值,未找到则返回-1</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">size</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按索引值删除单向链表的值, 返回结点值, 不存在返回undefined</span></span><br><span class="line">  <span class="title function_">removeByIndex</span>(<span class="params">index = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="variable language_">this</span>.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">size</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === index) &#123;</span><br><span class="line">        currentNode.<span class="property">next</span>.<span class="property">prior</span> = currentNode.<span class="property">prior</span>;</span><br><span class="line">        currentNode.<span class="property">prior</span>.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">return</span> currentNode.<span class="property">value</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取第i个元素的值, 不存在则返回undefined</span></span><br><span class="line">  <span class="title function_">getItemByIndex</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">size</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode.<span class="property">value</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在第i个位置之前插入新结点, 返回新链表长, 位置比链表长大则在链表末端新增, 位置小于0，则重置为0</span></span><br><span class="line">  <span class="title function_">insertBefore</span>(<span class="params">position = <span class="number">0</span>, ...args</span>) &#123;</span><br><span class="line">    position &lt; <span class="number">0</span> &amp;&amp; (position = <span class="number">0</span>); <span class="comment">// 重置负值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">unshift</span>(...args);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="variable language_">this</span>.<span class="property">size</span>; i++, currentNode = currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === position) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> args) &#123;</span><br><span class="line">          <span class="keyword">const</span> insertNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">          currentNode.<span class="property">prior</span>.<span class="property">next</span> = insertNode;</span><br><span class="line">          insertNode.<span class="property">prior</span> = currentNode.<span class="property">prior</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          insertNode.<span class="property">next</span> = currentNode;</span><br><span class="line">          currentNode.<span class="property">prior</span> = insertNode;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">push</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整表删除, 不用担心循环引用垃圾回收的问题</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kinsiyLinkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">push</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">pop</span>()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">unshift</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">shift</span>()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">removeByIndex</span>(<span class="number">7</span>)); <span class="comment">// undefined 越界了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">indexOf</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">getItemByIndex</span>(<span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">insertBefore</span>(<span class="number">3</span>, <span class="string">&quot;kinsiy&quot;</span>, <span class="string">&quot;qing&quot;</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kinsiyLinkedList.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList); <span class="comment">// LinkedList &#123;head: null, tail: null, size: 0&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<p>[1]<a href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">Wikipedia. 双向链表</a></p>
<p>[2]<a href="https://humanwhocodes.com/blog/2019/02/computer-science-in-javascript-doubly-linked-lists/">Human Who Codes. Computer science in JavaScript: Doubly linked lists</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树 - 遍历</title>
    <url>/binaryTree-traverse/</url>
    <content><![CDATA[<h2 id="遍历">遍历</h2>
<blockquote>
<p>二叉树的遍历(traversing binary tree) 是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次</p>
<p>——程杰. 《大话数据结构》</p>
</blockquote>
<p>下列遍历算法的二叉树节点结构均为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BitNode</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="深度优先遍历">深度优先遍历</h2>
<h3 id="前序遍历">前序遍历</h3>
<p>根节点 → 左子树 → 右子树</p>
<h4 id="递归">递归</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">preorderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">yield</span> root.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">preorderTraversal</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">preorderTraversal</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="title function_">preorderTraversal</span>(root)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代">迭代</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">let</span> node</span><br><span class="line">  stack.<span class="title function_">push</span>(root)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(stack.<span class="property">length</span> !== <span class="number">0</span>)&#123;</span><br><span class="line">    node = stack.<span class="title function_">pop</span>()</span><br><span class="line">    result.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">    <span class="keyword">if</span>(node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历">中序遍历</h3>
<p>左子树 → 根节点 → 右子树</p>
<h4 id="递归-2">递归</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">inorderTraversal</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">inorderTraversal</span>(root.<span class="property">left</span>);</span><br><span class="line">  <span class="keyword">yield</span> root.<span class="property">value</span>;</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">inorderTraversal</span>(root.<span class="property">right</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="title function_">inorderTraversal</span>(root)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代-2">迭代</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> curNode = root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (curNode !== <span class="literal">null</span> || stack.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.<span class="title function_">push</span>(curNode);</span><br><span class="line">      curNode = curNode.<span class="property">left</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curNode = stack.<span class="title function_">pop</span>();</span><br><span class="line">      result.<span class="title function_">push</span>(curNode.<span class="property">val</span>);</span><br><span class="line">      curNode = curNode.<span class="property">right</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<p>左子树 → 右子树 → 根节点</p>
<h4 id="递归-3">递归</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">postorderTraversal</span>(<span class="params">root</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">postorderTraversal</span>(root.<span class="property">left</span>)</span><br><span class="line">  <span class="keyword">yield</span>* <span class="title function_">postorderTraversal</span>(root.<span class="property">right</span>)</span><br><span class="line">  <span class="keyword">yield</span> root.<span class="property">value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> <span class="title function_">postorderTraversal</span>(root)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代-3">迭代</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> node;</span><br><span class="line">  stack.<span class="title function_">push</span>(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (stack.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    node = stack.<span class="title function_">pop</span>();</span><br><span class="line">    result.<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">left</span>) stack.<span class="title function_">push</span>(node.<span class="property">left</span>); <span class="comment">// 注意与前序遍历的不同</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">right</span>) stack.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">reverse</span>(); <span class="comment">// 注意与前序遍历的不同</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历">广度优先遍历</h2>
<p>二叉树的广度优先遍历又称按层次遍历。算法借助队列实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(root === <span class="literal">null</span>) <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> queue = [root]</span><br><span class="line">  <span class="keyword">let</span> levelLength</span><br><span class="line">  <span class="keyword">let</span> levelNumber</span><br><span class="line">  <span class="keyword">while</span>(queue.<span class="property">length</span> !== <span class="number">0</span>)&#123;</span><br><span class="line">    levelNumber = []</span><br><span class="line"></span><br><span class="line">    levelLength = queue.<span class="property">length</span> <span class="comment">// 记录层节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; levelLength; i++)&#123;</span><br><span class="line">      <span class="keyword">let</span> curNode = queue.<span class="title function_">shift</span>()</span><br><span class="line"></span><br><span class="line">      levelNumber.<span class="title function_">push</span>(curNode.<span class="property">val</span>)        <span class="comment">// 存储每一层的节点</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(curNode.<span class="property">left</span>)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(curNode.<span class="property">left</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(curNode.<span class="property">right</span>)&#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(curNode.<span class="property">right</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.<span class="title function_">push</span>(levelNumber)        <span class="comment">// 把每一层的结果放到结果数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">Wikipedia. 二叉树.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>前序遍历</tag>
        <tag>中序遍历</tag>
        <tag>后序遍历</tag>
        <tag>层序遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>链表-单向链表</title>
    <url>/dataStructure-Singly-Linked-Lists/</url>
    <content><![CDATA[<h2 id="前置知识">前置知识</h2>
<h3 id="链表">链表</h3>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中，<strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E6%A8%99_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">指针</a>(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的<a href="https://zh.wikipedia.org/wiki/%E8%A4%87%E9%9B%9C%E5%BA%A6">复杂度</a>，比另一种线性表<a href="https://zh.wikipedia.org/wiki/%E9%A1%BA%E5%BA%8F%E8%A1%A8">顺序表</a>快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>
<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
<p>–Wikipedia. 链表</p>
</blockquote>
<span id="more"></span>
<h3 id="单向链表">单向链表</h3>
<blockquote>
<p><strong>单向链表</strong>（又名单链表、线性链表）是<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>的一种，其特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读取。</p>
<p>一个单向链表的节点被分成两个部分。第一个部分保存或者显示关于节点的信息，第二个部分存储下一个节点的地址。单向链表只可向一个方向遍历。</p>
</blockquote>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Link_zh.png" alt=""></p>
<h3 id="头指针与头结点的异同">头指针与头结点的异同</h3>
<h4 id="头指针">头指针</h4>
<ul>
<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>
<li>头指针具有标识作用，所以常用头指针冠以链表的名字</li>
<li>无论链表是否为空，头指针均不为空。头指针是链表的必要元素</li>
</ul>
<h4 id="头结点">头结点</h4>
<ul>
<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义(也可存放链表的长度)</li>
<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>
<li>头结点不一定是链表必须要素</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<div class="note warning"><p>使用参数收集符(<strong>…args</strong>)，感觉使用了顺序链表(数组)，有点循环套娃的感觉</p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singly Linked Lists</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>; <span class="comment">// first/head/root 结点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>; <span class="comment">// 结点总数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在单向链表末端新增结点, 返回新的链表长度</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> args) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">root</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">        <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">          currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentNode.<span class="property">next</span> = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">root</span> = node;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表末端删除结点, 返回结点值</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode &amp;&amp; currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断是不是只有一个结点</span></span><br><span class="line">      <span class="keyword">while</span> (currentNode &amp;&amp; currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="comment">// 到达最后一个结点</span></span><br><span class="line">        prevNode = currentNode;</span><br><span class="line">        currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNode.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentNode) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">      <span class="keyword">return</span> currentNode.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表开端新增结点, 返回新链表长</span></span><br><span class="line">  <span class="title function_">unshift</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = args.<span class="property">length</span> - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(args[index]);</span><br><span class="line">      node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在单向链表开端删除结点, 返回结点值</span></span><br><span class="line">  <span class="title function_">shift</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">root</span> = first.<span class="property">next</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">      <span class="keyword">return</span> first.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按值搜索结点，返回其索引值,未找到则返回-1</span></span><br><span class="line">  <span class="title function_">indexOf</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>, i = <span class="number">0</span>; currentNode; i++, currentNode = currentNode.<span class="property">next</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按索引值删除单向链表的值, 返回结点值, 不存在返回undefined</span></span><br><span class="line">  <span class="title function_">removeByIndex</span>(<span class="params">index = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>.<span class="property">next</span>, i = <span class="number">1</span>; currentNode; i++, currentNode = currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === index) &#123;</span><br><span class="line">        prevNode.<span class="property">next</span> = currentNode.<span class="property">next</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span>--;</span><br><span class="line">        <span class="keyword">return</span> currentNode.<span class="property">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNode = currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取第i个元素的值, 不存在则返回undefined</span></span><br><span class="line">  <span class="title function_">getItemByIndex</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>, i = <span class="number">0</span>; currentNode; i++, currentNode = currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentNode.<span class="property">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在第i个位置之前插入新结点, 返回新链表长, 位置比链表长大则在链表末端新增, 位置小于0，则重置为0</span></span><br><span class="line">  <span class="title function_">insertBefore</span>(<span class="params">position = <span class="number">0</span>, ...args</span>) &#123;</span><br><span class="line">    position &lt; <span class="number">0</span> &amp;&amp; (position = <span class="number">0</span>); <span class="comment">// 重置负值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">unshift</span>(...args);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prevNode = <span class="variable language_">this</span>.<span class="property">root</span>;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">root</span>.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; currentNode; i++, currentNode = currentNode.<span class="property">next</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i === position) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> args) &#123;</span><br><span class="line">          <span class="keyword">const</span> insertNode = <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">          prevNode.<span class="property">next</span> = insertNode;</span><br><span class="line">          insertNode.<span class="property">next</span> = currentNode;</span><br><span class="line">          prevNode = insertNode;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">size</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prevNode = currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">push</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整表删除, 不用担心循环引用垃圾回收的问题</span></span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kinsiyLinkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">push</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">pop</span>()); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">unshift</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">shift</span>()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">removeByIndex</span>(<span class="number">7</span>)); <span class="comment">// undefined 越界了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">indexOf</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">getItemByIndex</span>(<span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList.<span class="title function_">insertBefore</span>(-<span class="number">5</span>, <span class="string">&quot;kinsiy&quot;</span>, <span class="string">&quot;qing&quot;</span>)); <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">kinsiyLinkedList.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(kinsiyLinkedList); <span class="comment">// LinkedList &#123;root: null, size: 0&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://adrianmejia.com/data-structures-time-complexity-for-beginners-arrays-hashmaps-linked-lists-stacks-queues-tutorial/#Linked-Lists">AdrianMejia. Data Structures in JavaScript: Arrays, HashMaps, and Lists. </a></p>
<p>[2] <a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构.</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>单向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与队列</title>
    <url>/dataStructure-Stack-Queue/</url>
    <content><![CDATA[<div class="note primary"><p>在Javascript中实际使用时，使用Array的push(), pop()模拟栈操作；使用push(), shift()模拟队列操作即可。</p>
</div>
<blockquote>
<p>数组是一种类列表对象，它的原型中提供了遍历和修改元素的相关操作。JavaScript 数组的长度和元素类型都是非固定的。<strong>因为数组的长度可随时改变，并且其数据在内存中也可以不连续，所以 JavaScript 数组不一定是密集型的，这取决于它的使用方式</strong></p>
<p>——MDN. Array</p>
</blockquote>
<h3 id="堆栈">堆栈</h3>
<blockquote>
<p><strong>堆栈</strong>（英语：stack）又称为<strong>栈</strong>或<strong>堆叠</strong>，是<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>中的一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象资料类型</a>，只允许在有序的线性资料集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
<p>——Wikipedia. 堆栈</p>
</blockquote>
<span id="more"></span>
<h4 id="实现-Ⅰ">实现 Ⅰ</h4>
<p>使用与单向链表类似的结构来存储栈元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_top</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 压栈，返回新的栈长</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stackNode = <span class="keyword">new</span> <span class="title class_">StackNode</span>(value);</span><br><span class="line">    stackNode.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">_top</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_top</span> = stackNode;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈，返回出栈元素值</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> popNode = <span class="variable language_">this</span>.<span class="property">_top</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (popNode) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_top</span> = popNode.<span class="property">next</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> popNode.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_top</span>.<span class="property">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈长</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">pop</span>());        <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;kinsiy&quot;</span>));        <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;stack&quot;</span>));        <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;push&quot;</span>));        <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>());        <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>());        <span class="comment">// push</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">pop</span>());        <span class="comment">// push</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>());        <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>());        <span class="comment">// stack</span></span><br></pre></td></tr></table></figure>
<h4 id="实现-Ⅱ">实现 Ⅱ</h4>
<p>使用一个内部对象存储栈元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">capacity = <span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_capacity</span> = capacity;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_storage</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 压栈，返回新的栈长</span></span><br><span class="line">  <span class="title function_">push</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_size</span> &lt; <span class="variable language_">this</span>.<span class="property">_capacity</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_size</span>] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Max capacity already reached. Remove element before adding a new one.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出栈，返回出栈元素</span></span><br><span class="line">  <span class="title function_">pop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_size</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">size</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈顶元素</span></span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_size</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回栈长</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">pop</span>()); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;stack&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">push</span>(<span class="string">&quot;push&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>()); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>()); <span class="comment">// push</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">pop</span>()); <span class="comment">// push</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stack.<span class="title function_">peek</span>()); <span class="comment">// stack</span></span><br></pre></td></tr></table></figure>
<h3 id="队列">队列</h3>
<blockquote>
<p><strong>队列</strong>，又称为<strong>伫列</strong>（queue），<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">计算机科学</a>中的一种<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">抽象资料型别</a>，是<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA%E6%BC%94%E7%AE%97%E6%B3%95">先进先出</a>（FIFO, First-In-First-Out）的<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a>。在具体应用中通常用<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表</a>或者<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%BB%84">数组</a>来实现。队列只允许在后端（称为<em>rear</em>）进行插入操作，在前端（称为<em>front</em>）进行删除操作。</p>
<p>队列的操作方式和<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<p>——Wikipedia. 队列</p>
</blockquote>
<h4 id="实现-Ⅰ-2">实现 Ⅰ</h4>
<p>使用类似单向链表的结构存储队列元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QueueNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队，并返回新的队列长</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> queueNode = <span class="keyword">new</span> <span class="title class_">QueueNode</span>(value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_head</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_head</span> = queueNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_tail</span> = queueNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_tail</span>.<span class="property">next</span> = queueNode;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_tail</span> = queueNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队，返回出队元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dequeueNode = <span class="variable language_">this</span>.<span class="property">_head</span>;</span><br><span class="line">    <span class="keyword">if</span> (dequeueNode) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_head</span> = dequeueNode.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (dequeueNode === <span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="variable language_">this</span>.<span class="property">_head</span>; <span class="comment">// 队列只有一个元素时，队尾元素也要置空</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_size</span>--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> dequeueNode.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列长</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列是否包含某一元素</span></span><br><span class="line">  <span class="title function_">contains</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> currentNode = <span class="variable language_">this</span>.<span class="property">_head</span>;</span><br><span class="line">    <span class="keyword">while</span> (currentNode) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentNode.<span class="property">value</span> === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      currentNode = currentNode.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;stack&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;push&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">contains</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">contains</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="实现-Ⅱ-2">实现 Ⅱ</h4>
<p>使用一个内部对象存储队列元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">capacity = <span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_capacity</span> = capacity;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_storage</span> = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_head</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队，并返回新的队列长</span></span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_size</span> &gt;= <span class="variable language_">this</span>.<span class="property">_capacity</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Max capacity already reached. Remove element before adding a new one.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_tail</span>] = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_tail</span>++;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_size</span>++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 出队，返回出队元素</span></span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_head</span>];</span><br><span class="line">    <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">_storage</span>[<span class="variable language_">this</span>.<span class="property">_head</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_head</span> &lt; <span class="variable language_">this</span>.<span class="property">_tail</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_head</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列长</span></span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回队列是否包含某一元素</span></span><br><span class="line">  <span class="title function_">contains</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">_head</span>; i &lt; <span class="variable language_">this</span>.<span class="property">_tail</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_storage</span>[i] === value) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;stack&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">enqueue</span>(<span class="string">&quot;push&quot;</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">contains</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">dequeue</span>()); <span class="comment">// kinsiy</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">size</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(queue.<span class="title function_">contains</span>(<span class="string">&quot;kinsiy&quot;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="参考">参考</h3>
<p>[1]<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">Wikipedia. 堆栈</a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">Wikipedia. 队列</a></p>
<p>[3]<a href="https://medium.com/@_jmoller/javascript-data-structures-stacks-and-queues-ea877d72a5f9">Jorge Moller. Medium.com. Javascript Data Structures: Stack and Queue</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法-Ⅰ</title>
    <url>/dataStructure-sort-%E2%85%A0/</url>
    <content><![CDATA[<h2 id="排序基本概念">排序基本概念</h2>
<div class="note primary"><p>本文未指定出处的引用均出自 <a href="https://book.douban.com/subject/6424904/">大话数据结构</a></p>
</div>
<h3 id="严格定义">严格定义</h3>
<blockquote>
<p>假设含有n个记录的序列为{r<sub>1</sub>, r<sub>2</sub>, … , r<sub>n</sub>}, 其相应的关键字分别为{k<sub>1</sub>, k<sub>2</sub>, … , k<sub>n</sub>}, 需确定1, 2, …, n 的一种排列p<sub>1</sub>, p<sub>2</sub>, …, p<sub>n</sub>, 使其相应的关键字满足k<sub>p1</sub> ≤ k<sub>p2</sub> ≤ … ≤ k<sub>pn</sub> (非递减或非递增)关系，即使得序列成为一个按关键字有序得序列{r<sub>p1</sub>, r<sub>p2</sub>, …, r<sub>pn</sub>}, 这样得操作就称为排序</p>
</blockquote>
<h3 id="稳定性">稳定性</h3>
<blockquote>
<p>假设k<sub>i</sub> = k<sub>j</sub> (1 ≤ i ≤ n, 1 ≤ j ≤ n, i ≠ j)，且在排序前的序列中r<sub>i</sub>领先于r<sub>j</sub> (即 i ＜ j)。如过排序后 r <sub>i</sub> 仍然领先于 r<sub>j</sub> ，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 r<sub>j</sub> 领先于 r<sub>i</sub> ，则称所用的排序方法是不稳定的。</p>
</blockquote>
<p>也就是如果一个排序算法是稳定的，当有两个相等键值的纪录<strong>R</strong>和<strong>S</strong>，且在原本的列表中<strong>R</strong>出现在<strong>S</strong>之前，在排序过的列表中<strong>R</strong>也将会是在<strong>S</strong>之前。</p>
<span id="more"></span>
<h3 id="原地算法">原地算法</h3>
<blockquote>
<p>在计算机科学中，一个原地算法（in-place algorithm，也称“就地算法”）是基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。不过，分配少量空间给部分辅助变量是被允许的。算法执行过程中，输入的数据往往会被输出结果覆盖。原地算法只能通过替换或交换元素的方式来修改原始的输入。不满足“原地”原则的算法也被称为非原地（not-in-place）算法或异地（out-of-place）算法。</p>
<p>——wikipedia. 原地算法</p>
</blockquote>
<h2 id="冒泡排序">冒泡排序</h2>
<blockquote>
<p>冒泡排序(Bubble Sort) 一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = array.<span class="property">length</span> - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">        [array[j - <span class="number">1</span>], array[j]] = [array[j], array[j - <span class="number">1</span>]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bubbleSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [0, 4, 16, 31, 32, 34, 84, 95, 97, 99]</span></span><br></pre></td></tr></table></figure>
<h3 id="优化">优化</h3>
<p>在待排序序列仅前几个记录是无序的情况下，例如 [2, 1, 3, 4, 5, 6, 7]。添加交换标志位可减少无用比较次数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> swapFlag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span> &amp;&amp; swapFlag; i++) &#123;</span><br><span class="line">    swapFlag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = array.<span class="property">length</span> - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j - <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">        [array[j - <span class="number">1</span>], array[j]] = [array[j], array[j - <span class="number">1</span>]];</span><br><span class="line">        swapFlag = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">bubbleSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [7, 9, 25, 43, 54, 55, 59, 82, 89, 96]</span></span><br></pre></td></tr></table></figure>
<h2 id="简单选择排序">简单选择排序</h2>
<blockquote>
<p>简单选择排序(Simple Selection Sort) 就是通过 n - i 次关键字间的比较，从 n - i + 1 个记录中选出关键字最小的记录，并和第 i (1 ≤ i ≤ n) 个记录交换之</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleSelectSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i !== minIndex) &#123;</span><br><span class="line">      [array[i], array[minIndex]] = [array[minIndex], array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">simpleSelectSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [5, 25, 34, 39, 55, 65, 70, 82, 86, 94]</span></span><br></pre></td></tr></table></figure>
<h2 id="直接插入排序">直接插入排序</h2>
<blockquote>
<p>直接插入排序(Straight Insertion Sort) 的基本操作就是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insertSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = array[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = i - <span class="number">1</span>; array[j] &gt; value; j--) &#123;</span><br><span class="line">        array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">      &#125;</span><br><span class="line">      array[j + <span class="number">1</span>] = value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** 可以不声明变量</span></span><br><span class="line"><span class="comment">       * let j;</span></span><br><span class="line"><span class="comment">       * for (j = i - 1; array[j] &gt; array[j + 1]; j--) &#123;</span></span><br><span class="line"><span class="comment">       *  [array[j + 1], array[j]] = [array[j], array[j + 1]];</span></span><br><span class="line"><span class="comment">       * &#125;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">insertSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort);</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序">希尔排序</h2>
<blockquote>
<p>希尔排序（Shellsort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>——wikipedid. 希尔排序</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shellSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">evenGap</span> = (<span class="params">i</span>) =&gt; <span class="number">9</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">4</span>, i) - <span class="number">9</span> * <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, i) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">oddGap</span> = (<span class="params">i</span>) =&gt; <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, i + <span class="number">2</span>) * (<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, i + <span class="number">2</span>) - <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> gapList = [];</span><br><span class="line">  <span class="keyword">let</span> gap;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    gap = <span class="title function_">evenGap</span>(n);</span><br><span class="line">    gap &lt;= array.<span class="property">length</span> &amp;&amp; gapList.<span class="title function_">unshift</span>(gap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gap = <span class="title function_">oddGap</span>(n);</span><br><span class="line">    gap &lt;= array.<span class="property">length</span> &amp;&amp; gapList.<span class="title function_">unshift</span>(gap);        <span class="comment">// unshift 方便下面遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n++;</span><br><span class="line">  &#125; <span class="keyword">while</span> (gap &lt; array.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(gapList); <span class="comment">// (1, 5, 19, 41, 109,...) 的反序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上半部分只是为了生成已知最好的步长序列，下面才是排序的主要代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> gap <span class="keyword">of</span> gapList) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> tempValue = array[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; tempValue; j -= gap) &#123; <span class="comment">// gap定好这里无需 &gt;= 0</span></span><br><span class="line">        array[j + gap] = array[j];</span><br><span class="line">      &#125;</span><br><span class="line">      array[j + gap] = tempValue;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/** 可以不声明变量</span></span><br><span class="line"><span class="comment">       * let j;</span></span><br><span class="line"><span class="comment">       * for (j = i - gap; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + gap]; j -= gap) &#123;</span></span><br><span class="line"><span class="comment">       *  [array[j + gap], array[j]] = [array[j], array[j + gap]];</span></span><br><span class="line"><span class="comment">       * &#125;</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">shellSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为普通插入排序，这就保证了数据一定会被排序。</p>
<p>Donald Shell最初建议步长选择为 n/2 并且对步长取半直到步长达到1。虽然这样取可以比  O (n<sup>2</sup>) 类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地</p>
<p>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项，从第0项开始，偶数来自9 * 4<sup>i</sup> - 9 * 2<sup>i</sup> +1 和奇数来自 2<sup>i+2</sup> * (2<sup>i+2</sup> - 3) +1 这两个算式这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p>另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)</p>
<p>——wikipedia. 希尔排序</p>
</blockquote>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构. </a></p>
<p>[2] <a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikepedia. 排序算法</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>简单选择排序</tag>
        <tag>直接插入排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/dataStructure-tree/</url>
    <content><![CDATA[<h3 id="树的定义">树的定义</h3>
<blockquote>
<p>树(Tree)是n(n ≥ 0)个结点的有限集。n = 0时称为空树。在任意一颗非空树中：</p>
<ol>
<li>有且仅有一个特定的称为根(Root)的结点；</li>
<li>当 n ＞ 1 时，其余结点可分为  m (m ＞ 0)个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub> , 其中每一个集合本身又是一棵树，并且称为根的子树</li>
</ol>
<p>——程杰. 《大话数据结构》</p>
</blockquote>
<span id="more"></span>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/637px-Treedatastructure.png" alt=""></p>
<h3 id="术语">术语</h3>
<blockquote>
<ol>
<li>节点的度： 一个节点含有的子树的个数称为该节点的度</li>
<li>树的度：一颗树中，最大的节点度称为树的度</li>
<li>叶节点或终端节点：度为零的节点</li>
<li>非终端节点或分支节点：度不为零的节点</li>
<li>双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的双亲结点</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点</li>
<li>节点的层次：从根开始定义起，根为第一层，根的子节点为第二层，以此类推</li>
<li>深度：对于任意节点n，n的深度为从根到 n的唯一路径长，<strong>根的深度为 0</strong></li>
<li>高度：对于任意节点n，n 的高度为从 n 到一片树叶的最长路径长，<strong>所有树叶的高度为 0</strong></li>
<li>堂兄弟节点：父节点在同一层节点互为堂兄弟</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙</li>
<li>森林：由m (m ≥ 0) 棵互不相交的树的集合称为森林</li>
</ol>
<p>——Wikipedia. 树(数据结构)</p>
</blockquote>
<h3 id="树的存储结构">树的存储结构</h3>
<h4 id="双亲表示法">双亲表示法</h4>
<p>双亲表示法采用顺序表(也就是数组)存储无序树，其实现的核心思想是：顺序存储各个节点的同时，给各节点附加一个双亲域，指向其双亲</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Sqll.jpg" alt=""></p>
<p>我们平时前后台交互传输的扁平树就是这里说的双亲表示法。在双亲的基础上还可以添加更多指针域，像长子域、右兄弟域等以满足要求</p>
<h4 id="孩子表示法">孩子表示法</h4>
<p>把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子节点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Hzll.jpg" alt=""></p>
<p>常见的普通树状结构数据就是以这种表示法表示的，只不过链表用 Array 代替，但在Javascript中数组也不尽是按顺序存储的，个人觉得也算一种链表。</p>
<h4 id="孩子兄弟表示法">孩子兄弟表示法</h4>
<p>对任意一棵树，它得节点的第一个孩子如果存在就是唯一的，它得右兄弟如果存在也是唯一的。因此，可以设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Hzxd.jpg" alt=""></p>
<p>此表示法是树和二叉树变换的介质</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/design-pattern-abstract-factory/</url>
    <content><![CDATA[<p>抽象工厂模式是一种创建型设计模式,它能创建一系列相关的对象,而无需指定具体</p>
<p>抽象工厂模式建议为系列中的每件产品明确声明接口.然后,确保所有产品变体都继承这些接口</p>
<pre><code class="highlight mermaid">classDiagram
class Chair &#123;
	&lt;&lt;interface&gt;&gt;
	+ hasLegs()
	+ sitOn()
&#125;

class VictorianChair &#123;
	+ hasLegs()
	+ sitOn()
&#125;

class ModernChair &#123;
  + hasLegs()
  + sitOn()
&#125;

Chair &lt;|.. VictorianChair
Chair &lt;|.. ModernChair</code></pre>
<p>同一对象的所有变体都必须放置在同一个类层次结构之中.</p>
<span id="more"></span>
<p>接下来,需要声明抽象工厂–包含系列中所有产品构造方法的接口.这些方法<mark class="label primary">必须返回抽象产品类</mark></p>
<pre><code class="highlight mermaid">classDiagram
class FurnitureFactory &#123;
&lt;&lt;interface&gt;&gt;
+ createChair(): Chair
+ createCoffeeTable(): CoffeeTable
+ createSofa(): Sofa
&#125;

class VictorianFurnitureFactory &#123;
+ createChair(): Chair
+ createCoffeeTable(): CoffeeTable
+ createSofa(): Sofa
&#125;

class ModernFurnitureFactory &#123;
+ createChair(): Chair
+ createCoffeeTable(): CoffeeTable
+ createSofa(): Sofa
&#125;

FurnitureFactory &lt;|.. VictorianFurnitureFactory
FurnitureFactory &lt;|.. ModernFurnitureFactory
</code></pre>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系列产品中的特定产品必须有一个基础接口.所有产品变体都必须实现这个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品由相应的具体工厂创建</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rendering Windows button...&quot;</span>);	<span class="comment">// 根据 windows 样式渲染按钮</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacButton</span> <span class="keyword">implements</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rendering Mac button...&quot;</span>); <span class="comment">// 根据 MacOS 样式渲染按钮</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个产品的基础接口.所有产品都可以互动, 但是只有相同具体变体的产品之间才能够正确地进行交互</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rendering Windows checkbox...&quot;</span>);	<span class="comment">// 根据 Windows 样式渲染复选框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacCheckbox</span> <span class="keyword">implements</span> <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Rendering Mac checkbox...&quot;</span>); <span class="comment">// 根据 MacOS 样式渲染复选框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法.这些产品属于同一个系列</span></span><br><span class="line"><span class="comment">// 且在高层主题或概念上具有相关性.同系列的产品通常能够相互搭配使用.</span></span><br><span class="line"><span class="comment">// 系列产品可有多个变体,但不同变体的产品不能搭配使用</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createButton</span>(): <span class="title class_">Button</span>;</span><br><span class="line">  <span class="title function_">createCheckbox</span>(): <span class="title class_">Checkbox</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂可生成属于同一变体的系列产品.工厂会确保其创建的产品能相互搭配使用</span></span><br><span class="line"><span class="comment">// 具体工厂方法签名会返回一个抽象产品,但在方法内部则会对具体产品进行实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsGUIFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createButton</span>(): <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsButton</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createCheckbox</span>(): <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsCheckbox</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个具体工厂中都会包含一个相应的产品变体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacGUIFactory</span> <span class="keyword">implements</span> <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createButton</span>(): <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacButton</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createCheckbox</span>(): <span class="title class_">Checkbox</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacCheckbox</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OSType</span> &#123;</span><br><span class="line">  <span class="variable constant_">WINDOWS</span>,</span><br><span class="line">  <span class="variable constant_">MAC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码仅通过抽象类型(GUIFactory, Button 和 Checkbox) 使用工厂和产品</span></span><br><span class="line"><span class="comment">// 这让你无需修改任何工厂或产品子类就能将其传递给客户端代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GUIFactoryProvider</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getFactory</span>(<span class="attr">osType</span>: <span class="title class_">OSType</span>): <span class="title class_">GUIFactory</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (osType) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">OSType</span>.<span class="property">WINDOWS</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowsGUIFactory</span>();</span><br><span class="line">      <span class="keyword">case</span> <span class="title class_">OSType</span>.<span class="property">MAC</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MacGUIFactory</span>();</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unsupported OS type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="comment">// 程序会根据当前配置或环境设定选择工厂类型,并在运行时创建工厂(通常在初始化阶段)</span></span><br><span class="line"><span class="keyword">const</span> osType = <span class="title class_">OSType</span>.<span class="property">WINDOWS</span>;</span><br><span class="line"><span class="keyword">const</span> factory = <span class="title class_">GUIFactoryProvider</span>.<span class="title function_">getFactory</span>(osType);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = factory.<span class="title function_">createButton</span>();</span><br><span class="line"><span class="keyword">const</span> checkbox = factory.<span class="title function_">createCheckbox</span>();</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">render</span>(); <span class="comment">// Output: Rendering Windows button...</span></span><br><span class="line">checkbox.<span class="title function_">render</span>(); <span class="comment">// Output: Rendering Windows checkbox...</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>代码需要与多个不同系列的相关产品交互,但是由于无法提前获取相关信息,或者出于对未来拓展性的考虑,你不希望代码基于产品的具体类进行构建,在这种情况下,可以使用抽象工厂</li>
<li>如果有一个基于一组抽象方法的类,且其主要功能因此变得不明确,那么在这种情况下可以考虑使用抽象工厂模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以确保同一工厂生成的产品相互匹配</li>
<li>可以避免客户端和具体产品代码的耦合</li>
<li>单一职责原则. 你可以将产品生成代码抽取到同一位置,使得代码易于维护</li>
<li>开闭原则. 向应用程序中引入新产品变体时, 你无需修改客户端代码</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>由于采用该模式需要向应用中引入众多接口和类, 代码可能会比之前更加复杂</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/abstract-factory">Refactoringguru.cn 抽象工厂模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>abstract-factory</tag>
        <tag>factory-method</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法 - Ⅱ</title>
    <url>/dataStructure-sort-%E2%85%A1/</url>
    <content><![CDATA[<h2 id="排序算法-Ⅱ">排序算法 - Ⅱ</h2>
<p>排序基础-Ⅰ 学习了冒泡排序、简单选择排序、直接插入排序以及希尔排序(直接插入排序的升级)。Ⅱ 学习堆排序(简单选择排序的升级)、归并排序以及快速排序(冒泡排序的升级)</p>
<div class="note primary"><p>本文未指定出处的引用均出自 <a href="https://book.douban.com/subject/6424904/">大话数据结构</a></p>
</div>
<h3 id="堆排序">堆排序</h3>
<blockquote>
<p>堆是具有下列性质的完全二叉树：每个节点的值都大于或等于其左右孩子的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p>
<p>堆排序(Heap Sort)就是利用堆(假设利用大顶堆)进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是对顶的根节点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩余的 n - 1 个序列重新构造成一个堆，这样会得到 n 个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
</blockquote>
<span id="more"></span>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(array.<span class="property">length</span> / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 完全二叉树性质，从最后一个双亲节点开始遍历</span></span><br><span class="line">    <span class="title function_">heapAdjust</span>(array, i, array.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = array.<span class="property">length</span> - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">    [array[<span class="number">0</span>], array[j]] = [array[j], array[<span class="number">0</span>]];</span><br><span class="line">    <span class="title function_">heapAdjust</span>(array, <span class="number">0</span>, j - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapAdjust</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> parents = start;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> child = <span class="number">2</span> * parents + <span class="number">1</span>; child &lt;= end; child = <span class="number">2</span> * child + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 完全二叉树性质，定位子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child + <span class="number">1</span> &lt;= end &amp;&amp; array[child] &lt; array[child + <span class="number">1</span>]) ++child; <span class="comment">// 找出左右子节点中最大的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (array[parents] &gt;= array[child]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 因为是从最后一个双亲节点开始遍历的，可以保证当上层满足双亲节点大于子节点时，整个子树满足大顶堆要求</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [array[parents], array[child]] = [array[child], array[parents]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    parents = child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">heapSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">//  [13, 33, 47, 52, 57, 64, 68, 84, 87, 98]</span></span><br></pre></td></tr></table></figure>
<h3 id="归并排序">归并排序</h3>
<blockquote>
<p>归并排序(Merging Sort) 就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有 n 个记录，则可以 看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 ⌈ n/2 ⌉ ( ⌈ x ⌉ 表示不小于 x 的最小整数)个长度为 2 或 1 的有序子序列；再两两归并，…，如此反复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<h4 id="递归实现">递归实现</h4>
<blockquote>
<ol>
<li>申请空间，使其大小为两个排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤 3 直到某一指针到达序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol>
<p>—— Wikipedia. 归并排序</p>
</blockquote>
<h5 id="实现-Ⅰ">实现 Ⅰ</h5>
<p>这种写法每次递归仅声明一个数组，巧妙利用下标复用数组，改变原数组。应该是较省内存的 <strong>(未实测)</strong> ，但是理解起来比较麻烦</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array, result, start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (start === end) &#123;</span><br><span class="line">    result[start] = array[start];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将array，平分为 array[start, middle]和 array[middle + 1, end]</span></span><br><span class="line">    <span class="keyword">const</span> supResult = [];</span><br><span class="line">    <span class="title function_">mergeSort</span>(array, supResult, start, middle);</span><br><span class="line">    <span class="comment">// 递归将 array[start, middle]归并为有序的 supResult[start, middle]</span></span><br><span class="line">    <span class="title function_">mergeSort</span>(array, supResult, middle + <span class="number">1</span>, end);</span><br><span class="line">    <span class="comment">// 递归将 array[middle + 1, end]归并为有序的 supResult[middle + 1, end]</span></span><br><span class="line">    <span class="title function_">merge</span>(result, supResult, start, middle, end);</span><br><span class="line">    <span class="comment">// 将 supResult[start, middle] 和 supResult[middle + 1, end] 归并到 result[start, end]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将有序的supResult[start,middle]和supResult[middle+1, end] 归并为有序的 result[Start, end]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">result, supResult, start, middle, end</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> curIndex = start;</span><br><span class="line">  <span class="keyword">let</span> left, right;</span><br><span class="line">  <span class="keyword">for</span> (left = start, right = middle + <span class="number">1</span>; left &lt;= middle &amp;&amp; right &lt;= end; curIndex++) &#123;</span><br><span class="line">    <span class="comment">// 将supResult 中记录由小到大归并到Result</span></span><br><span class="line">    <span class="keyword">if</span> (supResult[left] &lt;= supResult[right]) &#123;</span><br><span class="line">      result[curIndex] = supResult[left++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result[curIndex] = supResult[right++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (left &lt;= middle) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= middle - left; i++) &#123;</span><br><span class="line">      result[curIndex + i] = supResult[left + i]; <span class="comment">// 将剩余的supResult 复制到 result</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (right &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= end - right; j++) &#123;</span><br><span class="line">      result[curIndex + j] = supResult[right + j]; <span class="comment">// 将剩余的supResult 复制到 result</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">mergeSort</span>(sort, sort, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [7, 11, 24, 27, 27, 40, 46, 48, 51, 88]</span></span><br></pre></td></tr></table></figure>
<h5 id="实现-Ⅱ">实现 Ⅱ</h5>
<p>这种写法就很直接，也好理解，但是申请了较多的空间(变量)，并且返回的数组并不是原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (array.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">  <span class="keyword">const</span> middle = array.<span class="property">length</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> left = array.<span class="title function_">slice</span>(<span class="number">0</span>, middle);</span><br><span class="line">  <span class="keyword">const</span> right = array.<span class="title function_">slice</span>(middle);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(<span class="title function_">mergeSort</span>(left), <span class="title function_">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; right.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result.<span class="title function_">push</span>(...left, ...right);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sortResult = <span class="title function_">mergeSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortResult); <span class="comment">// [0, 5, 16, 17, 27, 38, 52, 54, 72, 82]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sortResult === sort); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代实现">迭代实现</h4>
<blockquote>
<ol>
<li>将序列每相邻两个数字进行归并操作，形成⌈ n/2 ⌉ 个序列，排序后每个序列包含两/一个元素</li>
<li>若此时序列数不是 1 则将上述序列再次归并，形成⌈ n/4 ⌉个序列，每个序列包含四/三个元素</li>
<li>重复步骤 2，直到所有元素排序完毕，即序列数为 1</li>
</ol>
<p>——Wikipedia. 归并排序</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> windowLength = <span class="number">1</span>; <span class="comment">// 初始窗口长度为1</span></span><br><span class="line">    <span class="keyword">while</span> (windowLength &lt; array.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="title function_">mergeByWindow</span>(result, array, windowLength, array.<span class="property">length</span>);</span><br><span class="line">        <span class="comment">// 当前窗口 array 有序，result 存储归并后结果</span></span><br><span class="line"></span><br><span class="line">        windowLength *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">mergeByWindow</span>(array, result, windowLength, array.<span class="property">length</span>);</span><br><span class="line">        <span class="comment">// 当前窗口 result有序， array 存储归并后结果</span></span><br><span class="line"></span><br><span class="line">        windowLength *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按窗口长度，将有序的supResult，归并为有序的result</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeByWindow</span>(<span class="params">result, supResult, windowLength, arrayLength</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index &lt;= arrayLength - <span class="number">2</span> * windowLength) &#123;</span><br><span class="line">        <span class="comment">// 保证能够归并两个窗口长度的数据，不足部分则作为独立窗口归并</span></span><br><span class="line">        <span class="title function_">merge</span>(result, supResult, index, index + windowLength - <span class="number">1</span>, index + <span class="number">2</span> * windowLength - <span class="number">1</span>);</span><br><span class="line">        index = index + <span class="number">2</span> * windowLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index + windowLength &lt; arrayLength) &#123;</span><br><span class="line">        <span class="comment">// 最后剩两个序列时，index + window 必然小于数组长度</span></span><br><span class="line">        <span class="title function_">merge</span>(result, supResult, index, index + windowLength - <span class="number">1</span>, arrayLength - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则只剩下单个子序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = index + <span class="number">1</span>; j &lt; arrayLength; j++) &#123;</span><br><span class="line">            result[j] = supResult[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上方递归实现Ⅰ 方法</span></span><br><span class="line"><span class="comment">// 将有序的supResult[start,middle]和supResult[middle+1, end] 归并为有序的 result[Start, end]</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">result, supResult, start, middle, end</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> curIndex = start;</span><br><span class="line">    <span class="keyword">let</span> left, right;</span><br><span class="line">    <span class="keyword">for</span> (left = start, right = middle + <span class="number">1</span>; left &lt;= middle &amp;&amp; right &lt;= end; curIndex++) &#123;</span><br><span class="line">        <span class="comment">// 将supResult 中记录由小到大归并到Result</span></span><br><span class="line">        <span class="keyword">if</span> (supResult[left] &lt;= supResult[right]) &#123;</span><br><span class="line">            result[curIndex] = supResult[left++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[curIndex] = supResult[right++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= middle) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= middle - left; i++) &#123;</span><br><span class="line">            result[curIndex + i] = supResult[left + i]; <span class="comment">// 将剩余的supResult 复制到 result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= end - right; j++) &#123;</span><br><span class="line">            result[curIndex + j] = supResult[right + j]; <span class="comment">// 将剩余的supResult 复制到 result</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">mergeSort</span>(sort);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [8, 21, 25, 30, 46, 47, 65, 69, 74, 93]</span></span><br></pre></td></tr></table></figure>
<h3 id="快速排序">快速排序</h3>
<blockquote>
<p>快速排序(Quick Sort)的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的</p>
</blockquote>
<div class="note primary"><p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">可视化</a></p>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sort = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> ~~(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">const</span> pivotIndex = <span class="title function_">partition</span>(array, start, end);</span><br><span class="line"></span><br><span class="line">        <span class="title function_">quickSort</span>(array, start, pivotIndex - <span class="number">1</span>); <span class="comment">// 对低子表递归排序</span></span><br><span class="line">        <span class="title function_">quickSort</span>(array, pivotIndex + <span class="number">1</span>, end); <span class="comment">// 对高子表递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换Array记录，使基准值记录到位，并返回其所在位置</span></span><br><span class="line"><span class="comment">// 在此之前（后）的记录均不大（小）于它</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">array, left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pivotValue = array[left]; <span class="comment">// 用子表第一个记录为基准值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 从表的两端交替向中间扫描</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; array[right] &gt;= pivotValue) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [array[left], array[right]] = [array[right], array[left]]; <span class="comment">// 将比基准值小的值交换到左侧</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; array[left] &lt;= pivotValue) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [array[left], array[right]] = [array[right], array[left]]; <span class="comment">// 将比基准值大的值交换到右侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">quickSort</span>(sort, <span class="number">0</span>, sort.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sort); <span class="comment">// [25, 26, 29, 41, 51, 55, 60, 62, 63, 80]</span></span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<h5 id="选取基准值">选取基准值</h5>
<blockquote>
<p><strong>三数取中(median-of-three)</strong>；即取三个关键字先进行排序，将中间数作为基准值，一般是取左端、右端和中间三个数</p>
</blockquote>
<p>partition 函数取基准值部分变换为三数取中逻辑即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middle = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">    [array[left], array[right]] = [array[right], array[left]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (array[middle] &gt; array[right]) &#123;</span><br><span class="line">    [array[middle], array[right]] = [array[right], array[middle]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (array[left] &gt; array[middle]) &#123;</span><br><span class="line">    [array[left], array[middle]] = [array[middle], array[left]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pivotValue = array[middle]; <span class="comment">// 用子表 头中尾 三个值中的中间数作为基准值</span></span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1] <a href="https://book.douban.com/subject/6424904/">程杰. 大话数据结构.</a></p>
<p>[2]<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">wikipedia. 堆排序</a></p>
<p>[3]<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">wikipedia. 归并排序</a></p>
<p>[4]<a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">wikipedia. 快速排序</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/design-pattern-bridge/</url>
    <content><![CDATA[<p><strong>桥接模式</strong> 是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立层次结构，从而能在开发时分别使用</p>
<p>抽象部分（也被称为接口）是一些实现的高阶控制层。该层自身不完成任何具体的工作，它需要将工作委派给实现部分层（也被称为平台）</p>
<div class="note warning"><p>注意，这里提到的内容与编程语言中的接口或抽象类无关。它们并不是一回事</p>
</div>
<span id="more"></span>
<h2 id="桥接模式结构">桥接模式结构</h2>
<pre><code class="highlight mermaid">classDiagram
class Client
class Abstraction &#123;
-i: Implementation
+feature1()
+feature2()
&#125;
class Implementation &#123;
&lt;&lt;interface&gt;&gt;
+method1()
+method2()
+method3()
&#125;
class Refined Abstraction &#123;
...
+fetureN()
&#125;
class Concrete Implementations
Client --&gt; Abstraction
Abstraction &lt;|-- Refined Abstraction
Abstraction o--&gt; Implementation
Implementation &lt;|.. Concrete Implementations</code></pre>
<ul>
<li><strong>抽象部分（abstraction）</strong> 提供高层控制逻辑，依赖与完成底层实际工作的实现对象</li>
<li><strong>实现部分（Implementation）</strong> 为所有具体实现声明通用接口。抽象部分仅能通过在这里声明的方法与实现对象交互</li>
<li><strong>具体实现（ConcreteImplementTations）</strong> 中包括特定于平台的代码</li>
<li><strong>精确抽象（RefinedAbstraction）</strong> 提供控制逻辑的变体。与其父类伊朗，它们通过通用实现接口与不同的实现进行交互</li>
<li>通常情况下，<strong>客户端（Client）</strong> 仅关心如何与抽象部分合作。但是客户端需要将抽象对象与一个实现对象连接起来</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理者一个指向“实现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAbstraction</span> <span class="keyword">implements</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">implementor</span>: <span class="title class_">Implementor</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">implementor: Implementor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">implementor</span> = implementor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteAbstraction.operation&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">implementor</span>.<span class="title function_">operationImpl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相匹配。</span></span><br><span class="line"><span class="comment">// 实际上，这连个接口可以完全不一样。通常实现接口只提供原语操作，而抽象接口则会基于这些操作定义较高层次的操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">  <span class="title function_">operationImpl</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The ConcreteImplementorA class that implements the Implementor interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">  <span class="title function_">operationImpl</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteImplementorA.operationImpl&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The ConcreteImplementorB class that implements the Implementor interface</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">  <span class="title function_">operationImpl</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteImplementorB.operationImpl&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The client code</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">implementorA</span>: <span class="title class_">Implementor</span> = <span class="keyword">new</span> <span class="title class_">ConcreteImplementorA</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">abstractionA</span>: <span class="title class_">Abstraction</span> = <span class="keyword">new</span> <span class="title class_">ConcreteAbstraction</span>(implementorA);</span><br><span class="line">abstractionA.<span class="title function_">operation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">implementorB</span>: <span class="title class_">Implementor</span> = <span class="keyword">new</span> <span class="title class_">ConcreteImplementorB</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">abstractionB</span>: <span class="title class_">Abstraction</span> = <span class="keyword">new</span> <span class="title class_">ConcreteAbstraction</span>(implementorB);</span><br><span class="line">abstractionB.<span class="title function_">operation</span>();</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式</li>
<li>如果你希望在几个独立维度上扩展一个类，可使用该模式</li>
<li>如果你需要在运行时切换不同的实现方法，可使用桥接模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以创建与平台无关的类和程序</li>
<li>客户端代码仅与高层抽象部分进行互动，不会接触到平台的详细信息</li>
<li>开闭原则。你可以新增抽象部分和实现部分，且它们之间不会相互影响</li>
<li>单一职责原则。抽象部分专注与处理高层逻辑，实现部分处理平台细节</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>对高内聚的类使用该模式可能会让代码更加复杂</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/bridge">Refactoringguru.cn 桥接模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>bridge</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/design-pattern-adapter/</url>
    <content><![CDATA[<p><strong>适配器模式</strong>是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。</p>
<p>运作方式如下：</p>
<ul>
<li>适配器实现与其中一个现有对象兼容的接口</li>
<li>现有对象可以使用该接口安全地调用适配器方法</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象</li>
</ul>
<span id="more"></span>
<h2 id="适配器模式结构">适配器模式结构</h2>
<h3 id="对象适配器">对象适配器</h3>
<p>使用构成原则：适配器实现了其中一个对象的接口，并对另一个对象进行封装。</p>
<pre><code class="highlight mermaid">classDiagram

class Client Interface &#123;
&lt;&lt;interface&gt;&gt;
+method(data)
&#125;
class Adapter &#123;
-adaptee: Service
+method(data)
&#125;
class Service &#123;
...
+serviceMethod(speciaData)
&#125;
Client --&gt; Client Interface
Client Interface &lt;|.. Adapter
Adapter --&gt; Service</code></pre>
<ul>
<li><strong>客户端（Client）</strong> 是包含当前程序业务逻辑的类</li>
<li><strong>客户端接口（Client Interface）</strong> 描述了其他类与客户端代码合作时必须遵循的协议</li>
<li><strong>服务（Service）</strong> 中有一些功能类（通常来自第三方或遗留系统）。客户端与其接口不兼容，因此无法直接调用其功能</li>
<li><strong>适配器（Adapter）</strong> 是一个可以同时与客户端和服务交互的类：它在实现客户端接口的同时封装了服务对象。适配器接受客户端通过适配器接口发起的调用，并将其转换为适用于被封装服务对象的调用</li>
</ul>
<p>客户端代码只需通过接口与适配器交互即可，无需与具体的适配器耦合。</p>
<h3 id="类适配器">类适配器</h3>
<p>这一实现使用了继承机制：适配器同时继承两个对象的接口。</p>
<pre><code class="highlight mermaid">classDiagram
class Client
class Existing Class &#123;
...
+method(data)
&#125;
class Service &#123;
...
+serviceMethod(specialData)
&#125;
class Adapter &#123;
...
+method(data)
&#125;
Client --&gt; Existing Class
Existing Class &lt;|-- Adapter
Service &lt;|-- Adapter</code></pre>
<ul>
<li><strong>类适配器</strong> 不需要封装任何对象，因为它同时继承了客户端和服务的行为。适配功能在重写的方法中完成。最后生成的适配器可替代已有的客户端类进行使用</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adaptee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FahrenheitSensor</span> &#123;</span><br><span class="line">  <span class="title function_">getTemperature</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> temperature = <span class="built_in">parseFloat</span>(<span class="title function_">prompt</span>(<span class="string">&quot;Enter temperature in Fahrenheit: &quot;</span>) || <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> temperature;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CelsiusSensor</span> &#123;</span><br><span class="line">  <span class="title function_">getTemperature</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adapter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FahrenheitToCelsiusAdapter</span> <span class="keyword">implements</span> <span class="title class_">CelsiusSensor</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">fahrenheitSensor</span>: <span class="title class_">FahrenheitSensor</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fahrenheitSensor: FahrenheitSensor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fahrenheitSensor</span> = fahrenheitSensor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getTemperature</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fahrenheitTemp = <span class="variable language_">this</span>.<span class="property">fahrenheitSensor</span>.<span class="title function_">getTemperature</span>();</span><br><span class="line">    <span class="keyword">const</span> celsiusTemp = (fahrenheitTemp - <span class="number">32</span>) * <span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">return</span> celsiusTemp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client code</span></span><br><span class="line"><span class="keyword">const</span> fahrenheitSensor = <span class="keyword">new</span> <span class="title class_">FahrenheitSensor</span>();</span><br><span class="line"><span class="keyword">const</span> celsiusSensor = <span class="keyword">new</span> <span class="title class_">FahrenheitToCelsiusAdapter</span>(fahrenheitSensor);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Temperature in Celsius: <span class="subst">$&#123;celsiusSensor.getTemperature()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类</li>
<li>如果需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法，但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>单一职责原则，你可以将接口或数据转换代码从程序主要业务逻辑中分离</li>
<li>开闭原则。只要客户端代码通过客户端接口与适配器进行交互，你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>代码整体复杂度增加，因为需要新增一系列接口和类。有时直接更改服务类使其与其他代码兼容会更简单</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/adapter">Refactoringguru.cn 适配器模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>wrapper</tag>
        <tag>adapter</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/design-pattern-clone/</url>
    <content><![CDATA[<p>原型模式将克隆过程委派给被克隆的实际对象。模式为所有支持克隆的对象声明了一个通用接口，该接口让你能够克隆对象，同时又无需将代码和对象所属类耦合。</p>
<p>通常情况下，这样的接口中仅包含一个 <mark class="label info">克隆</mark> 方法</p>
<p>所有的类对 <mark class="label info">克隆</mark> 方法都非常相似。该方法会创建一个当前类的对象，然后将原始对象所有的成员变量值复制到新建的类中。</p>
<p>支持克隆的对象即为原型。当你的对象有几十个成员变量和几百种类型时，对其进行克隆甚至可以代替子类的构造</p>
<span id="more"></span>
<h2 id="基本实现">基本实现</h2>
<pre><code class="highlight mermaid">classDiagram
class Prototype &#123;
&lt;&lt;Interface&gt;&gt;
+ clone(): Prototype
&#125;
class ConcretePrototype &#123;
- field1
+ ConcretePrototype(prototype)
+ clone(): Prototype
&#125;
class SubclassPrototype &#123;
- field2
+ SubclassPrototype(prototype)
+ clone(): Prototype
&#125;

Prototype &lt;|.. ConcretePrototype
ConcretePrototype &lt;|-- SubclassPrototype


Client --&gt; Prototype</code></pre>
<ul>
<li><strong>原型（Prototype）</strong> 接口将对克隆方法进行声明</li>
<li><strong>具体原型（Concrete Prototype）</strong> 类将实现克隆方法。除了将原始对象的数据复制到克隆体中之外，该方法有时还需处理克隆过程中的极端情况，例如克隆关联对象和梳理递归依赖等</li>
<li><strong>客户端（Client）</strong> 可以复制实现了原型接口的任何对象</li>
</ul>
<h2 id="原型注册表实现">原型注册表实现</h2>
<pre><code class="highlight mermaid">classDiagram
Client --&gt; PrototypeRegistry
class PrototypeRegistry &#123;
- items: Prototye[]
+ addItem(id: string, p: Prototype)
+ getById(id: string): Prototype
+ getByColor(color: string): Prototype
&#125;
class Prototype &#123;
&lt;&lt;interface&gt;&gt;
+ getColor(): string
+ clone(): Prototype
&#125;
class Button &#123;
- x,y,color
+ Button(x,y,color)
+ Botton(prototype)
+ getColor(): string
+ clone(): Prototype
&#125;
PrototypeRegistry o-- Prototype
Prototype &lt;|.. Button</code></pre>
<ul>
<li><strong>原型注册表（Prototype registry）</strong> 提供了一种访问常用原型的简单方法，其中存储了一系列可供随时复制的预生成对象。</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础原型</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">type</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">size</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id: <span class="built_in">number</span>, <span class="keyword">type</span>: <span class="built_in">string</span>, color: <span class="built_in">string</span>, size: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="keyword">type</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">draw</span>(): <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">prototype</span>: <span class="title class_">Shape</span> = <span class="variable language_">this</span>): <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototype)</span><br><span class="line">    clone.<span class="property">id</span> = crypto.<span class="title function_">randomUUID</span>()</span><br><span class="line">    clone.<span class="property">type</span> = prototype.<span class="title function_">getType</span>()</span><br><span class="line">    clone.<span class="title function_">setColor</span>(prototype.<span class="title function_">getColor</span>())</span><br><span class="line">    clone.<span class="title function_">setSize</span>(prototype.<span class="title function_">getSize</span>())</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getId</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getType</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">type</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getColor</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">color</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getSize</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColor</span>(<span class="attr">color</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setSize</span>(<span class="attr">size</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id: <span class="built_in">number</span>, color: <span class="built_in">string</span>, radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(id, <span class="string">&quot;Circle&quot;</span>, color, <span class="number">2</span> * radius);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 需要调用父类克隆函数来复制父类中定义的私有成员变量</span></span><br><span class="line"><span class="comment">   * 当然由于父类定义了`Get`函数，直接在子类 Circle 克隆也是可以的</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">clone</span>(<span class="attr">prototype</span>: <span class="title class_">Circle</span> = <span class="variable language_">this</span>): <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="variable language_">super</span>.<span class="title function_">clone</span>(prototype) <span class="keyword">as</span> <span class="title class_">Circle</span></span><br><span class="line">    clone.<span class="property">radius</span> = prototype.<span class="property">radius</span></span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getRadius</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">radius</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Drawing a <span class="subst">$&#123;<span class="variable language_">this</span>.getColor()&#125;</span> circle with size <span class="subst">$&#123;<span class="variable language_">this</span>.getSize()&#125;</span> and ID <span class="subst">$&#123;<span class="variable language_">this</span>.getId()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Shape</span> &#123;</span><br><span class="line">  <span class="attr">rx</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">ry</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">id: <span class="built_in">number</span>, color: <span class="built_in">string</span>, size: <span class="built_in">number</span>, rx = <span class="number">0</span>, ry = <span class="number">0</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(id, <span class="string">&quot;Rectangle&quot;</span>, color, size);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">rx</span> = rx</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ry</span> = ry</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">clone</span>(prototype = <span class="variable language_">this</span>): <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="variable language_">super</span>.<span class="title function_">clone</span>(prototype) <span class="keyword">as</span> <span class="title class_">Rectangle</span></span><br><span class="line">    clone.<span class="property">rx</span> = prototype.<span class="property">rx</span></span><br><span class="line">    clone.<span class="property">ry</span> = prototype.<span class="property">ry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">draw</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Drawing a <span class="subst">$&#123;<span class="variable language_">this</span>.getColor()&#125;</span> rectangle with size <span class="subst">$&#123;<span class="variable language_">this</span>.getSize()&#125;</span> and ID <span class="subst">$&#123;<span class="variable language_">this</span>.getId()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型注册表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeCache</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">shapeMap</span>: &#123; [<span class="attr">id</span>: <span class="built_in">string</span>]: <span class="title class_">Shape</span> &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getShape</span>(<span class="attr">id</span>: <span class="built_in">string</span>): <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cachedShape = <span class="title class_">ShapeCache</span>.<span class="property">shapeMap</span>[id];</span><br><span class="line">    <span class="keyword">return</span> cachedShape.<span class="title function_">clone</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 预生成对象</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">loadCache</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>, <span class="string">&quot;Red&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">2</span>, <span class="string">&quot;Blue&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="title class_">ShapeCache</span>.<span class="property">shapeMap</span>[<span class="title class_">String</span>(circle.<span class="title function_">getId</span>())] = circle;</span><br><span class="line">    <span class="title class_">ShapeCache</span>.<span class="property">shapeMap</span>[<span class="title class_">String</span>(rectangle.<span class="title function_">getId</span>())] = rectangle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="title class_">ShapeCache</span>.<span class="title function_">loadCache</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="title class_">ShapeCache</span>.<span class="title function_">getShape</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rectangle1 = <span class="title class_">ShapeCache</span>.<span class="title function_">getShape</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">circle1.<span class="title function_">draw</span>(); <span class="comment">// Drawing a Red circle with size 10 and ID randomUUID1</span></span><br><span class="line">rectangle1.<span class="title function_">draw</span>(); <span class="comment">// Drawing a Blue rectangle with size 20 and ID randomUUID2</span></span><br><span class="line"></span><br><span class="line">circle1.<span class="title function_">setColor</span>(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">circle1.<span class="title function_">setSize</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="title class_">ShapeCache</span>.<span class="title function_">getShape</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">circle2.<span class="title function_">draw</span>(); <span class="comment">// Drawing a Red circle with size 10 and ID &lt;different random number&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>需要复制一些对象，同时又希望代码独立于这些对象所属的具体类，可以使用原型模式</li>
<li>如果子类的区别仅在于其对象的初始化方式，那么可以使用该模式来减少子类的数量。别人创建这些子类的目的可能是为了创建特定类型的对象</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以克隆对象，而无需与它们所属的具体类相耦合</li>
<li>可以克隆预生成原型，避免反复初始化代码</li>
<li>可以更方便地生成复杂对象</li>
<li>可以用继承以外的方式来处理复杂对象的不同配置</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>克隆包含循环引用的复杂对象可能会非常麻烦</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/prototype">Refactoringguru.cn 原型模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>clone</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器模式</title>
    <url>/design-pattern-builder/</url>
    <content><![CDATA[<p>生成器模式是一种创建型设计模式,使你能够分步骤创建复杂对象.该模式允许你使用相同的创建代码生成不同类型和形式的对象.</p>
<p>生成器模式建议将对象构造代码从产品类中抽取出来, 并将其放在一个名为生成器的独立对象中.</p>
<pre><code class="highlight mermaid">classDiagram
class Client
class Builder &#123;
&lt;&lt;interface&gt;&gt;
+reset()
+buildStepA()
+buildStepB()
+buildStepZ()
&#125;
class Director &#123;
-builder: Builder
+Director(builder)
+changeBuilder(bulider)
+make(type)
&#125;
class ConcreteBuilder1 &#123;
-result: Product1
+reset()
+buildStepA()
+buildStepB()
+buildStepZ()
+getResult(): Product1
&#125;
class Product1
class ConcreteBuilder2 &#123;
-result: Product2
+reset()
+buildStepA()
+buildStepB()
+buildStepZ()
+getResult(): Product2
&#125;
class Product2

Client ..&gt; ConcreteBuilder1
Client --&gt; Director
Director --&gt; Builder
Builder &lt;|.. ConcreteBuilder1
ConcreteBuilder1 --&gt; Product1
Builder &lt;|.. ConcreteBuilder2
ConcreteBuilder2 --&gt; Product2</code></pre>
<blockquote>
<p>生成器模式让你能够分步骤复杂对象.生成器不允许其他对象访问正在创建的产品</p>
</blockquote>
<span id="more"></span>
<ul>
<li><strong>生成器（Builder）</strong> 接口声明在所有类型生成器中通用的产品构造步骤</li>
<li><strong>具体生成器（Concrete Builders）</strong> 提供构造过程的不同实现。具体生成器也可以构造不遵循通用接口的产品</li>
<li><strong>产品（Products）</strong> 是最终生成的对象。由不同生成器构造的产品无需属于同一类层次结构或接口</li>
<li><strong>主管（Director）</strong> 类定义调用构造步骤的顺序，这样你就可以创建和复用特定的产品配置</li>
<li><strong>客户端（Client）</strong> 必须将某个生成器对象与主管类关联。一般情况下，你只需通过主管类构造函数的参数进行一次性关联即可。此后主管类就能使用生成器对象完成后续所有的构造任务。但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。在这种情况下，你在使用主管类生产产品时每次都可以使用不同的生成器</li>
</ul>
<p>该模式会将对象构造过程划分为一组步骤, 比如<mark class="label info">buildWalls 创建墙壁</mark>和<mark class="label info">buildDoor 创建房门</mark>创建房门等.每次创建对象时,你都需要通过生成器对象执行一系列步骤. 重点在于你无需调用所有步骤, 而只需调用创建特定对象配置所需的那些步骤即可</p>
<p>当你需要创建不用形式的产品时,其中的一些构造步骤可能需要不同的实现.在这种情况下,你可以创建多个不同的生成器,用不同方式实现一组相同的创建步骤.然后你就可以在创建过程中使用这些生成器来生成不同类型的对象.</p>
<p><strong>主管</strong></p>
<p>可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类.主管类可定义创建步骤的执行顺序,而生成器则提供这些步骤的实现</p>
<p>严格来说, 程序中并不一定需要主管类.客户端代码可直接以特定顺序调用创建步骤.不过,主管类中非常适合放入各种例行构造流程,以便在程序中反复使用.</p>
<h2 id="代码示例">代码示例</h2>
<p>只有当产品较为复杂且需要详细配置时, 使用生成器模式才有意义.</p>
<p>这里成员均为 <mark class="label info">string</mark>类型, 只是为了减少示例代码.真实代码中使用真实的实例能更好的发挥生成器模式的能力</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品不一定需要实现同样的接口. 或继承自同一个基类.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">  <span class="attr">seats</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">engine</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">tripComputer</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">gps</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manual</span> &#123;</span><br><span class="line">  <span class="attr">seats</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">engine</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">tripComputer</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">gps</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成器接口声明了创建产品对象不同部件的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">  <span class="title function_">reset</span>(): <span class="built_in">any</span></span><br><span class="line">  <span class="title function_">setSeats</span>(<span class="attr">seat</span>: <span class="built_in">string</span>): <span class="built_in">any</span></span><br><span class="line">  <span class="title function_">setEngine</span>(<span class="attr">engine</span>: <span class="built_in">string</span>): <span class="built_in">any</span></span><br><span class="line">  <span class="title function_">setTripComputer</span>(<span class="attr">computer</span>: <span class="built_in">string</span>): <span class="built_in">any</span></span><br><span class="line">  <span class="title function_">setGps</span>(<span class="attr">gps</span>: <span class="built_in">string</span>): <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体生成器类型将遵循生成器接口并提供步骤的具体实现</span></span><br><span class="line"><span class="comment">// 可以有多个以不同方式实现的生成器变体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">car</span>: <span class="title class_">Car</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一个生成器示例必须包含一个在后续组装过程中使用的空产品对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// reset 方法可清除正在生成的对象</span></span><br><span class="line">  <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span> = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所有生成步骤都会与同一个产品实例进行交互</span></span><br><span class="line">  <span class="title function_">setSeats</span>(<span class="params">seats: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">serts</span> = seats</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setEngine</span>(<span class="params">engine: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">engine</span> = engine</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setTripComputer</span>(<span class="params">computer: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">tripComputer</span> = computer</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setGps</span>(<span class="params">gps: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gps</span> = gps</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 具体生成器需要自行提供获取结果的方法.</span></span><br><span class="line">  <span class="comment">// 这是因为不同类型的生成器可能会创建不遵循相同接口的,完全不同的产品.</span></span><br><span class="line">  <span class="comment">// 所以也就无法在生成器接口中声明这些方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">getProduct</span>(): <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> car = <span class="variable language_">this</span>.<span class="property">car</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reset</span>()	<span class="comment">// 做好生成另一个产品的准备</span></span><br><span class="line">    <span class="keyword">return</span> car</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通常在生成器实例将结果返回给客户端后,它们应该做好生成另一个产品的准备.</span></span><br><span class="line">  <span class="comment">// 因此生成器实例通常会在 `getProduct(获取产品)`方法主题末尾调用重置方法</span></span><br><span class="line">  <span class="comment">// 但是该行为不是必需的,你也可以让生成器等待客户端明确调用重置方法后再去处理之前的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarManualBuilder</span> <span class="keyword">implements</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">manual</span>: <span class="title class_">Manual</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一个生成器示例必须包含一个在后续组装过程中使用的空产品对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// reset 方法可清除正在生成的对象</span></span><br><span class="line">  <span class="title function_">reset</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">manual</span> = <span class="keyword">new</span> <span class="title class_">Manual</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 所有生成步骤都会与同一个产品实例进行交互</span></span><br><span class="line">  <span class="title function_">setSeats</span>(<span class="params">seats: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">serts</span> = seats</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setEngine</span>(<span class="params">engine: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">engine</span> = engine</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setTripComputer</span>(<span class="params">computer: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">car</span>.<span class="property">tripComputer</span> = computer</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">setGps</span>(<span class="params">gps: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">gps</span> = gps</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 具体生成器需要自行提供获取结果的方法.</span></span><br><span class="line">  <span class="comment">// 这是因为不同类型的生成器可能会创建不遵循相同接口的,完全不同的产品.</span></span><br><span class="line">  <span class="comment">// 所以也就无法在生成器接口中声明这些方法</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">getProduct</span>(): <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> car = <span class="variable language_">this</span>.<span class="property">car</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reset</span>()	<span class="comment">// 做好生成另一个产品的准备</span></span><br><span class="line">    <span class="keyword">return</span> car</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通常在生成器实例将结果返回给客户端后,它们应该做好生成另一个产品的准备.</span></span><br><span class="line">  <span class="comment">// 因此生成器实例通常会在 `getProduct(获取产品)`方法主题末尾调用重置方法</span></span><br><span class="line">  <span class="comment">// 但是该行为不是必需的,你也可以让生成器等待客户端明确调用重置方法后再去处理之前的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主管只负责按照特定顺序执行生成步骤.</span></span><br><span class="line"><span class="comment">// 其在根据特定步骤或配置来生成产品时会很有帮助.</span></span><br><span class="line"><span class="comment">// 由于客户端可以直接控制生成器,所以严格意义上来说,主管类并不是必需的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">  <span class="title function_">constructSportsCar</span>(<span class="params">builder: Builder</span>) &#123;</span><br><span class="line">    builder.<span class="title function_">reset</span>()</span><br><span class="line">    builder.<span class="title function_">setSeats</span>(<span class="number">2</span>)</span><br><span class="line">    builder.<span class="title function_">setEngine</span>(<span class="string">&quot;sport engine&quot;</span>)</span><br><span class="line">    builder.<span class="title function_">setTripComputer</span>(<span class="string">&quot;super computer&quot;</span>)</span><br><span class="line">    builder.<span class="title function_">setGPs</span>(<span class="string">&quot;gps system&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructSUV</span>(<span class="params">builder: Builder</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码会创建生成器对象并将其传递给主管,然后执行构造过程.</span></span><br><span class="line"><span class="comment">// 最终结果将需要从生成器对象中获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> director = <span class="keyword">new</span> <span class="title class_">Director</span>()</span><br><span class="line"><span class="keyword">const</span> carBuilder = <span class="keyword">new</span> <span class="title class_">CarBuilder</span>()</span><br><span class="line">director.<span class="title function_">constructSportsCar</span>(carBuilder)</span><br><span class="line"><span class="keyword">const</span> car = carBuilder.<span class="title function_">getProduct</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> carManualBuilder = <span class="keyword">new</span> <span class="title class_">CarManualBuilder</span>()</span><br><span class="line">director.<span class="title function_">constructSportsCar</span>(carManualBuilder)</span><br><span class="line"><span class="keyword">const</span> manual = builder.<span class="title function_">getProduct</span>()</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>使用生成器模式可避免“重叠构造函数(telescoping construtor)” 的出现</li>
<li>当你希望使用代码创建不同形式的产品时,可使用生成器模式</li>
<li>使用生成器构造组合树或其他复杂对象</li>
</ul>
<p>生成器在执行制造步骤时,不能对外发布未完成的产品.这可以避免客户端代码获取到不完整结果对象的情况</p>
<h2 id="优点">优点</h2>
<ul>
<li>可以分步创建对象,暂缓创建步骤或递归运行创建步骤</li>
<li>生成不同形式的产品时,你可以复用相同的制造代码</li>
<li>单一职责原则.你可以将复杂构造代码从产品的业务逻辑中分离出来</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>由于该模式需要新增多个类,因此代码整体复杂程度会有所增加</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/builder">Refactoringguru.cn 生成器模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>builder</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/design-pattern-chain-of-responsibility/</url>
    <content><![CDATA[<p><strong>责任链模式</strong>是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者</p>
<pre><code class="highlight mermaid">classDiagram
class Handler &#123;
&lt;&lt;interface&gt;&gt;
+setNext(h: Handler)
+handle(request)
&#125;
class BaseHandler &#123;
-next: Handler
+setNext(h: Handler)
+handle(request)
&#125;
class ConcreteHandlers &#123;
...
+handle(request)
&#125;
class Client

Handler &lt;-- Client
Handler &lt;|.. BaseHandler
Handler &lt;--o BaseHandler
BaseHandler &lt;|-- ConcreteHandlers</code></pre>
<span id="more"></span>
<ul>
<li><strong>处理者（Handler）</strong> 声明了所有具体处理者的通用接口。该接口通常仅包含单个方法用于请求处理，但有时其还会包含一个设置链上下个处理者的方法</li>
<li><strong>基础处理者（Base Handler）</strong> 是一个可选的类，你可以将所有处理者共用的样本代码放置在其中</li>
<li><strong>具体处理者（Concrete Handlers）</strong> 包含处理请求的实际代码。每个处理者接受到请求后，都必须决定是否进行处理，以及是否沿着链传递请求<br>
处理者通常是独立且不可变的，需要通过构造函数一次性地获得所有必要地数据</li>
<li><strong>客户端（Client）</strong> 可根据程序逻辑一次性或者动态地生成链。<br>
值得注意的是，请求可以发送给链上的任意一个处理者，而非必须是第一个处理者</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handler interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="title function_">setNext</span>(<span class="attr">handler</span>: <span class="title class_">Handler</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">handle</span>(<span class="attr">request</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract base handler</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">nextHandler</span>: <span class="title class_">Handler</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">setNext</span>(<span class="attr">handler</span>: <span class="title class_">Handler</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextHandler</span> = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handle</span>(<span class="attr">request</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nextHandler</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nextHandler</span>.<span class="title function_">handle</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete handlers</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerA</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handle</span>(<span class="attr">request</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteHandlerA: Handling the request&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">handle</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handle</span>(<span class="attr">request</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteHandlerB: Handling the request&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">handle</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteHandlerC</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractHandler</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">handle</span>(<span class="attr">request</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request === <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ConcreteHandlerC: Handling the request&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">super</span>.<span class="title function_">handle</span>(request);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example</span></span><br><span class="line"><span class="keyword">const</span> handlerA = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerA</span>();</span><br><span class="line"><span class="keyword">const</span> handlerB = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerB</span>();</span><br><span class="line"><span class="keyword">const</span> handlerC = <span class="keyword">new</span> <span class="title class_">ConcreteHandlerC</span>();</span><br><span class="line"></span><br><span class="line">handlerA.<span class="title function_">setNext</span>(handlerB);</span><br><span class="line">handlerB.<span class="title function_">setNext</span>(handlerC);</span><br><span class="line"></span><br><span class="line">handlerA.<span class="title function_">handle</span>(<span class="string">&#x27;B&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式</li>
<li>当必须按顺序执行多个处理者时，可以使用该模式</li>
<li>如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以控制请求处理的顺序</li>
<li>单一职责原则。可对发起操作和执行操作的类进行解耦</li>
<li>开闭原则。可以在不更改现有代码的情况下再程序中新增处理者</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>部分请求可能未被处理</li>
</ul>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<p>责任链模式和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。</p>
<p>但是，责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。另一方面，各种装饰可以在遵循基本接口的情况下扩展对象的行为。此外装饰无法中断请求的传递</p>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">Refactoringguru.cn 责任链模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>CoR</tag>
        <tag>Chain of Command</tag>
        <tag>Chain of Responsibility</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/design-pattern-command/</url>
    <content><![CDATA[<p><strong>命令模式</strong> 是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作</p>
<pre><code class="highlight mermaid">classDiagram
class Invoker &#123;
-command
+setCommand(command)
+executeCommand()
&#125;
class Command &#123;
&lt;&lt;Interface&gt;&gt;
+execute()
&#125;
class ConcreteCommand1 &#123;
-receiver
-params
+Command1(receiver, params)
+execute()
&#125;
class ConcreteCommand2 &#123;
+execute()
&#125;
class Receiver &#123;
...
+operation(a,b,c)
&#125;
class Client
Client --&gt; Receiver
Client ..&gt; ConcreteCommand1
Command &lt;|.. ConcreteCommand1
Command &lt;|.. ConcreteCommand2
Invoker --&gt; Command</code></pre>
<span id="more"></span>
<ul>
<li><strong>发送者(Sender)/触发者(Invoker)</strong> 类负责对请求进行初始化，其中必须包含一个成员变量来存储对于命令对象的引用。发送者触发命令，而不向接受者直接发送请求。注意：发送者并不负责创建命令对象：它通常会通过构造函数从客户端处获得预先生成的命令</li>
<li><strong>命令(Command)</strong> 接口通常仅声明一个执行命令的方法</li>
<li><strong>具体命令(Concrete Commands)</strong> 会实现各种类型的请求。具体命令自身并不完成工作，而是会将调用委派给一个业务逻辑对象。但为了简化代码，这些类可以进行合并。接收对象执行方法所需的参数可以声明为具体命令的成员变量，你可以将命令对象设为不可变，仅允许通过构造函数对这些成员变量进行初始化</li>
<li><strong>接收者(Receiver)</strong> 类包含部分业务逻辑。几乎任何对象都可以作为接受者。绝大部分命令只处理如何将请求传递到接收者的细节，接受者自己会完成实际的工作</li>
<li><strong>客户端(Client)</strong> 会创建并配置具体命令对象。客户端必须将包括接受者实体在内的所有请求参数传递给命令的构造函数。此后，生成的命令就可以与一个或多个发送者相关联了</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receiver class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">turnOn</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Light is on&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">turnOff</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Light is off&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Command interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="title function_">execute</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">undo</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete command classes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOnCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">light</span>: <span class="title class_">Light</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">light: Light</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span> = light;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">execute</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span>.<span class="title function_">turnOn</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">undo</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span>.<span class="title function_">turnOff</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TurnOffCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">light</span>: <span class="title class_">Light</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">light: Light</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span> = light;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">execute</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span>.<span class="title function_">turnOff</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">undo</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">light</span>.<span class="title function_">turnOn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoker class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteControl</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">commands</span>: <span class="title class_">Command</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">executeCommand</span>(<span class="attr">command</span>: <span class="title class_">Command</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">push</span>(command);</span><br><span class="line">    command.<span class="title function_">execute</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">undoLastCommand</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> lastCommand = <span class="variable language_">this</span>.<span class="property">commands</span>.<span class="title function_">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (lastCommand) &#123;</span><br><span class="line">      lastCommand.<span class="title function_">undo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example</span></span><br><span class="line"><span class="keyword">const</span> light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line"><span class="keyword">const</span> turnOnCommand = <span class="keyword">new</span> <span class="title class_">TurnOnCommand</span>(light);</span><br><span class="line"><span class="keyword">const</span> turnOffCommand = <span class="keyword">new</span> <span class="title class_">TurnOffCommand</span>(light);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> remoteControl = <span class="keyword">new</span> <span class="title class_">RemoteControl</span>();</span><br><span class="line">remoteControl.<span class="title function_">executeCommand</span>(turnOnCommand); <span class="comment">// Output: Light is on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform additional operations, state changes, etc.</span></span><br><span class="line"></span><br><span class="line">remoteControl.<span class="title function_">undoLastCommand</span>(); <span class="comment">// Output: Light is off</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果需要通过操作来参数化对象，可使用命令模式</li>
<li>如果你想要将操作放入队列中，延迟操作的执行或者远程执行操作，可使用命令模式</li>
<li>如果你想要实现操作回滚功能，可使用命令模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>单一职责原则。可以解耦触发和执行操作的类</li>
<li>开闭原则。可以在不修改已有客户端代码的情况下在程序中创建新的命令</li>
<li>可以实现撤销和恢复功能</li>
<li>可以实现操作的延迟执行</li>
<li>可以将一组简单命令组合成一个复杂命令</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>代码可能会变得更加复杂，因为你在发送者和接收者之间增加了一个全新的层次</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/command">Refactoringguru.cn 命令模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>action</tag>
        <tag>transaction</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式比较</title>
    <url>/design-pattern-compare-factory/</url>
    <content><![CDATA[<h2 id="工厂">工厂</h2>
<p>工厂是一个含义模糊的术语,表示可以创建一些东西的函数,方法或类.最常见的情况下,工厂创建的是对象.但是它们也可以 创建文件和数据库记录等其他东西.</p>
<p>例如,下面这些东西都可以非正式地被称为“工厂”</p>
<ul>
<li>创建程序GUI的函数或方法</li>
<li>创建用户的类</li>
<li>以特定方式调用类构造函数的静态方法</li>
<li>一种创建型设计模式</li>
</ul>
<p>当某人说到“工厂”这个词时,其具体含义通常可以根据上下文来确定.</p>
<span id="more"></span>
<h2 id="构建方法">构建方法</h2>
<p>构造方法只是构造函数调用的封装器.它可能只是一个能更好地表达以图的名称.此外,它可以让你的代码独立与构造函数的改动,甚至还可以包含一些特殊的逻辑,返回已有对象而不是创建新对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooNumber</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">value</span>: <span class="built_in">number</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构建方法</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FooNumber</span>(<span class="variable language_">this</span>.<span class="property">value</span> + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态构建方法">静态构建方法</h2>
<p>静态构建方法是被声明为<mark class="label info">static</mark>的构建方法.</p>
<p>当静态构建方法返回一个新对象时,它就成为了构造函数的代替品</p>
<div class="note danger"><p>构建方法在 《重构和模式》中被定义为“创建对象的方法”. 但不是工厂方法. 工厂方法是一种依赖于继承的设计模式.</p>
<p>同样的, 静态构建方法也不是“静态工厂方法”</p>
</div>
<h2 id="简单工厂模式">简单工厂模式</h2>
<p>简单工厂模式描述了一个类,它拥有一个包含大量条件语句的构建方法,可根据方法的参数来选择对何种产品进行初始化并将其返回.</p>
<p>人们通常会将简单工厂与普通的工厂或其它创建型设计模式混淆.在绝大多数情况下,简单工厂是引入工厂方法或抽象工厂模式时的一个中间步骤</p>
<p>简单工厂通常没有子类.但当从一个简单工厂中抽取子类后,它看上去就会更新经典的工厂方法模式了</p>
<p>另外,将一个简单工厂声明为<mark class="label info">abstract</mark>类型,它并不会神奇地变成抽象工厂模式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="variable constant_">USER_TYPE</span> &#123;</span><br><span class="line">  <span class="variable constant_">USER</span>,</span><br><span class="line">  <span class="variable constant_">CUSTOMER</span>,</span><br><span class="line">  <span class="variable constant_">ADMIN</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserFactory</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">create</span>(<span class="params"><span class="keyword">type</span>: USER_TYPE</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="variable constant_">USER_TYPE</span>.<span class="property">USER</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">      <span class="keyword">case</span> <span class="variable constant_">USER_TYPE</span>.<span class="property">CUSTOMER</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">      <span class="keyword">case</span> <span class="variable constant_">USER_TYPE</span>.<span class="property">ADMIN</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Admin</span>();</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;错误的用户类型&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工厂方法模式">工厂方法模式</h2>
<p>工厂方法是一种创建型设计模式,其在父类中提供一个创建对象的方法,允许子类决定实例化对象的类型.</p>
<p>如果在基类及其拓展的子类中都有一个构建方法的话,那它可能就是工厂方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口或者创建者基类</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span>; <span class="comment">// 注意返回值, 为产品实现的接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体创建者将重写工厂方法以改变其所返回的产品类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicProductFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicProduct</span>(name, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种产品工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiscountedProductFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscountedProduct</span>(name, <span class="number">10</span>, <span class="number">0.2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂模式">抽象工厂模式</h2>
<p>抽象工厂是一种创建型设计模式,它能创建一系列相关或相互依赖的对象,而无需指定其具体类</p>
<p>什么是<mark class="label info">“系列对象”</mark>?</p>
<p>例如一组对象: <mark class="label info">运输工具</mark> + <mark class="label info">引擎</mark> + <mark class="label info">控制器</mark>. 它可能会有几个变体</p>
<ul>
<li>
<mark class="label info">汽车</mark> + <mark class="label info">内燃机</mark> + <mark class="label info">方向盘</mark>
</li>
<li>
<mark class="label info">飞机</mark> + <mark class="label info">喷气式发动机</mark> + <mark class="label info">操纵杆</mark>
</li>
</ul>
<p>如果程序中并不涉及产品系列的话,那就不需要抽象工厂</p>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/factory-comparison">Refactoringguru.cn 工厂模式比较</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>factory-method</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/design-pattern-composite/</url>
    <content><![CDATA[<p><strong>组合模式</strong> 是一种结构型设计模式，你可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们。</p>
<pre><code class="highlight mermaid">classDiagram
class Client
class Component &#123;
&lt;&lt;interface&gt;&gt;
+execute()
&#125;
class Leaf &#123;
...
+execute()
&#125;
class Composite &#123;
-children: Component[]
+add(c: Component)
+remove(c: Component)
+getChildren(): Component[]
+execute()
&#125;
Client --&gt; Component
Component &lt;|.. Leaf
Component &lt;|.. Composite
Component &lt;--o Composite</code></pre>
<div class="note warning"><p>如果应用的核心模型能用树状结构表示，在应用中使用组合模式才有价值</p>
</div>
<span id="more"></span>
<ul>
<li><strong>组件（Component）</strong> 接口描述了树中简单项目和复杂项目所共有的操作</li>
<li><strong>叶节点（Leaf）</strong> 是树的基本结构，它不包含子项目。<br>
一般情况下，叶节点最终会完成大部分的实际工作，因为它们无法将工作指派给其他部分</li>
<li><strong>容器（Container/Composite）</strong> 是包含叶节点或其他容器等子项目的单位。容器不知道其子项目所属的具体类，它只通过通用组件接口与其子项目交互<br>
容器接收到请求后会将工作分配给自己的子项目，处理中间结果，然后将最终结果返回给客户端</li>
<li><strong>客户端（Client）</strong> 通过组件接口与所有项目交互。因此，客户端能以相同方式与树状结构中的简单或复杂项目交互</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件接口会声明组合中简单和复杂对象的通用操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叶节点代表组合的终端对象。叶节点对象中不能包含任何子对象。</span></span><br><span class="line"><span class="comment">// 叶节点对象通常会完成实际的工作，组合对象则会将工作委派给自己的子部件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Leaf operation&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有组件类都可以拓展其他组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bud</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Leaf</span> &#123;</span><br><span class="line">  <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项目，然后“汇总”结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">children</span>: <span class="title class_">Component</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）</span></span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">component</span>: <span class="title class_">Component</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(component);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">remove</span>(<span class="attr">component</span>: <span class="title class_">Component</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">indexOf</span>(component);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组合会议特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集汇总其结果</span></span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Composite operation&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> child <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">children</span>) &#123;</span><br><span class="line">      child.<span class="title function_">operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"><span class="keyword">const</span> leaf1 = <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line"><span class="keyword">const</span> bud = <span class="keyword">new</span> <span class="title class_">Bud</span>();</span><br><span class="line"><span class="keyword">const</span> composite = <span class="keyword">new</span> <span class="title class_">Composite</span>();</span><br><span class="line">composite.<span class="title function_">add</span>(leaf1);</span><br><span class="line">composite.<span class="title function_">add</span>(bud);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> leaf2 = <span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line"><span class="keyword">const</span> composite2 = <span class="keyword">new</span> <span class="title class_">Composite</span>();</span><br><span class="line">composite2.<span class="title function_">add</span>(leaf2);</span><br><span class="line">composite2.<span class="title function_">add</span>(composite);</span><br><span class="line"></span><br><span class="line">composite2.<span class="title function_">operation</span>();</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果你需要实现树状对象结构，可以使用组合模式</li>
<li>如果你希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以利用多态和递归机制更方便地使用复杂树结构</li>
<li>开闭原则。无需更改现有代码，你就可以在应用中添加新元素，使其成为对象树的一部分</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>对于功能差异较大的类，提供公共接口或许会有困难。在特定情况下，你需要过度一般化组件接口，使其变得令人难以理解</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/composite">Refactoringguru.cn 组合模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>Composite</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/design-pattern-decorator/</url>
    <content><![CDATA[<p><strong>装饰模式</strong> 是一种结构性设计模式，允许你通过将对象放入包含行为的特殊封装对象来为原对象绑定新的行为</p>
<p>当你需要更改一个对象的行为时，第一个跳入脑海的想法就是拓展它所属的类。但是，你不能忽视继承可能引发的几个严重问题</p>
<ul>
<li>继承是静态的。你无法在运行时更改已有对象的行为，只能使用由不同子类创建的对象来代替当前的整个对象</li>
<li>子类只能有一个父类。大部分编程语言不允许一个类同时继承多个类的行为</li>
</ul>
<p>其中一种方法是用聚合或组合，而不是继承。两者的工作方式几乎一模一样；一个对象包含指向另一个对象的引用，并将部分工作委派给引用对象；继承中的对象则继承了父类的行为，它们自己能够完成这些工作</p>
<mark class="label primary">封装器</mark> 是装饰模式的别称，这个称谓明确地表达了该模式的主要思想。“封装器”是一个能与其他“目标”对象连接的对象。封装器包含与目标对象相同的一系列方法<mark class="label success">（即实现了与封装对象相同的接口）</mark>，它会将所有接收到的请求委派给目标对象。但是，封装器可以在将请求委派给目标前后对其进行处理，所以可能会改变最终结果。
<span id="more"></span>
<h2 id="装饰模式结构">装饰模式结构</h2>
<pre><code class="highlight mermaid">classDiagram
class Client
class Component &#123;
&lt;&lt;interface&gt;&gt;
+execte()
&#125;
class Concrete Component&#123;
...
+ execute()
&#125;
class Base Decorator &#123;
-wrappee: Component
+BaseDecorator(c: Component)
+execute()
&#125;
class ConcreteDecorators &#123;
...
+execute()
+extra()
&#125;

Client --&gt; Component
Component &lt;|.. ConcreteComponent
Component &lt;|.. BaseDecorator
Component &lt;--o BaseDecorator
BaseDecorator &lt;|-- ConcreteDecorators
</code></pre>
<ul>
<li><strong>部件（Component）</strong> 声明封装器和被封装对象的公用接口</li>
<li><strong>具体部件（Concrete Component）</strong> 类是被封装对象所属的类。它定义了基础行为，但装饰类可以改变这些行为</li>
<li><strong>基础装饰（Base decorator）</strong> 类拥有一个可以指向被装饰对象的引用成员变量。该变量的类型应当被声明为通用部件接口，这样它就可以引用具体的部件和装饰。装饰基类会将所有操作委派给被封装的对象</li>
<li><strong>具体装饰类（Concrete Decorators）</strong> 定义了可动态添加到部件的额外行为。具体装饰类会重写装饰基类的方法，并在调用父类方法之前或之后进行额外的行为</li>
<li><strong>客户端（Client）</strong> 可以使用多层装饰来封装部件，只要它能使用通用接口与所有对象交互即可</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰可以改变组件接口所定义的操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="title function_">operation</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件提供操作的默认实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicPizza</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">operation</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Pizza with tomato sauce and cheese&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封装接口</span></span><br><span class="line"><span class="comment">// 封装的默认实现代码中可能会包含一个被封装组件的成员变量，并且负责对其进行初始化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PizzaDecorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">component</span>: <span class="title class_">Component</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">component: Component</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">component</span> = component;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式可简化装饰类的拓展工作</span></span><br><span class="line">  <span class="comment">// 当然这里定义为了抽象方法, 具体装饰的不能直接调用的，只能实现 operation 方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">operation</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pepperoni</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PizzaDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">operation</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.component.operation()&#125;</span>, with pepperoni`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mushrooms</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PizzaDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">operation</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.component.operation()&#125;</span>, with mushrooms`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Onions</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PizzaDecorator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">operation</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.component.operation()&#125;</span>, with onions`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰组件的简单示例</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">pizza</span>: <span class="title class_">Component</span> = <span class="keyword">new</span> <span class="title class_">BasicPizza</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pizza.<span class="title function_">operation</span>());</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">Pepperoni</span>(pizza);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pizza.<span class="title function_">operation</span>());</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">Mushrooms</span>(pizza);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pizza.<span class="title function_">operation</span>());</span><br><span class="line"></span><br><span class="line">pizza = <span class="keyword">new</span> <span class="title class_">Onions</span>(pizza);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pizza.<span class="title function_">operation</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端使用外部数据源。PizzaManager 对象不关心 Pizza 是使用什么做的。</span></span><br><span class="line"><span class="comment">// 它们会与提前配置好的数据源进行交互，数据源则是通过程序配置器获取的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PizzasManager</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">component</span>: <span class="title class_">Component</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">component: Component</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">component</span> = component;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">addTopping</span>(<span class="attr">topping</span>: <span class="title class_">PizzaDecorator</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">component</span> = topping;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getPizza</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">component</span>.<span class="title function_">operation</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> manager = <span class="keyword">new</span> <span class="title class_">PizzasManager</span>(<span class="keyword">new</span> <span class="title class_">BasicPizza</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(manager.<span class="title function_">getPizza</span>());</span><br><span class="line"></span><br><span class="line">manager.<span class="title function_">addTopping</span>(<span class="keyword">new</span> <span class="title class_">Pepperoni</span>(manager));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(manager.<span class="title function_">getPizza</span>());</span><br><span class="line"></span><br><span class="line">manager.<span class="title function_">addTopping</span>(<span class="keyword">new</span> <span class="title class_">Mushrooms</span>(manager));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(manager.<span class="title function_">getPizza</span>());</span><br><span class="line"></span><br><span class="line">manager.<span class="title function_">addTopping</span>(<span class="keyword">new</span> <span class="title class_">Onions</span>(manager));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(manager.<span class="title function_">getPizza</span>());</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果你希望在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式</li>
<li>如果用继承来拓展对象行为的方案难以实现或者根本不可行，你可以使用该模式。（比如说<mark class="label info">final</mark>关键字限制的类）</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>无需创建新子类即可拓展对象的行为</li>
<li>可以在运行时添加或删除对象的功能</li>
<li>可以使用多个装饰封装对象来组合几种行为</li>
<li>单一职责原则。可以将实现了许多不同行为的一个大类拆分为多个较小的类</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>在封装器中删除特定封装器比较困难</li>
<li>实现行为不受装饰栈影响的装饰比较困难</li>
<li>各层的初始化配置代码看上去可能会比较糟糕</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/decorator">Refactoringguru.cn 装饰模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>Wrapper</tag>
        <tag>Decorator</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/design-pattern-facade/</url>
    <content><![CDATA[<p><strong>外观模式</strong> 是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。</p>
<p>外观类为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合，但只需使用其中非常少的功能，那么使用外观模式会非常方便</p>
<span id="more"></span>
<h2 id="外观模式结构">外观模式结构</h2>
<pre><code class="highlight mermaid">classDiagram
class Client
class Facade &#123;
-linksToSubsystemObjects
-optionalAdditionalFacade
+subsystemOpearation()
&#125;
class AdditionalFacade &#123;
...
+anotherOperation()
&#125;
Client --&gt; Facade
Facade --&gt; AdditionalFacade

Facade ..&gt; SubsystemClass
AdditionalFacade ..&gt; SubsystemClass</code></pre>
<ul>
<li><strong>外观（Facade）</strong> 提供了一种访问特定子系统功能的便捷方式，其了解如何重定向客户端请求，知晓如何操作一切活动部件</li>
<li><strong>附加外观（Additional Facade）</strong> 类可以避免多种不相关的功能污染单一外观，使其变成又一个复杂结构。客户端和其他外观都可以使用附加外观</li>
<li><strong>复杂子系统（Complex Subsystem）</strong> 由数十个不同对象构成。如果要用这些对象完成有意义的工作，你必须深入了解子系统的实现细节，比如按照正确顺序初始化对象和为其提供正确格式的数据</li>
<li><strong>客户端（Client）</strong> 使用外观代替对子系统对象的直接调用</li>
</ul>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">freeze</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CPU: Freezing...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">jump</span>(<span class="attr">position</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`CPU: Jumping to position <span class="subst">$&#123;position&#125;</span>...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">execute</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;CPU: Executing...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">load</span>(<span class="attr">position</span>: <span class="built_in">number</span>, <span class="attr">data</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Memory: Loading data &quot;<span class="subst">$&#123;data&#125;</span>&quot; to position <span class="subst">$&#123;position&#125;</span>...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HardDrive</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">read</span>(<span class="attr">position</span>: <span class="built_in">number</span>, <span class="attr">size</span>: <span class="built_in">number</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`HardDrive: Reading <span class="subst">$&#123;size&#125;</span> bytes from position <span class="subst">$&#123;position&#125;</span>...`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Some data from the hard drive&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。</span></span><br><span class="line"><span class="comment">// 它是在功能性和简洁性之间做出的权衡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerFacade</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">cpu</span>: <span class="variable constant_">CPU</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">memory</span>: <span class="title class_">Memory</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">hardDrive</span>: <span class="title class_">HardDrive</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span> = <span class="keyword">new</span> <span class="title function_">CPU</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memory</span> = <span class="keyword">new</span> <span class="title class_">Memory</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">hardDrive</span> = <span class="keyword">new</span> <span class="title class_">HardDrive</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">start</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span>.<span class="title function_">freeze</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memory</span>.<span class="title function_">load</span>(<span class="number">0</span>, <span class="string">&quot;Some initial data&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span>.<span class="title function_">jump</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> bootSector = <span class="variable language_">this</span>.<span class="property">hardDrive</span>.<span class="title function_">read</span>(<span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memory</span>.<span class="title function_">load</span>(<span class="number">0</span>, bootSector);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cpu</span>.<span class="title function_">execute</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="comment">// 应用程序的类并不依赖复杂框架中成千上万的类。</span></span><br><span class="line"><span class="comment">// 同样，如果你决定更换框架，那只需重写外观类即可</span></span><br><span class="line"><span class="keyword">const</span> computerFacade = <span class="keyword">new</span> <span class="title class_">ComputerFacade</span>();</span><br><span class="line">computerFacade.<span class="title function_">start</span>();</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式</li>
<li>如果需要将子系统组织为多层结构，可以使用外观</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以让自己的代码独立于复杂子系统</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>外观可能成为与程序中所有类都耦合的<strong>上帝对象</strong></li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/facade">Refactoringguru.cn 外观模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>facade</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/design-pattern-factory/</url>
    <content><![CDATA[<p>工厂方法模式是一种创建型设计模式,其在父类中提供一个创建对象的方法,允许子类决定实例化对象的类型.</p>
<p>工厂方法模式建议使用特殊的工厂方法代替对于对象构造函数的直接调用(即使用 <mark class="label info">new</mark> 运算符).不用担心,对象仍将通过<mark class="label info">new</mark>运算符创建,只是该运算符改在工厂方法中调用罢了.</p>
<p>工厂方法返回的对象通常被称作“产品”</p>
<pre><code class="highlight mermaid">classDiagram
class Logistics &#123;
 + planDelivery()
 + createTransport(): Transport
&#125;
class RoadLogistics &#123;
 + createTransport(): Transport
&#125;

class SeaLogistics &#123;
 + createTransport(): Transport
&#125;

Logistics &lt;|-- RoadLogistics
Logistics &lt;|-- SeaLogistics</code></pre>
<span id="more"></span>
<ul>
<li>
<mark class="label info">Logistics</mark> 物流工厂类
</li>
<li>
<mark class="label info">RoadLogistics</mark> 陆路物流工厂类, 重写工厂方法, 创建陆路运输工具(车)
</li>
<li>
<mark class="label info">SeaLogistic</mark> 水路物流工厂类, 重写工厂方法, 创建水路运输工具(船)
</li>
</ul>
<p>需要注意, 工厂方法创建的产品需要具有共同的基类或者接口. <mark class="label info">基类中的工厂方法(即Logistic > createTransport)</mark> 应将其返回类型声明为这一共有接口</p>
<pre><code class="highlight mermaid">classDiagram
class Transport &#123;
 &lt;&lt;interface&gt;&gt;
 + deliver()
&#125;
class Truck &#123;
+ deliver()
&#125;
class Ship &#123;
+ deliver()
&#125;

Transport &lt;|-- Truck
Transport &lt;|-- Ship</code></pre>
<div class="note primary"><p>必须要理解为什么返回的是通用接口,而不是具体的产品类实例. <mark class="label success"> (createTransport 返回的是 Transport, 而不是 Truck 或者 Ship)</mark></p>
<p>如果返回具体产品类实例, 创建方法就与具体产品之间产生了耦合. 此时, 你已经预知了需要的对象的确切类别和具体关系. 而工厂方法一般是在无法预知这两者时使用. 并且这样做也不利于用户拓展, 用户无法知道原有产品内部的逻辑, 当其想拓展另一种产品时, 根本无从下手. (返回通用接口时, 用户只需要编写满足接口要求的实现即可, 无需考虑已有的产品)</p>
</div>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品接口, 工厂方法创建的产品需要实现该接口</span></span><br><span class="line"><span class="comment">// 声明所有具体产品都必须实现的操作</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(): <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">getPrice</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品需提供产品接口的各种实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, price: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getPrice</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiscountedProduct</span> <span class="keyword">implements</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">price</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">discountRate</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, price: <span class="built_in">number</span>, discountRate: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">discountRate</span> = discountRate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getName</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getPrice</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span> * (<span class="number">1</span> - <span class="variable language_">this</span>.<span class="property">discountRate</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂基类(接口), 这里只有工厂方法, 也可以使用基类的方式. 额外定义产品的消费等</span></span><br><span class="line"><span class="comment">// 创建者类声明的工厂方法必须返回一个产品类的对象. 创建者的子类通常会提供该方法的实现</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span>; <span class="comment">// 注意返回值, 为产品实现的接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体创建者将重写工厂方法以改变其所返回的产品类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasicProductFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicProduct</span>(name, <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种产品工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DiscountedProductFactory</span> <span class="keyword">implements</span> <span class="title class_">ProductFactory</span> &#123;</span><br><span class="line">  <span class="title function_">createProduct</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DiscountedProduct</span>(name, <span class="number">10</span>, <span class="number">0.2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ProductType</span> &#123;</span><br><span class="line">  <span class="variable constant_">BASIC</span>,</span><br><span class="line">  <span class="variable constant_">DISCOUNTED</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前客户端代码会与具体创建者的示例进行交互, 但是必须通过其基本接口进行</span></span><br><span class="line"><span class="comment">// 只要客户端通过基本接口与创建者进行交互, 你就可以将任何创建者子类传递给客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductStore</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">productFactories</span>: <span class="title class_">Map</span>&lt;<span class="title class_">ProductType</span>, <span class="title class_">ProductFactory</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">productFactories</span> = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">productFactories</span>.<span class="title function_">set</span>(<span class="title class_">ProductType</span>.<span class="property">BASIC</span>, <span class="keyword">new</span> <span class="title class_">BasicProductFactory</span>());</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">productFactories</span>.<span class="title function_">set</span>(<span class="title class_">ProductType</span>.<span class="property">DISCOUNTED</span>, <span class="keyword">new</span> <span class="title class_">DiscountedProductFactory</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 注意返回值, 为产品实现的接口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">buyProduct</span>(<span class="attr">productType</span>: <span class="title class_">ProductType</span>, <span class="attr">name</span>: <span class="built_in">string</span>): <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> productFactory = <span class="variable language_">this</span>.<span class="property">productFactories</span>.<span class="title function_">get</span>(productType);</span><br><span class="line">    <span class="keyword">if</span> (!productFactory) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`Unsupported product type: <span class="subst">$&#123;productType&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> productFactory.<span class="title function_">createProduct</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">ProductStore</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> basicProduct = store.<span class="title function_">buyProduct</span>(<span class="title class_">ProductType</span>.<span class="property">BASIC</span>, <span class="string">&quot;Basic Product&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> discountedProduct = store.<span class="title function_">buyProduct</span>(<span class="title class_">ProductType</span>.<span class="property">DISCOUNTED</span>, <span class="string">&quot;Discounted Product&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(basicProduct.<span class="title function_">getName</span>(), basicProduct.<span class="title function_">getPrice</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(discountedProduct.<span class="title function_">getName</span>(), discountedProduct.<span class="title function_">getPrice</span>());</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当无法预知对象确切类别及其依赖关系时, 可使用工厂方法</li>
<li>希望用户能够拓展你的软件库或框架的内部组件, 可使用工厂方法</li>
<li>希望复用现有对象来节省系统资源,而不是每次都重新创建对象, 可使用工厂方法</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以避免创建者和具体产品之间的紧密耦合</li>
<li>单一职责原则.可以将产品创建代码放在程序的单一位置,从而使得代码更容易维护</li>
<li>开闭原则.无需更改现有客户端代码就可以在程序中引入新的产品类型</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>需要引入许多新的子类,代码可能会因此变得更复杂. 最好的情况是将该模式引入创建者类的现有层次结构中</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/factory-method">Refactoringguru.cn 工厂方法模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>factory-method</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/design-pattern-flyweight/</url>
    <content><![CDATA[<p><strong>享元模式</strong> 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式，通过共享多个对象共有的相同状态，让你能在有限的内存容量中载入更多对象</p>
<h2 id="享元模式结构">享元模式结构</h2>
<pre><code class="highlight mermaid">classDiagram
class FlyweightFactory &#123;
-cache: Flyweight[]
+getFlyweight(repeatingState)
&#125;
class Flyweight &#123;
-repeatingState
+operation(uniqueState)
&#125;
class Context &#123;
-uniqueState
-flyweight
+Context(repeatingState, uniqueState)
+operation()
&#125;
FlyweightFactory o--&gt; Flyweight
Context --&gt; Flyweight
FlyweightFactory &lt;-- Context
Client *--&gt; Context</code></pre>
<div class="note warning"><p>享元模式只是一种优化。在使用该模式之前，你要确定程序中存在大量类似对象同时占用内存相关的内存消耗问题，并且确保该问题无法使用其他更好的方式来解决</p>
</div>
<span id="more"></span>
<ul>
<li><strong>享元（Flyweight）</strong> 类包含原始对象中部分能在多个对象中共享的状态。同一享元对象可在许多不同情景中使用。享元中存储的状态被称为“内在状态”。传递给享元方法的状态被称为“外在状态”</li>
<li><strong>情景（Context）</strong> 类包含原始对象中各不相同的外在状态。情景和享元对象组合在一起就能表示原始对象的全部状态</li>
<li>通常情况下，原始对象的行为会保留在享元类中。因此调用享元方法必须提供部分外在状态作为参数。但你也可将行为移动到情景类中，然后将连入的享元作为单纯的数据对象</li>
<li><strong>客户端（Client）</strong> 负责计算或存储享元的外在状态。在客户端看来，享元是一种可在运行时进行配置的模板对象，具体的配置方式为向其方法中传入一些情景数据参数</li>
<li><strong>享元工厂（Flyweight Factory）</strong> 会对已有享元的缓存池进行管理。有了工厂后，客户端就无需直接创建享元，它们只需调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参照在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回；如果没有找到就根据参数创建新享元</li>
</ul>
<div class="note primary"><p><strong>享元与不可变性</strong></p>
<p>由于享元对象可在不同的情景中使用，你必须确保其状态不能被修改。享元类的状态只能由构造函数的参数进行一次性的初始化，它不能对其他对象公开其设置器或公有成员变量</p>
</div>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">flavor</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">flavor: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">flavor</span> = flavor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getFlavor</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">flavor</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">serveCoffee</span>(<span class="attr">context</span>: <span class="title class_">CoffeeContext</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Serving <span class="subst">$&#123;<span class="variable language_">this</span>.flavor&#125;</span> coffee to table <span class="subst">$&#123;context.getTable()&#125;</span>...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情景对象包含原始对象中的外在状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeContext</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">tableNumber</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tableNumber: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tableNumber</span> = tableNumber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getTable</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tableNumber</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元工厂决定是否复用已有享元或者创建一个新的对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">flavors</span>: <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Coffee</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Coffee</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getCoffeeFlavor</span>(<span class="attr">flavor</span>: <span class="built_in">string</span>): <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">flavors</span>.<span class="title function_">has</span>(flavor)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Creating new <span class="subst">$&#123;flavor&#125;</span> coffee...`</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">flavors</span>.<span class="title function_">set</span>(flavor, <span class="keyword">new</span> <span class="title class_">Coffee</span>(flavor));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">flavors</span>.<span class="title function_">get</span>(flavor) <span class="keyword">as</span> <span class="title class_">Coffee</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getTotalCoffeeFlavorsMade</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">flavors</span>.<span class="property">size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tables</span>: <span class="title class_">CoffeeContext</span>[] = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CoffeeContext</span>(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CoffeeContext</span>(<span class="number">2</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">CoffeeContext</span>(<span class="number">3</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> coffeeFactory = <span class="keyword">new</span> <span class="title class_">CoffeeFactory</span>();</span><br><span class="line"></span><br><span class="line">coffeeFactory.<span class="title function_">getCoffeeFlavor</span>(<span class="string">&quot;Cappuccino&quot;</span>).<span class="title function_">serveCoffee</span>(tables[<span class="number">0</span>]);</span><br><span class="line">coffeeFactory.<span class="title function_">getCoffeeFlavor</span>(<span class="string">&quot;Latte&quot;</span>).<span class="title function_">serveCoffee</span>(tables[<span class="number">1</span>]);</span><br><span class="line">coffeeFactory.<span class="title function_">getCoffeeFlavor</span>(<span class="string">&quot;Cappuccino&quot;</span>).<span class="title function_">serveCoffee</span>(tables[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Total coffee flavors made: <span class="subst">$&#123;coffeeFactory.getTotalCoffeeFlavorsMade()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>如果程序中有很多相似对象，那么你将可以节省大量内存</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>你可能需要牺牲执行速度来换取内存，因为他人每次调用享元方法时都需要重新计算部分场景数据</li>
<li>代码会变得更加复杂。</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/flyweight">Refactoringguru.cn 享元模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>cache</tag>
        <tag>flyweight</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/design-pattern-iterator/</url>
    <content><![CDATA[<p><strong>迭代器模式</strong> 是一种行为设计模式，让你能在不暴露集合底层表现形式（列表，栈和树等）的情况下遍历集合中所有的元素</p>
<pre><code class="highlight mermaid">classDiagram
class Client
class Iterator &#123;
&lt;&lt;interface&gt;&gt;
+getNext()
+hasMore(): bool
&#125;
class IterableCollection &#123;
&lt;&lt;interface&gt;&gt;
+createIterator(): Iterator
&#125;
class ConcreteCollection &#123;
...
+createIterator(): Iterator
&#125;
class ConcreteIterator &#123;
-collection: ConcreteCollection
-iterationState
+ConcreteIterator(c: ConcreteCollection)
+getNext()
+hasMore(): bool
&#125;

Client --&gt; Iterator
Client --&gt; IterableCollection
IterableCollection ..&gt; Iterator
Iterator &lt;|.. ConcreteIterator
IterableCollection &lt;|.. ConcreteCollection
ConcreteIterator &lt;--&gt; ConcreteCollection</code></pre>
<span id="more"></span>
<ul>
<li><strong>迭代器（Iterator）</strong> 接口声明了遍历几何所需的操作：获取下一个元素、获取当前位置和重新开始迭代等</li>
<li><strong>具体迭代器（Concrete Iterator）</strong> 实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合</li>
<li><strong>集合（collection）</strong> 接口声明了一个或多个方法来获取与集合兼容的迭代器。请注意，返回方法的类型必须被声明为迭代器接口，因此具体几何可以返回各种不同类型的迭代器</li>
<li><strong>具体集合（Concrete Collections）</strong> 会在客户端请求迭代器时返回一个特定的具体迭代器类实体（图中隐藏了集合的其他代码）。</li>
<li><strong>客户端（Client）</strong> 通过集合和迭代器的接口与两者进行交互。这样依赖客户端无需与具体类进行耦合，允许同一客户端代码使用各种不同的集合和迭代器</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">hasNext</span>(): <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="title function_">next</span>(): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Aggregate</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_">createIterator</span>(): <span class="title class_">Iterator</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">collection</span>: T[];</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">position</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">collection: T[]</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">collection</span> = collection;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">position</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">hasNext</span>(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">position</span> &lt; <span class="variable language_">this</span>.<span class="property">collection</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(): T &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;End of collection reached.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> element = <span class="variable language_">this</span>.<span class="property">collection</span>[<span class="variable language_">this</span>.<span class="property">position</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">position</span>++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Aggregate</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">collection</span>: T[];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">collection</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addItem</span>(<span class="attr">item</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">collection</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">createIterator</span>(): <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>(<span class="variable language_">this</span>.<span class="property">collection</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage Example</span></span><br><span class="line"><span class="keyword">const</span> aggregate = <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">aggregate.<span class="title function_">addItem</span>(<span class="number">1</span>);</span><br><span class="line">aggregate.<span class="title function_">addItem</span>(<span class="number">2</span>);</span><br><span class="line">aggregate.<span class="title function_">addItem</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = aggregate.<span class="title function_">createIterator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.<span class="title function_">hasNext</span>()) &#123;</span><br><span class="line">  <span class="keyword">const</span> item = iterator.<span class="title function_">next</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式</li>
<li>使用该模式可以减少程序中重复的遍历代码</li>
<li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>单一职责原则。通过将体积庞大的遍历算法代码抽取为独立的类，你可对客户端代码和集合进行整理</li>
<li>开闭原则。可实现新型的集合和迭代器并将其传递给现有代码，无需修改现有代码</li>
<li>可以并行遍历同一集合，因为每个迭代器对象都包含其自身的遍历状态</li>
<li>可以暂停遍历并在需要时继续</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>如果你的程序只与简单的集合进行交互，应用该模式可能会矫枉过正</li>
<li>对于某些特殊几何，使用迭代器可能比直接遍历的效率低</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/iterator">Refactoringguru.cn 迭代器模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/design-pattern-mediator/</url>
    <content><![CDATA[<p><strong>中介者模式</strong> 是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作</p>
<pre><code class="highlight mermaid">classDiagram
class ComponentA &#123;
-m: Mediator
+operationA()
&#125;
class ComponentB &#123;
-m: Mediator
+operationB()
&#125;
class ComponentC &#123;
-m: Mediator
+operationC()
&#125;
class ComponentD &#123;
-m: Mediator
+operationD()
&#125;
class Mediator &#123;
&lt;&lt;interface&gt;&gt;
+notify(sender)
&#125;
class ConcreteMediator &#123;
-componentA
-componentB
-componentC
-componentD
+notify(sender)
+reactOnA()
+reactOnB()
+reactOnC()
+reactOnD()
&#125;
ComponentA &lt;--* ConcreteMediator
ComponentA --&gt; Mediator
ComponentB --&gt; Mediator
Mediator &lt;-- ComponentC
Mediator &lt;|.. ConcreteMediator
Mediator &lt;-- ComponentD

ComponentB &lt;--* ConcreteMediator
ComponentC &lt;--* ConcreteMediator
ComponentD &lt;--* ConcreteMediator
</code></pre>
<span id="more"></span>
<ul>
<li><strong>组件（Component）</strong> 是各种包含业务逻辑的类。每个组件都有一个指向中介者的引用，该引用被声明为中介者接口类型。组件不知道中介者实际所属的类，因此你可通过将其连接到不同的中介者以使其能在其他程序中复用</li>
<li><strong>中介者（Mediator）</strong> 接口声明了与组件交流的方法，但通常仅包括一个通知方法。组件可将任意上下文（包括自己的对象）作为该方法的参数，只有这样接收组件和发送者类之间才不会耦合</li>
<li><strong>具体中介者（Concrete Mediator）</strong> 封装了多种组件间的关系。具体中介者通常会保存所有组件的引用并对其进行管理，甚至有时会对其生命周期进行管理</li>
<li>组件并不知道其他组件的情况。如果组件内发生了重要事件，它只能通知中介者。中介者收到通知后能轻易地确定发送者，者或许已足以判断接下来需要触发的组件了。</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mediator Interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="attr">sender</span>: <span class="title class_">Colleague</span>, <span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Colleague Base Class</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Colleague</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">mediator</span>: <span class="title class_">Mediator</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">mediator: Mediator</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mediator</span> = mediator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">send</span>(<span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mediator</span>.<span class="title function_">notify</span>(<span class="variable language_">this</span>, event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="title function_">receive</span>(<span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Colleague Classes</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Colleague</span> &#123;</span><br><span class="line">  <span class="title function_">receive</span>(<span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ConcreteColleague1 received event: <span class="subst">$&#123;event&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Colleague</span> &#123;</span><br><span class="line">  <span class="title function_">receive</span>(<span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`ConcreteColleague2 received event: <span class="subst">$&#123;event&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Mediator Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">implements</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">colleague1</span>: <span class="title class_">ConcreteColleague1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">colleague2</span>: <span class="title class_">ConcreteColleague2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColleague1</span>(<span class="attr">colleague1</span>: <span class="title class_">ConcreteColleague1</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colleague1</span> = colleague1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setColleague2</span>(<span class="attr">colleague2</span>: <span class="title class_">ConcreteColleague2</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colleague2</span> = colleague2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="attr">sender</span>: <span class="title class_">Colleague</span>, <span class="attr">event</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sender === <span class="variable language_">this</span>.<span class="property">colleague1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">colleague2</span>.<span class="title function_">receive</span>(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sender === <span class="variable language_">this</span>.<span class="property">colleague2</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">colleague1</span>.<span class="title function_">receive</span>(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> mediator = <span class="keyword">new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> colleague1 = <span class="keyword">new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class="line"><span class="keyword">const</span> colleague2 = <span class="keyword">new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class="line"></span><br><span class="line">mediator.<span class="title function_">setColleague1</span>(colleague1);</span><br><span class="line">mediator.<span class="title function_">setColleague2</span>(colleague2);</span><br><span class="line"></span><br><span class="line">colleague1.<span class="title function_">send</span>(<span class="string">&#x27;Event 1&#x27;</span>);</span><br><span class="line">colleague2.<span class="title function_">send</span>(<span class="string">&#x27;Event 2&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当一些对象和其他对象紧密耦合以致难以对其进行修改时，可使用中介者模式</li>
<li>当组件过于依赖其他组件而无法在不同应用中复用时，可使用中介者模式</li>
<li>如果为了能在不同情景下复用一些基本行为，导致你需要被迫创建大量组件子类时，可使用中介者模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>单一职责原则。你可以将多个组件间的交流抽取到同一位置，使其更易于理解和维护</li>
<li>开闭原则。你无需修改实际组件就能增加新的中介者</li>
<li>你可以减轻应用中多个组件的耦合情况</li>
<li>你可以更方便地复用各个组件</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>一段时间后，中介者可能会演化成为上帝对象</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/mediator">Refactoringguru.cn 中介者模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>intermediary</tag>
        <tag>controller</tag>
        <tag>mediator</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/design-pattern-memento/</url>
    <content><![CDATA[<p><strong>备忘录模式</strong> 是一种行为设计模式，允许在不暴露对象细节的情况下保存和恢复对象之前的状态</p>
<h2 id="基于嵌套类实现">基于嵌套类实现</h2>
<pre><code class="highlight mermaid">classDiagram
class Originator &#123;
-state
+save(): Memento
+restore(m: Memento)
&#125;
class Memento &#123;
-state
-Memento(state)
-getState()
&#125;
class Caretaker&#123;
-originator
-history: Memento[]
+doSomething()
+undo()
&#125;
Originator ..&gt; Memento
Memento &lt;--o Caretaker</code></pre>
<span id="more"></span>
<ul>
<li><strong>原发器（Originator）</strong> 类可以生成自身状态的快照，也可以在需要时通过快照恢复自身状态</li>
<li><strong>备忘录（Memento）</strong> 是原发器状态快照的值对象（value Object）。通常做法是将备忘录设为不可变，并通过构造函数一次性传递数据</li>
<li><strong>负责人（Caretaker）</strong> 仅知道“何时”和“为何”捕捉原发器的状态，以及何时恢复状态</li>
<li>在该实现方法中，备忘录类将被嵌套在原发器中。这样原发器就可访问备忘录的成员变量和方法，即使这些方法被声明为私有。另一方面，负责人对于备忘录的成员变量和方法的访问权限非常有限：它们只能在栈中保存备忘录，而不能修改其状态。</li>
</ul>
<h3 id="Typescript中的嵌套类">Typescript中的嵌套类</h3>
<p>在Typescript中，没有直接支持嵌套类的语法。嵌套类指的是在一个类内部定义另一个类。然而，可以通过其他方式实现类似的效果</p>
<p>一种常见的方法是使用内部类（inner classes），即在外部类的成员中定义一个独立的类。这个内部类可以访问外部类的成员和方法，但在外部类之外是不可见的。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">  <span class="attr">outerProperty</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">outerProperty: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outerProperty</span> = outerProperty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">outerMethod</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Outer method&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="attr">innerClass</span>: <span class="title class_">InnerClass</span> = <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inner class</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    <span class="attr">innerProperty</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">innerProperty</span> = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">innerMethod</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Inner method&#x27;</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Accessing outer property:&#x27;</span>, outerProperty); <span class="comment">// Access outer property</span></span><br><span class="line">      <span class="title function_">outerMethod</span>(); <span class="comment">// Access outer method</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> outerObj = <span class="keyword">new</span> <span class="title class_">OuterClass</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">outerObj.<span class="property">innerClass</span>.<span class="title function_">innerMethod</span>();</span><br></pre></td></tr></table></figure>
<h2 id="基于中间接口的实现">基于中间接口的实现</h2>
<pre><code class="highlight mermaid">classDiagram
class Originator &#123;
-state
+save(): Memento
+restore(m:Memento)
&#125;
class ConcreteMemento &#123;
-state
+ConcreteMemento(state)
+getState()
&#125;
class Memento &#123;
&lt;&lt;interface&gt;&gt;
&#125;
class Client &#123;
-originator
-history:Memento[]
+undo()
&#125;
Originator ..&gt; ConcreteMemento
Memento &lt;|.. ConcreteMemento
Memento &lt;--o Client</code></pre>
<ul>
<li>在没有嵌套类的情况下，你可以规定负责人仅可通过声明的中间接口与备忘录互动，该接口仅声明与备忘录元数据相关的方法，限制其对备忘录成员变量的直接访问权限</li>
<li>另一方面，原发器可以直接与备忘录对象进行交互，访问备忘录类中声明的成员变量和方法。这种方式的确定在于你需要将备忘录的所有成员变量声明为公有</li>
</ul>
<h2 id="封装更加严格的实现">封装更加严格的实现</h2>
<p>如果你不想让其他类有任何机会通过备忘录来访问原发器的状态，那么还有另一种可用的实现方式</p>
<pre><code class="highlight mermaid">classDiagram
class Originator &#123;
&lt;&lt;interface&gt;&gt;
save(): Memento
&#125;
class ConcreteOriginator &#123;
-state
+save(): Memento
+setState(state)
&#125;
class Memento &#123;
&lt;&lt;interface&gt;&gt;
+restore()
&#125;
class ConcreteMemento &#123;
-originator
-state
+ConcreteMemento(originator, state)
+restore()
&#125;
class Caretaker &#123;
-history: Memento[]
+undo()
&#125;

Originator &lt;|.. ConcreteOriginator
Originator  ..&gt; Memento
Memento &lt;|.. ConcreteMemento
ConcreteOriginator &lt;--&gt; ConcreteMemento
Memento &lt;--o Caretaker
</code></pre>
<ul>
<li>这种实现方式允许存在多种不同类型的原发器和备忘录。每种原发器都和其相应的备忘录进行交互。原发器和备忘录都不会将其状态暴露给其他类</li>
<li>负责人此时被明确禁止修改存储在备忘录中的状态。但负责人将独立于原发器，因为此时恢复方法被定义在备忘录类中</li>
<li>每个备忘录将于创建了自身的原发器连接。原发器会将自己及状态传递给备忘录的构造函数。由于这些类之间的紧密联系，只要原发器定义了合适的设置器（setter），备忘录就能恢复其状态</li>
</ul>
<h2 id="代码实现（基于中间接口）">代码实现（基于中间接口）</h2>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Originator class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setState</span>(<span class="attr">state</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting state to: <span class="subst">$&#123;state&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">saveToMemento</span>(): <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Saving state to memento&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(<span class="variable language_">this</span>.<span class="property">state</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">restoreFromMemento</span>(<span class="attr">memento</span>: <span class="title class_">Memento</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Restoring state from memento&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = memento.<span class="title function_">getState</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">showState</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current state: <span class="subst">$&#123;<span class="variable language_">this</span>.state&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memento class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">state</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">state: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getState</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caretaker class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">mementos</span>: <span class="title class_">Memento</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addMemento</span>(<span class="attr">memento</span>: <span class="title class_">Memento</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mementos</span>.<span class="title function_">push</span>(memento);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getMemento</span>(<span class="attr">index</span>: <span class="built_in">number</span>): <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">mementos</span>[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> originator = <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line"><span class="keyword">const</span> caretaker = <span class="keyword">new</span> <span class="title class_">Caretaker</span>();</span><br><span class="line"></span><br><span class="line">originator.<span class="title function_">setState</span>(<span class="string">&quot;State 1&quot;</span>);</span><br><span class="line">caretaker.<span class="title function_">addMemento</span>(originator.<span class="title function_">saveToMemento</span>());</span><br><span class="line"></span><br><span class="line">originator.<span class="title function_">setState</span>(<span class="string">&quot;State 2&quot;</span>);</span><br><span class="line">caretaker.<span class="title function_">addMemento</span>(originator.<span class="title function_">saveToMemento</span>());</span><br><span class="line"></span><br><span class="line">originator.<span class="title function_">setState</span>(<span class="string">&quot;State 3&quot;</span>);</span><br><span class="line">originator.<span class="title function_">showState</span>();</span><br><span class="line"></span><br><span class="line">originator.<span class="title function_">restoreFromMemento</span>(caretaker.<span class="title function_">getMemento</span>(<span class="number">1</span>));</span><br><span class="line">originator.<span class="title function_">showState</span>();</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当你需要创建对象状态快照来恢复其之前的状态时，可以使用备忘录模式</li>
<li>当直接访问对象的成员变量，获取器或设置器将导致封装被突破时，可以使用该模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以在不破坏对象封装情况的前提下创建对象状态快照</li>
<li>可以通过让负责人维护原发器状态历史记录来简化原发器代码</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>如果客户端过于频繁地创建备忘录，程序将消耗大量内存</li>
<li>负责人必须完整跟踪原发器的生命周期，这样才能销毁弃用的备忘录</li>
<li>绝大部分动态编程语言（例如PHP、Python和Javascript）不能确保备忘录中的状态不被修改</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/memento">Refactoringguru.cn 备忘录模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>snapshot</tag>
        <tag>memento</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/design-pattern-singleton/</url>
    <content><![CDATA[<p><strong>单例模式</strong>是一种创建型设计模式，让你能够保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p>
<pre><code class="highlight mermaid">classDiagram
class Singleton &#123;
-instance Singleton$
-Singleton()
+getInstance()$ Singleton
&#125;

Singleton &lt;-- Singleton</code></pre>
<p><strong>单例（Singleton）</strong> 类声明了一个名为 <mark class="label info">getInstance</mark> 的静态方法来返回其所属类的一个相同实例</p>
<p>单例的构造函数必须对客户端（Client）代码隐藏。调用<mark class="label info">getInstance</mark> 方法必须是获取单例对象的唯一方式</p>
<span id="more"></span>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 保存单例类型实例的成员变量必须被声明为静态类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="attr">instance</span>: <span class="title class_">Singleton</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">data</span>: <span class="built_in">string</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单例的构造函数必须永远是私有类型，以防使用 `new` 运算符直接调用构造方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 部分初始化代码</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于控制对单例实例的访问权限的静态方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">getInstance</span>(): <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Singleton</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">      <span class="title class_">Singleton</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Singleton</span>.<span class="property">instance</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何单例都必须定义一些可以在其实例上执行的业务逻辑</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">addData</span>(<span class="attr">data</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">removeData</span>(<span class="attr">index</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">getData</span>(): <span class="built_in">string</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage</span></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">instance1.<span class="title function_">addData</span>(<span class="string">&quot;Data 1&quot;</span>);</span><br><span class="line">instance1.<span class="title function_">addData</span>(<span class="string">&quot;Data 2&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">getData</span>()); <span class="comment">// Output: [&quot;Data 1&quot;, &quot;Data 2&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="title class_">Singleton</span>.<span class="title function_">getInstance</span>();</span><br><span class="line">instance2.<span class="title function_">removeData</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="title function_">getData</span>()); <span class="comment">// Output: [&quot;Data 2&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="title function_">getData</span>()); <span class="comment">// Output: [&quot;Data 2&quot;]</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>程序中的某个类对于所有客户端只有一个可用的实例，可以使用单例模式</li>
<li>当需要更加严格地控制全局变量时，可以使用单例模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以保证一个类只有一个实例</li>
<li>获得一个指向该实例的全局访问节点</li>
<li>仅在首次请求单例对象时对其进行初始化</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>违反单一职责原则。该模式同时解决了两个问题</li>
<li>单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等</li>
<li>在多线程环境下需要进行特殊处理</li>
<li>单元的客户端单元测试可能会比较困难</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/factory-method">Refactoringguru.cn 单例模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/design-pattern-proxy/</url>
    <content><![CDATA[<p><strong>代理模式</strong> 是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理空着着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p>
<h2 id="代理模式结构">代理模式结构</h2>
<pre><code class="highlight mermaid">classDiagram
class Client
class ServiceInterface &#123;
&lt;&lt;interface&gt;&gt;
+operation()
&#125;
class Proxy &#123;
-realService: Service
+Proxy(s: Service)
+checkAccess()
+operation()
&#125;
class Service &#123;
...
+operation()
&#125;
Client --&gt; ServiceInterface
ServiceInterface &lt;|.. Proxy
ServiceInterface &lt;|.. Service
Proxy o--&gt; Service</code></pre>
<span id="more"></span>
<ul>
<li><strong>服务接口（Service Interface）</strong> 声明了服务接口。代理必须遵循该接口才能伪装成服务对象</li>
<li><strong>服务（Service）</strong> 类提供了一些实用的业务逻辑</li>
<li><strong>代理（Proxy）</strong> 类包含一个指向服务对象的引用成员变量。代理完成其任务（例如延迟初始化、记录日志、访问控制和缓存等）后会将请求传递给服务对象<br>
通常情况下，代理会对其服务对象的整个生命周期进行管理</li>
<li><strong>客户端（Client）</strong> 能通过同一接口与服务或代理进行交互，所以你可在一切需要服务对象的代码中使用代理</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">  <span class="title function_">display</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">fileName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fileName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fileName</span> = fileName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">loadFromDisk</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">display</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Displaying <span class="subst">$&#123;<span class="variable language_">this</span>.fileName&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">loadFromDisk</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Loading <span class="subst">$&#123;<span class="variable language_">this</span>.fileName&#125;</span> from disk`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">realImage</span>: <span class="title class_">RealImage</span> | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">fileName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">fileName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fileName</span> = fileName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">display</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">realImage</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">realImage</span> = <span class="keyword">new</span> <span class="title class_">RealImage</span>(<span class="variable language_">this</span>.<span class="property">fileName</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">realImage</span>.<span class="title function_">display</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="keyword">const</span> image1 = <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(<span class="string">&quot;image1.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> image2 = <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(<span class="string">&quot;image2.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> image3 = <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(<span class="string">&quot;image3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">image1.<span class="title function_">display</span>(); <span class="comment">// Loading image1.jpg from disk, Displaying image1.jpg</span></span><br><span class="line">image2.<span class="title function_">display</span>(); <span class="comment">// Loading image2.jpg from disk, Displaying image2.jpg</span></span><br><span class="line">image3.<span class="title function_">display</span>(); <span class="comment">// Loading image3.jpg from disk, Displaying image3.jpg</span></span><br><span class="line">image1.<span class="title function_">display</span>(); <span class="comment">// Displaying image1.jpg</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>延迟初始化（虚拟代理）。如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式</li>
<li>访问控制（保护代理）。如果你只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序（包括恶意程序），此时可使用代理模式</li>
<li>本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形</li>
<li>记录日志请求（日志记录代理）。适用于当你需要保存对于服务对象的请求历史记录时</li>
<li>缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时</li>
<li>智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以在客户端毫无察觉的情况下控制服务对象</li>
<li>如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理</li>
<li>即使服务对象还未准备好或不存在，代理也可以正常工作</li>
<li>开闭原则。你可以在不对服务或客户端做出修改的情况下创建新代理</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>代码可能会变得复杂，因为需要新建许多类</li>
<li>服务响应可能会延迟</li>
</ul>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ul>
<li>适配器模式能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰模式则能为对象提供加强的接口</li>
<li>外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同</li>
<li>装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理服务对象的生命周期，而装饰的生成则总是由客户端进行控制</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/proxy">Refactoringguru.cn 代理模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/design-pattern-observer/</url>
    <content><![CDATA[<p><strong>观察者模式</strong>是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象</p>
<pre><code class="highlight mermaid">classDiagram
class Publisher &#123;
-subscribers: Subscriber[]
-mainState
+subscribe(s: Subscriber)
+unsubscribe(s: Subscriber)
+notifySubscribers()
+mainBusinessLogic()
&#125;
class Subscriber &#123;
&lt;&lt;interface&gt;&gt;
+update(context)
&#125;
class ConcreteSubscribers &#123;
...
+update(context)
&#125;
class Client

Publisher &lt;-- Client
Publisher o--&gt; Subscriber
Subscriber &lt;|.. ConcreteSubscribers
ConcreteSubscribers &lt;.. Client</code></pre>
<span id="more"></span>
<ul>
<li><strong>发布者（Publisher）</strong> 会向其他对象发送值得关注的事件。事件会在发布者自身状态改变或执行特定行为后发生。发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅架构</li>
<li>当新事件发生时，发送者会遍历订阅列表并调用每个订阅者对象的通知方法。该方法是在订阅者接口中声明的</li>
<li><strong>订阅者（Subscriber）</strong> 接口声明了通知接口。在绝大多数情况下，该接口仅包含一个update方法。该方法可以拥有多个参数，使发布者能在更新时传递事件的详细信息</li>
<li><strong>具体订阅者（Concrete Subscriber）</strong> 可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口，因此发布者不需要与具体类相耦合</li>
<li>订阅者通常需要一些上下文信息来正确地处理更新。因此，发布者通常会将一些上下文数据作为通知方法的参数进行传递。发布者也可将自身作为参数进行传递，使订阅者直接获取所需的数据</li>
<li><strong>客户端（Client）</strong> 会分别创建发布者和订阅者对象，然后为订阅者注册发布者更新</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subscriber</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> received data: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewsPublisher</span> <span class="keyword">implements</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">subscribers</span>: <span class="title class_">Observer</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(subscriber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">indexOf</span>(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`NewsPublisher is notifying subscribers...`</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> subscriber <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">subscribers</span>) &#123;</span><br><span class="line">      subscriber.<span class="title function_">update</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publishNews</span>(<span class="attr">news</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Publishing news: <span class="subst">$&#123;news&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notify</span>(news);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeatherPublisher</span> <span class="keyword">implements</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">subscribers</span>: <span class="title class_">Observer</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(subscriber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="attr">subscriber</span>: <span class="title class_">Observer</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">indexOf</span>(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="attr">data</span>: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`WeatherPublisher is notifying subscribers...`</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> subscriber <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">subscribers</span>) &#123;</span><br><span class="line">      subscriber.<span class="title function_">update</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publishWeather</span>(<span class="attr">weather</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Publishing weather: <span class="subst">$&#123;weather&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notify</span>(weather);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example</span></span><br><span class="line"><span class="keyword">const</span> newsPublisher = <span class="keyword">new</span> <span class="title class_">NewsPublisher</span>();</span><br><span class="line"><span class="keyword">const</span> weatherPublisher = <span class="keyword">new</span> <span class="title class_">WeatherPublisher</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subscriber1 = <span class="keyword">new</span> <span class="title class_">Subscriber</span>(<span class="string">&quot;Subscriber 1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> subscriber2 = <span class="keyword">new</span> <span class="title class_">Subscriber</span>(<span class="string">&quot;Subscriber 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">newsPublisher.<span class="title function_">subscribe</span>(subscriber1);</span><br><span class="line">newsPublisher.<span class="title function_">subscribe</span>(subscriber2);</span><br><span class="line"></span><br><span class="line">weatherPublisher.<span class="title function_">subscribe</span>(subscriber2);</span><br><span class="line"></span><br><span class="line">newsPublisher.<span class="title function_">publishNews</span>(<span class="string">&quot;New article published!&quot;</span>);</span><br><span class="line">weatherPublisher.<span class="title function_">publishWeather</span>(<span class="string">&quot;Sunny day ahead!&quot;</span>);</span><br><span class="line"></span><br><span class="line">newsPublisher.<span class="title function_">unsubscribe</span>(subscriber1);</span><br><span class="line">weatherPublisher.<span class="title function_">unsubscribe</span>(subscriber2);</span><br><span class="line"></span><br><span class="line">newsPublisher.<span class="title function_">publishNews</span>(<span class="string">&quot;Breaking news!&quot;</span>);</span><br><span class="line">weatherPublisher.<span class="title function_">publishWeather</span>(<span class="string">&quot;Rainy weather expected.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[LOG]: &quot;Publishing news: New article published!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;NewsPublisher is notifying subscribers...&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Subscriber 1 received data: New article published!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Subscriber 2 received data: New article published!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Publishing weather: Sunny day ahead!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;WeatherPublisher is notifying subscribers...&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Subscriber 2 received data: Sunny day ahead!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Publishing news: Breaking news!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;NewsPublisher is notifying subscribers...&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Subscriber 2 received data: Breaking news!&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;Publishing weather: Rainy weather expected.&quot; </span></span><br><span class="line"><span class="comment">[LOG]: &quot;WeatherPublisher is notifying subscribers...&quot; </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式</li>
<li>当应用中的一些对象必须观察其他对象时，可使用该模式。但仅能在有限时间内或特定情况下使用</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>开闭原则。你无需修改发布者代码就能引入新的订阅者类（如果是发布者接口则可轻松引入发布者类）</li>
<li>你可以在运行时建立对象之间的联系</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>订阅者的通知顺序是随机的</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/observer">Refactoringguru.cn 观察者模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>evnet-subscriber</tag>
        <tag>listener</tag>
        <tag>observer</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/design-pattern-strategy/</url>
    <content><![CDATA[<p><strong>策略模式</strong> 是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替代</p>
<pre><code class="highlight mermaid">classDiagram
class Context &#123;
-strategy
+setStrategy(strategy)
+doSomething()
&#125;
class Strategy &#123;
&lt;&lt;interface&gt;&gt;
+execute(data)
&#125;
class ConcreteStrategies &#123;
+execute(data)
&#125;
class Client
Context &lt;-- Client
Context o--&gt; Strategy
Strategy &lt;|.. ConcreteStrategies
Client ..&gt; ConcreteStrategies</code></pre>
<span id="more"></span>
<ul>
<li><strong>上下文（Context）</strong> 维护指向具体策略的引用，且仅通过策略接口与该对象进行交流</li>
<li><strong>策略（Strategy）</strong> 接口是所有具体策略的通用接口，它声明了一个上下文用于执行策略的方法</li>
<li><strong>具体策略（Concrete Strategies）</strong> 实现了上下文所用算法的各种不同变体</li>
<li>当上下文需要运行算法时，它会在其已连接的策略对象上调用执行方法。上下文不清楚其所涉及的策略类型与算法的执行方式</li>
<li><strong>客户端（Client）</strong> 会创建一个特定策略对象并将其传递给上下文。上下文则会提供一个设置器以便客户端在运行时替换关联的策略</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Define the strategy interface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SortingStrategy</span> &#123;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="attr">data</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement concrete sorting strategies</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">SortingStrategy</span> &#123;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="attr">data</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="comment">// Sort the data using bubble sort algorithm</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Sorting using bubble sort&quot;</span>);</span><br><span class="line">    <span class="comment">// ... implementation</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">implements</span> <span class="title class_">SortingStrategy</span> &#123;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="attr">data</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="comment">// Sort the data using quick sort algorithm</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Sorting using quick sort&quot;</span>);</span><br><span class="line">    <span class="comment">// ... implementation</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MergeSort</span> <span class="keyword">implements</span> <span class="title class_">SortingStrategy</span> &#123;</span><br><span class="line">  <span class="title function_">sort</span>(<span class="attr">data</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="comment">// Sort the data using merge sort algorithm</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Sorting using merge sort&quot;</span>);</span><br><span class="line">    <span class="comment">// ... implementation</span></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Context class that uses the sorting strategy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">strategy</span>: <span class="title class_">SortingStrategy</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">strategy: SortingStrategy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setStrategy</span>(<span class="params">strategy: SortingStrategy</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">strategy</span> = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sort</span>(<span class="attr">data</span>: <span class="built_in">number</span>[]): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">strategy</span>.<span class="title function_">sort</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example</span></span><br><span class="line"><span class="keyword">const</span> data = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sorter = <span class="keyword">new</span> <span class="title class_">Sorter</span>(<span class="keyword">new</span> <span class="title class_">BubbleSort</span>());</span><br><span class="line">sorter.<span class="title function_">sort</span>(data);</span><br><span class="line"></span><br><span class="line">sorter.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title class_">QuickSort</span>());</span><br><span class="line">sorter.<span class="title function_">sort</span>(data);</span><br><span class="line"></span><br><span class="line">sorter.<span class="title function_">setStrategy</span>(<span class="keyword">new</span> <span class="title class_">MergeSort</span>());</span><br><span class="line">sorter.<span class="title function_">sort</span>(data);</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当你想使用对象中各种不同的算法变体，并希望能在运行时切换算法时，可使用策略模式。</li>
<li>当你有许多仅在执行某些行为时略有不同的相似类时，可使用策略模式</li>
<li>如果算法在上下文的逻辑中不是特别重要，使用该模式能将雷德业务逻辑与其算法实现细节隔离开来</li>
<li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时，可使用该模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>可以在运行时切换对象内的算法</li>
<li>可以将算法的实现和使用算法的代码隔离开来</li>
<li>可以使用组合来替代继承</li>
<li>开闭原则。无需对上下文进行修改就能够引入新的策略</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>如果你的算法极少发生改变，那么没有任何理由引入新的类和接口。使用该模式只会让程序过于复杂</li>
<li>客户端必须知晓策略间的不同，它需要选择合适的策略</li>
<li>许多现代编程语言支持函数类型功能，允许你在一组匿名函数中实现不同版本的算法。这样，你使用这些函数的方式就和使用策略对象时完全相同，无需借助额外的类和接口来保持代码简洁</li>
</ul>
<h2 id="与其他模式的区别">与其他模式的区别</h2>
<ul>
<li><strong><a href="/design-pattern-command/" title="命令模式">命令模式</a></strong> 和 <strong><a href="/design-pattern-strategy/" title="策略模式">策略模式</a></strong> 开上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同
<ul>
<li>你可以使用命令来将任何操作转换为对象。操作的参数将成为对象的成员变量。你可以通过转换来延迟操作的执行、将操作放入队列、保持历史命令或向远程服务器发送命令等。</li>
<li>另一方面，策略通常可用于描述完成某件事的不同方式，让你能够在同一个上下文类中切换算法</li>
</ul>
</li>
<li><strong><a href="/design-pattern-state/" title="状态模式">状态模式</a></strong> 可被视为 <strong><a href="/design-pattern-strategy/" title="策略模式">策略模式</a></strong> 的拓展两者都基于组合机制：它们都通过将部分工作委派给“帮手”对象量改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/strategy">Refactoringguru.cn 策略模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>stategy</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/design-pattern-template-method/</url>
    <content><![CDATA[<p><strong>模板方法模式</strong> 是一种行为设计模式，它在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤</p>
<pre><code class="highlight mermaid">classDiagram
class AbstractClass &#123;
...
+templateMethod()
+step1()
+step2()
+step3()
+step4()
&#125;
class ConcreteClass1 &#123;
...
+step3()
+step4()
&#125;
class ConcreteClass2 &#123;
...
+step1()
+step2()
+step3()
+step4()
&#125;

AbstractClass &lt;|-- ConcreteClass1
AbstractClass &lt;|-- ConcreteClass2</code></pre>
<span id="more"></span>
<ul>
<li><strong>抽象类（AbstractClass）</strong> 会声明作为算法步骤的方法，以及依次调用它们实际的模板方法。算法步骤可以被声明为 <strong>抽象</strong>类型，也可以提供一些默认实现</li>
<li><strong>具体类（ConcreteClass）</strong> 可以重写所有步骤，但不能重写模板方法自身</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">DataProcessor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">processData</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="title function_">extractData</span>();</span><br><span class="line">    <span class="keyword">const</span> transformedData = <span class="variable language_">this</span>.<span class="title function_">transformData</span>(data);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">displayData</span>(transformedData);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title function_">extractData</span>(): <span class="built_in">any</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="title function_">transformData</span>(<span class="attr">data</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>[];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">displayData</span>(<span class="attr">data</span>: <span class="built_in">any</span>[]): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Processed Data:&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSVDataProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DataProcessor</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">extractData</span>(): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Extracting data from CSV file...&#x27;</span>);</span><br><span class="line">    <span class="comment">// Perform CSV data extraction logic here</span></span><br><span class="line">    <span class="keyword">const</span> extractedData = [<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;Jane Smith&#x27;</span>, <span class="string">&#x27;Bob Johnson&#x27;</span>];</span><br><span class="line">    <span class="keyword">return</span> extractedData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">transformData</span>(<span class="attr">data</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Transforming CSV data...&#x27;</span>);</span><br><span class="line">    <span class="comment">// Perform CSV data transformation logic here</span></span><br><span class="line">    <span class="keyword">const</span> transformedData = data.<span class="title function_">map</span>(<span class="function">(<span class="params">name</span>) =&gt;</span> (&#123; name &#125;));</span><br><span class="line">    <span class="keyword">return</span> transformedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSONDataProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">DataProcessor</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">extractData</span>(): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Extracting data from JSON file...&#x27;</span>);</span><br><span class="line">    <span class="comment">// Perform JSON data extraction logic here</span></span><br><span class="line">    <span class="keyword">const</span> extractedData = [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;Jane Smith&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob Johnson&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span> &#125;</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> extractedData;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">transformData</span>(<span class="attr">data</span>: <span class="built_in">any</span>[]): <span class="built_in">any</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Transforming JSON data...&#x27;</span>);</span><br><span class="line">    <span class="comment">// Perform JSON data transformation logic here</span></span><br><span class="line">    <span class="keyword">const</span> transformedData = data.<span class="title function_">map</span>(<span class="function">(<span class="params">person</span>) =&gt;</span> person.<span class="property">name</span>);</span><br><span class="line">    <span class="keyword">return</span> transformedData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client code</span></span><br><span class="line"><span class="keyword">const</span> csvDataProcessor = <span class="keyword">new</span> <span class="title class_">CSVDataProcessor</span>();</span><br><span class="line">csvDataProcessor.<span class="title function_">processData</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jsonDataProcessor = <span class="keyword">new</span> <span class="title class_">JSON</span>DataProcessor();</span><br><span class="line">jsonDataProcessor.<span class="title function_">processData</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Extracting data from CSV file...</span></span><br><span class="line"><span class="comment">Transforming CSV data...</span></span><br><span class="line"><span class="comment">Processed Data:</span></span><br><span class="line"><span class="comment">[ &#123; name: &#x27;John Doe&#x27; &#125;, &#123; name: &#x27;Jane Smith&#x27; &#125;, &#123; name: &#x27;Bob Johnson&#x27; &#125; ]</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">Extracting data from JSON file...</span></span><br><span class="line"><span class="comment">Transforming JSON data...</span></span><br><span class="line"><span class="comment">Processed Data:</span></span><br><span class="line"><span class="comment">[ &#x27;John Doe&#x27;, &#x27;Jane Smith&#x27;, &#x27;Bob Johnson&#x27; ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>当你只希望客户端拓展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式</li>
<li>当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是，只要算法发生变化，你就可能需要修改所有的类</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>你可仅允许客户端重写一个大型算法中的特定部分，使得算法其他部分修改对其所造成的影响减小</li>
<li>你可将重复代码提取到一个超类中</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>部分客户端可能会受到算法框架的限制</li>
<li>通过子类抑制默认步骤实现可能会导致违反里氏替换原则</li>
<li>模板方法中的步骤越多，其维护工作中就可能会越困难</li>
</ul>
<h2 id="与其他模式的关系">与其他模式的关系</h2>
<ul>
<li>
<a href="/design-pattern-factory/" title="工厂方法模式">工厂方法模式</a>是 **模板方法模式** 的一种特殊形式。同时，工厂方法可以作为一个大型模板方法中的一个步骤
</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/template-method">Refactoringguru.cn 模板方法模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>template method</tag>
      </tags>
  </entry>
  <entry>
    <title>双端 Diff 算法</title>
    <url>/doubleside-diff/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第十章 - 双端 Diff 算法 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<span id="more"></span>
<p>双端 Diff 的算法指的是, 在新旧两组子节点的四个端点之间分别进行比较, 并视图找到可复用的节点.相比简单 Diff 算法, 双端 Diff 算法的优势在于, 对于同样的更新场景, 执行的 DOM 移动操作次数更少</p>
<h2 id="代码实现">代码实现</h2>
<p>在书中有算法实现的完整思路, 由浅入深,说的非常明白. 这里仅贴出最终的示例代码, 供重温用, 更为具体的讲解参见书籍原文.</p>
<div class="note primary"><p>代码中<mark class="label info">patch, patchElement, patchChildren</mark>函数, 在书中第八章 - 挂载与更新中有详细的讲解, 代码已贴到 <a href="/simple-diff/#%E9%99%84%E5%BD%95">简单 Diff 算法#附录</a>中</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双端 Diff 算法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = n2.<span class="property">children</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 四个索引值</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 四个索引指向的 vnode 节点</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVNode = oldChildren[oldStartIdx]</span><br><span class="line">  <span class="keyword">let</span> oldEndVNode = oldChildren[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newStartVNode = newChildren[newStartIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndVNode = newChildren[newEndIdx]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!oldStartVNode) &#123;</span><br><span class="line">      <span class="comment">// DOM 已被移动</span></span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVNode) &#123;</span><br><span class="line">      <span class="comment">// DOM 已被移动</span></span><br><span class="line">      oldEndVNode = newChildren[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartVNode.<span class="property">key</span> === newStartVNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 步骤一： oldStartVNode 和 newStartVNode 比较</span></span><br><span class="line">      <span class="comment">// 无需移动</span></span><br><span class="line">      <span class="title function_">patch</span>(oldStartVNode, newStartVNode, container)</span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.<span class="property">key</span> === newEndVNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 步骤二： oldEndVNode 和 newEndVNode 比较</span></span><br><span class="line">      <span class="comment">// 无需移动</span></span><br><span class="line">      <span class="title function_">patch</span>(oldEndVNode, newEndVNode, container)</span><br><span class="line">      oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">      newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartVNode.<span class="property">key</span> === newEndVNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 步骤三： oldStartVNode 和 newEndVNode 比较</span></span><br><span class="line">      <span class="title function_">patch</span>(oldStartVNode, newEndVNode, container)</span><br><span class="line">      <span class="comment">// oldStartVNode.el 移动到 oldEndVNode.el.nextSibling 前面</span></span><br><span class="line">      <span class="title function_">insert</span>(oldStartVNode.<span class="property">el</span>, container, oldEndVNode.<span class="property">el</span>.<span class="property">nextSibling</span>)</span><br><span class="line"></span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">      newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.<span class="property">key</span> === newStartVNode.<span class="property">key</span>) &#123;</span><br><span class="line">      <span class="comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span></span><br><span class="line">      <span class="title function_">patch</span>(oldEndVNode, newStartVNode, container)</span><br><span class="line">      <span class="comment">// oldEndVNode.el 移动到 oldStartVNode.el 前面</span></span><br><span class="line">      <span class="title function_">insert</span>(oldEndVNode.<span class="property">el</span>, container, oldStartVNode.<span class="property">el</span>)</span><br><span class="line"></span><br><span class="line">      oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span></span><br><span class="line">      <span class="keyword">const</span> idxInOld = oldChildren.<span class="title function_">findIndex</span>(</span><br><span class="line">        <span class="function"><span class="params">node</span> =&gt;</span> node.<span class="property">key</span> === newStartVNode.<span class="property">key</span></span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (idxInOld &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到可复用的节点</span></span><br><span class="line">        <span class="keyword">const</span> vnodeToMove = oldChildren[idxInOld]</span><br><span class="line">        <span class="title function_">patch</span>(vnodeToMove, newStartVNode, container)</span><br><span class="line">        <span class="comment">// vnodeToMove.el 移动到 oldStartVNode.el 前</span></span><br><span class="line">        <span class="title function_">insert</span>(vnodeToMove.<span class="property">el</span>, container, oldStartVNode.<span class="property">el</span>)</span><br><span class="line">        oldChildren[idxInOld] = <span class="literal">undefined</span>	<span class="comment">// 标记该处对应的真实DOM已经移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没找到可复用的节点 挂载新节点到 oldStartVNode.el 前</span></span><br><span class="line">        <span class="title function_">patch</span>(<span class="literal">null</span>, newStartVNode, container, oldStartVNode.<span class="property">el</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldEndIdx &lt; oldStartIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 添加新节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, newChildren[i], container, oldStartVNode.<span class="property">el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndIdx &lt; newStartIdx &amp;&amp; oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 移除操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(oldChildren[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>响应系统 - 实现</title>
    <url>/effect-system-1/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第四章 - 响应系统的作用与实现 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<h2 id="一个完善的响应式系统">一个完善的响应式系统</h2>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储副作用函数的桶</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 对原始数据的代理</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">// 拦截读取操作</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="comment">// 返回属性值</span></span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置属性值</span></span><br><span class="line">    target[key] = newVal</span><br><span class="line">    <span class="comment">// 把副作用函数从桶里取出并执行</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    bucket.<span class="title function_">set</span>(target, (depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deps = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  <span class="keyword">if</span> (!deps) &#123;</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, (deps = <span class="keyword">new</span> <span class="title class_">Set</span>()))</span><br><span class="line">  &#125;</span><br><span class="line">  deps.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">  activeEffect.<span class="property">deps</span>.<span class="title function_">push</span>(deps)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">      <span class="comment">// 避免无限循环</span></span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> <span class="title function_">effectFn</span>())</span><br><span class="line">  <span class="comment">// effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn())</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个全局变量存储当前激活的 effect 函数</span></span><br><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"><span class="comment">// effect 栈  用于支持effect嵌套</span></span><br><span class="line"><span class="keyword">const</span> effectStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">cleanup</span>(effectFn)  <span class="comment">// 避免副作用函数遗留</span></span><br><span class="line">    <span class="comment">// 当调用 effect 注册副作用函数时，将副作用函数复制给 activeEffect</span></span><br><span class="line">    activeEffect = effectFn</span><br><span class="line">    <span class="comment">// 在调用副作用函数之前将当前副作用函数压栈</span></span><br><span class="line">    effectStack.<span class="title function_">push</span>(effectFn)</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">    <span class="comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并还原 activeEffect 为之前的值</span></span><br><span class="line">    effectStack.<span class="title function_">pop</span>()</span><br><span class="line">    activeEffect = effectStack[effectStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> cleanup 函数接收副作用函数作为参数,遍历副作用函数的effectRn.deps数组,该数组的每一项都是一个依赖集合,然后将该副作用函数从依赖集合中移除,最后重置effectFn.deps数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cleanup</span>(<span class="params">effectFn</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.<span class="property">deps</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> deps = effectFn.<span class="property">deps</span>[i]</span><br><span class="line">    deps.<span class="title function_">delete</span>(effectFn)</span><br><span class="line">  &#125;</span><br><span class="line">  effectFn.<span class="property">deps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="调度执行">调度执行</h2>
<div class="note primary"><p>可调度性:  当trigger动作触发副作用函数重新执行时,有能力决定副作用函数执行的时机/次数以及方式</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过在options 上指定 scheduler 调度器实现 调度器 scheduler是一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 options 挂在到 effectFn 上</span></span><br><span class="line">  effectFn.<span class="property">options</span> = options</span><br><span class="line">  <span class="comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span></span><br><span class="line">  effectFn.<span class="property">deps</span> = []</span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  <span class="title function_">effectFn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// ...略...</span></span><br><span class="line">  effectsToRun.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn.<span class="property">options</span>.<span class="property">scheduler</span>) &#123;</span><br><span class="line">      effectFn.<span class="property">options</span>.<span class="title function_">scheduler</span>(effectFn)    <span class="comment">// 把控制权交给用户</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算属性computed与lazy">计算属性computed与lazy</h2>
<p>上面实现的 effect 函数会立即执行传递给它的副作用函数. 但在有些场景下,我们并不希望它立即执行,而是希望它在需要的时候才执行,例如计算属性.这时我们可以通过在options中添加lazy属性来达到目的.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn, options = &#123;&#125;</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="title function_">effectFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title function_">fn</span>()  <span class="comment">// 将真正的副作用函数fn的执行结果保存到res中</span></span><br><span class="line">    <span class="comment">// ...略...</span></span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment">// 将其作为effectFn的返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...略...</span></span><br><span class="line">  <span class="comment">// 执行副作用函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">lazy</span>) &#123;</span><br><span class="line">    <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> effectFn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在手动执行时拿到副作用函数的返回值</span></span><br><span class="line"><span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(<span class="function">() =&gt;</span> obj.<span class="property">foo</span> + obj.<span class="property">bar</span>, &#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">effectFn</span>()</span><br></pre></td></tr></table></figure>
<p>有了上面的基数就可以实现计算属性了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(gerrer, &#123;<span class="attr">lazy</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="comment">// 当读取value时才执行effectFn</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>()&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">effectFn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述实现的计算属性只做到了懒计算, 还做不到对值进行缓存, 假如我们多次访问计算属性的valve值,会导致effectFn进行多次计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computed</span>(<span class="params">getter</span>) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   加入缓存, 在响应式数据发生变化时, 置缓存无效. 并触发计算属性响应. 即计算属性也是一个响应式数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">let</span> dirty = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(getter, &#123;</span><br><span class="line">    <span class="attr">lazy</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="title function_">scheduler</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// getter函数中所依赖的响应式数据变化时执行</span></span><br><span class="line">      <span class="keyword">if</span> (!dirty) &#123;</span><br><span class="line">        dirty = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">trigger</span>(obj, <span class="string">&#x27;value&#x27;</span>)  <span class="comment">// 触发响应</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty) &#123;</span><br><span class="line">        value = <span class="title function_">effectFn</span>()</span><br><span class="line">        dirty = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">track</span>(obj, <span class="string">&#x27;value&#x27;</span>)  <span class="comment">// 手动调用 track 函数进行追踪</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="watch的实现原理">watch的实现原理</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 递归的进行读取操作, 这样就可以追踪到任意属性的变化, 这里仅考虑value就是一个对象,不考虑数组等其他结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">value, seen = <span class="keyword">new</span> <span class="built_in">Set</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span> || value === <span class="literal">null</span> || seen.<span class="title function_">has</span>(value)) <span class="keyword">return</span></span><br><span class="line">  seen.<span class="title function_">add</span>(value)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="title function_">traverse</span>(value[k], seen)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> watch函数可以接收一个响应式数据或者一个getter函数.在getter函数内部,用户可以指定该watch依赖那些响应式数据,只有这些数据变化时,才会触发回调函数执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> getter</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    getter = source</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    getter = <span class="function">() =&gt;</span> <span class="title function_">traverse</span>(source)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    newValue = <span class="title function_">effectFn</span>()</span><br><span class="line">    <span class="title function_">cb</span>(oldValue, newValue)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectFn = <span class="title function_">effect</span>(</span><br><span class="line">    <span class="comment">// 执行 getter</span></span><br><span class="line">    <span class="function">() =&gt;</span> <span class="title function_">getter</span>(),</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">lazy</span>: <span class="literal">true</span>,  <span class="comment">// 利用 lazy 选项 获取新值与旧值</span></span><br><span class="line">      <span class="attr">scheduler</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.<span class="property">flush</span> === <span class="string">&#x27;post&#x27;</span>) &#123;  <span class="comment">// flush 选项指定回调执行时机</span></span><br><span class="line">          <span class="comment">// post 代表调度函数需要将副作用函数放到一个微任务队列中,并等待DOM更新结束后再执行</span></span><br><span class="line">          <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">          p.<span class="title function_">then</span>(job)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="title function_">job</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">immediate</span>) &#123;</span><br><span class="line">    <span class="title function_">job</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oldValue = <span class="title function_">effectFn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过期的副作用">过期的副作用</h2>
<p>思考</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finalData</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 发送请求并等待结果</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/path/to/request&#x27;</span>)</span><br><span class="line">  <span class="comment">// 将请求结果赋给data</span></span><br><span class="line">  finalData = res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>假设我们第一次修改obj对象的某个字段值,这会导致回调函数执行,同时发送了第一次请求A.随着时间的推移,在请求A的结果返回之前,我们对obj对象的某个字段值进行了第二次修改,这会导致发送第二次请求B.此时请求A和请求B都在进行中,不能够确定哪一个请求会先返回结果.如果请求B先于请求A返回结果,就会导致最终finalData中存储的是A请求的结果.</p>
<p>但由于请求B是后发送的,因此我们认为请求B返回的数据才是最新的,而请求A则应该被视为“过期”的.finalData存储的值应该是由请求B返回的结果,而非请求A返回的结果.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">watch</span>(<span class="params">source, cb, options = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// ...略...</span></span><br><span class="line">  <span class="keyword">let</span> oldValue, newValue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cleanup <span class="comment">// 存储用户注册的过期回调</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onInvalidate</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    cleanup = fn</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">job</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    newValue = <span class="title function_">effectFn</span>()</span><br><span class="line">    <span class="comment">// 在调用回调函数cb之前,先调用过期回调</span></span><br><span class="line">    <span class="keyword">if</span> (cleanup) &#123;</span><br><span class="line">      <span class="title function_">cleanup</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">cb</span>(oldValue, newValue, onInvalidate)</span><br><span class="line">    oldValue = newValue</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>稍微修改上面请求的代码即可得到正确的结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finallyData</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> obj.<span class="property">foo</span>, <span class="keyword">async</span> (newVal, oldVal, onInvalidate) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> valid = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 调用onInvalidate 函数注册一个过期回调</span></span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    valid = <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!valid) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  finallyData = res</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(finallyData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">foo</span>++</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  obj.<span class="property">foo</span>++</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/design-pattern-visitor/</url>
    <content><![CDATA[<p><strong>访问者模式</strong> 是一种行为设计模式，它能将算法与其作用的对象隔离开来</p>
<pre><code class="highlight mermaid">classDiagram
class Visitor &#123;
&lt;&lt;interface&gt;&gt;
+visit(e: ElementA)
+visit(e: ElementB)
&#125;
class ConcreteVisitors &#123;
...
+visit(e: ElementA)
+visit(e: ElementB)
&#125;
class Element &#123;
&lt;&lt;interface&gt;&gt;
+accept(v: Visitor)
&#125;
class ConcreteElementA &#123;
...
+featureA()
+accept(v: Visitor)
&#125;
class ConcreteElementB &#123;
...
+featureB()
+accept(v: Visitor)
&#125;
class Client

Visitor &lt;|.. ConcreteVisitors

Visitor ..&gt; ConcreteElementB

Visitor &lt;.. Element
Element &lt;|.. ConcreteElementA
Element &lt;|.. ConcreteElementB
Visitor ..&gt; ConcreteElementA
ConcreteVisitors &lt;.. Client
Element &lt;.. Client</code></pre>
<span id="more"></span>
<ul>
<li><strong>访问者（Visitor）</strong> 接口声明了一系列以对象结果的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的</li>
<li><strong>具体访问者（Concrete Visitor）</strong> 会为不同的具体元素类实现相同行为的几个不同版本</li>
<li><strong>元素（Element）</strong> 接口声明了一个方法来“接收”访问者。该方法必须有一个参数本声明为访问者接口类型</li>
<li><strong>具体元素（Concrete Element）</strong> 必须实现接收方法。该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法</li>
<li><strong>客户端（Client）</strong> 通常会作为集合或其他复杂对象（例如一个<a href="/design-pattern-composite/" title="组合模式">组合模式</a>树）的代表。客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互</li>
</ul>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitable</span> &#123;</span><br><span class="line">  <span class="title function_">accept</span>(<span class="attr">visitor</span>: <span class="title class_">Visitor</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Visitable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">accept</span>(<span class="attr">visitor</span>: <span class="title class_">Visitor</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    visitor.<span class="title function_">visitCircle</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Visitable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">width: <span class="built_in">number</span>, height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">accept</span>(<span class="attr">visitor</span>: <span class="title class_">Visitor</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    visitor.<span class="title function_">visitRectangle</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="title function_">visitCircle</span>(<span class="attr">circle</span>: <span class="title class_">Circle</span>): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">visitRectangle</span>(<span class="attr">rectangle</span>: <span class="title class_">Rectangle</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AreaVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">visitCircle</span>(<span class="attr">circle</span>: <span class="title class_">Circle</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> area = <span class="title class_">Math</span>.<span class="property">PI</span> * circle.<span class="property">radius</span> * circle.<span class="property">radius</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Area of circle with radius <span class="subst">$&#123;circle.radius&#125;</span>: <span class="subst">$&#123;area&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">visitRectangle</span>(<span class="attr">rectangle</span>: <span class="title class_">Rectangle</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> area = rectangle.<span class="property">width</span> * rectangle.<span class="property">height</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Area of rectangle with width <span class="subst">$&#123;rectangle.width&#125;</span> and height <span class="subst">$&#123;rectangle.height&#125;</span>: <span class="subst">$&#123;area&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PerimeterVisitor</span> <span class="keyword">implements</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">visitCircle</span>(<span class="attr">circle</span>: <span class="title class_">Circle</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> perimeter = <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span> * circle.<span class="property">radius</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Perimeter of circle with radius <span class="subst">$&#123;circle.radius&#125;</span>: <span class="subst">$&#123;perimeter&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">visitRectangle</span>(<span class="attr">rectangle</span>: <span class="title class_">Rectangle</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> perimeter = <span class="number">2</span> * (rectangle.<span class="property">width</span> + rectangle.<span class="property">height</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Perimeter of rectangle with width <span class="subst">$&#123;rectangle.width&#125;</span> and height <span class="subst">$&#123;rectangle.height&#125;</span>: <span class="subst">$&#123;perimeter&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">shapes</span>: <span class="title class_">Visitable</span>[] = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">7</span>)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">areaVisitor</span>: <span class="title class_">Visitor</span> = <span class="keyword">new</span> <span class="title class_">AreaVisitor</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="attr">perimeterVisitor</span>: <span class="title class_">Visitor</span> = <span class="keyword">new</span> <span class="title class_">PerimeterVisitor</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> shape <span class="keyword">of</span> shapes) &#123;</span><br><span class="line">  shape.<span class="title function_">accept</span>(areaVisitor);</span><br><span class="line">  shape.<span class="title function_">accept</span>(perimeterVisitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果你需要对一个复杂对象结构（例如对象树）中的所有元素执行某些操作，可使用访问者模式</li>
<li>可使用访问者模式来清理辅助行为的业务逻辑</li>
<li>当某个行为仅在类层次结构中的一些类中有意义，而在其他类中没有意义是，可使用该模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>开闭原则。你可以引入在不同类对象上执行的新行为，且无需对这些类做出修改</li>
<li>单一职责原则。可将同一行为的不同版本移到同一个类中</li>
<li>访问者对象可以在与各种对象交互时收集一些有用的信息。当你想要遍历一些复杂的对象结构（例如对象树），并在结构中的每个对象上应用访问者时，这些信息可能会有所帮助</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>每次在元素层次结构中添加或移除一个类时，你都要更新所有的访问者</li>
<li>在访问者同某个元素进行交互时，它们可能没有访问元素私有成员变量和方法的必要权限</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/visitor">Refactoringguru.cn 访问者模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>visitor</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/design-pattern-state/</url>
    <content><![CDATA[<p><strong>状态模式</strong> 是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。</p>
<pre><code class="highlight mermaid">classDiagram
class Context &#123;
-state
+Context(initialState)
+ChangeState(state)
+doThis()
+doThat()
&#125;
class State &#123;
&lt;&lt;interface&gt;&gt;
+doThis()
+doThat()
&#125;
class ConcreteStates &#123;
-context
+setContext(context)
+doThis()
+doThat()
&#125;
class Client

Context &lt;-- Client
Context &lt;-- ConcreteStates
Context o--&gt; State
State &lt;|.. ConcreteStates
Client ..&gt; ConcreteStates
</code></pre>
<span id="more"></span>
<ul>
<li>
<p><strong>上下文（Context）</strong> 保存了对于一个具体状态对象的引用，并会将所有与该状态相关的工作委派给它。上下文通过状态接口与状态对象交互，且会提供一个设置器用于传递新的状态对象</p>
</li>
<li>
<p><strong>状态（State）</strong> 接口会声明特定于状态的方法。这些方法应能被其他所有具体状态所理解，因为你不希望某些状态所拥有的方法永远不会被调用</p>
</li>
<li>
<p><strong>具体状态（Concrete States）</strong> 会自行实现特定于状态的方法。为了避免多个状态中包含相似代码，你可以提供一个封装有部分通用行为的中间抽象类<br>
状态对象可提供对于上下文对象的反向引用。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移</p>
</li>
<li>
<p>上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换</p>
</li>
</ul>
<h2 id="代码实现">代码实现</h2>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="title function_">play</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">pause</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadyState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">player</span>: <span class="title class_">AudioPlayer</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">player: AudioPlayer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span> = player;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">play</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Playing audio...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span>.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">PlayingState</span>(<span class="variable language_">this</span>.<span class="property">player</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pause</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cannot pause. Audio is not playing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cannot stop. Audio is not playing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PlayingState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">player</span>: <span class="title class_">AudioPlayer</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">player: AudioPlayer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span> = player;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">play</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cannot play. Audio is already playing.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pause</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Pausing audio...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span>.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">PausedState</span>(<span class="variable language_">this</span>.<span class="property">player</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Stopping audio...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span>.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(<span class="variable language_">this</span>.<span class="property">player</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PausedState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">player</span>: <span class="title class_">AudioPlayer</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">player: AudioPlayer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span> = player;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">play</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Resuming audio...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span>.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">PlayingState</span>(<span class="variable language_">this</span>.<span class="property">player</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pause</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Cannot pause. Audio is already paused.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Stopping audio...&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">player</span>.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">ReadyState</span>(<span class="variable language_">this</span>.<span class="property">player</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayer</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">state</span>: <span class="title class_">State</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="keyword">new</span> <span class="title class_">ReadyState</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">changeState</span>(<span class="attr">state</span>: <span class="title class_">State</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">play</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="title function_">play</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">pause</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="title function_">pause</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">stop</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="title function_">stop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage example</span></span><br><span class="line"><span class="keyword">const</span> player = <span class="keyword">new</span> <span class="title class_">AudioPlayer</span>();</span><br><span class="line"></span><br><span class="line">player.<span class="title function_">play</span>(); <span class="comment">// Output: &quot;Playing audio...&quot;</span></span><br><span class="line">player.<span class="title function_">pause</span>(); <span class="comment">// Output: &quot;Pausing audio...&quot;</span></span><br><span class="line">player.<span class="title function_">play</span>(); <span class="comment">// Output: &quot;Resuming audio...&quot;</span></span><br><span class="line">player.<span class="title function_">stop</span>(); <span class="comment">// Output: &quot;Stopping audio...&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="适用场景">适用场景</h2>
<ul>
<li>如果对象需要根据自身当前状态进行不同行为，同时状态的数量非常多且与状态相关的代码会频繁变更的话，可使用状态模式</li>
<li>如果某个类需要根据成员变量的当前值改变自身行为，从而需要大量的条件语句时，可使用该模式</li>
<li>当相似状态和基于条件的状态机转换中存在许多重复代码时，可使用状态模式</li>
</ul>
<h2 id="优点">优点</h2>
<ul>
<li>单一职责原则。将于特定状态相关的代码放在单独的类中</li>
<li>开闭原则。无需修改已有状态类和上下文就能引入新状态</li>
<li>通过消除臃肿的状态机条件语句简化上下文代码</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>如果状态机只有很少的几个状态，或者很少发生改变，那没应用该模式可能会显得小题大作</li>
</ul>
<h2 id="与其他模式的区别">与其他模式的区别</h2>
<ul>
<li><strong><a href="/design-pattern-state/" title="状态模式">状态模式</a></strong> 可被视为 <strong><a href="/design-pattern-strategy/" title="策略模式">策略模式</a></strong> 的拓展。两者都基于组合机制：它们都通过将部分工作委派给“帮手”对象量改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://refactoringguru.cn/design-patterns/state">Refactoringguru.cn 状态模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为模式</category>
      </categories>
      <tags>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>响应系统 - 非原始值 - 数组</title>
    <url>/effect-system-2-2/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第五章 - 非原始值的响应式方案 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<h2 id="代理数组">代理数组</h2>
<p>数组属于异质对象, 其<mark class="label info">[[DefineOwnProperty]]</mark>内部方法与常规对象不同. 大部分用来代理常规对象的代码对于数组也是生效的. 但数组的一些操作需要特别对待</p>
<span id="more"></span>
<h3 id="数组的索引与length">数组的索引与length</h3>
<ul>
<li>通过索引设置大于当前数组长度的值时,会影响<mark class="label primary">length</mark> , 与属性 <mark class="label primary">length</mark>相关的副作用函数需要重新执行</li>
<li>反过来, 当修改<mark class="label primary">length</mark>的值时, 索引值大于或等于新的<mark class="label primary">length</mark>属性值的元素需要触发响应</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isReadonly) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`属性 <span class="subst">$&#123;key&#125;</span> 是只读的`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> oldVal = target[key]</span><br><span class="line">      <span class="keyword">const</span> type = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)</span><br><span class="line">        ? <span class="title class_">Number</span>(key) &lt; target.<span class="property">length</span> ? <span class="string">&#x27;SET&#x27;</span> : <span class="string">&#x27;ADD&#x27;</span>	<span class="comment">// 区分设置大于当前数组长度的值的操作</span></span><br><span class="line">        : <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? <span class="string">&#x27;SET&#x27;</span> : <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver)</span><br><span class="line">      <span class="keyword">if</span> (target === receiver.<span class="property">raw</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;</span><br><span class="line">          <span class="comment">// 增加第四个参数, 即触发响应的新值</span></span><br><span class="line">          <span class="title function_">trigger</span>(target, key, type, newVal)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type, newVal</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 当操作类型为 ADD 并且目标类型是数组时,应该取出并执行那些与 length 属性相关联的副作用函数</span></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;ADD&#x27;</span> &amp;&amp; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">const</span> lengthEffects = depsMap.<span class="title function_">get</span>(<span class="string">&#x27;length&#x27;</span>)</span><br><span class="line">    lengthEffects &amp;&amp; lengthEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果操作目标是数组, 并且修改了数组的 length 属性</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; key === <span class="string">&#x27;length&#x27;</span>) &#123;</span><br><span class="line">    depsMap.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effects, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (key &gt;= newVal) &#123;</span><br><span class="line">        effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">            effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历数组">遍历数组</h3>
<h4 id="for…in">for…in</h4>
<p>尽管<mark class="label info">for...in</mark>一般不用来(也不建议)遍历数组, 但数组也是对象, 在语法上是行得通的.</p>
<p>当数组的 <mark class="label info">length</mark>变化时, 我们需要去触发响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ITERATE_KEY</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">      <span class="title function_">track</span>(target, <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? <span class="string">&#x27;length&#x27;</span> : <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for…of">for…of</h4>
<p>当使用 <mark class="label info">for...of</mark>遍历时, 会去读取<mark class="label info">length</mark>属性, 我们不需要增加任何代码就可以使其正确地工作.但无论是使用<mark class="label info">for...of</mark>循环,还是调用<mark class="label info">values</mark>方法,它们都会读取数组的 <mark class="label primary">Symbol.iterator</mark> 属性.该属性是一个<mark class="label info">symbol</mark>值,为了避免发生意外的错误,以及性能上的考虑, 不应该在副作用函数与 <mark class="label primary">Symbol.iterator</mark> 这类<mark class="label info">symbol</mark>值之间建立联系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 添加判断, 如果key的类型是 symbol, 则不进行追踪</span></span><br><span class="line">      <span class="keyword">if</span> (!isReadonly &amp;&amp; <span class="keyword">typeof</span> key !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">track</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组的查找方法">数组的查找方法</h3>
<p>由于在 <a href="/effect-system-2-1#%E6%B5%85%E5%93%8D%E5%BA%94%E4%B8%8E%E6%B7%B1%E5%93%8D%E5%BA%94">浅响应与深响应</a>中我们做了深响应, 即通过代理对象来访问元素值时,如果值仍然是可以被代理的,那么得到的值就是新的代理对象而非原始对象.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于查找方法<mark class="label info">includes/indexOf/lastIndexOf</mark>在ECMA规范中的实现需要读取索引值并与查找值对比, 返回代理对象无法查找到正确值,解决如下问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([obj])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(arr[<span class="number">0</span>])) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(obj)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>第一个问题,需要缓存代理对象, 优先通过原始对象寻找之前创建的代理对象.</p>
<p>第二个问题,需要重写查找方法<mark class="label info">includes/indexOf/lastIndexOf</mark>解决</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Map实例, 存储原始对象到代理对象的映射</span></span><br><span class="line"><span class="keyword">const</span> reactiveMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// 优先通过原始对象obj 寻找之前创建的代理对象, 如果找到了, 直接返回已有的代理对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="title function_">createReactive</span>(obj)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> existionProxy = reactiveMap.<span class="title function_">get</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (existionProxy) <span class="keyword">return</span> existionProxy</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 否则, 创建新的代理对象</span></span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="title function_">creatReactive</span>(obj)</span><br><span class="line">  <span class="comment">// 存储到 Map 中, 从而避免重复创建</span></span><br><span class="line">  reactiveMap.<span class="title function_">set</span>(obj, proxy)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayInstrumentations = &#123;&#125;</span><br><span class="line"></span><br><span class="line">;[<span class="string">&#x27;includes&#x27;</span>, <span class="string">&#x27;indexOf&#x27;</span>, <span class="string">&#x27;lastIndexOf&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originMethod = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method]</span><br><span class="line">  arrayInstrumentations[method] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// this 是代理对象，先在代理对象中查找，将结果存储到 res 中</span></span><br><span class="line">    <span class="keyword">let</span> res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res === <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="comment">// res 为 false 说明没找到，在通过 this.raw 拿到原始数组，再去原始数组中查找，并更新 res 值</span></span><br><span class="line">      res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">raw</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最终的结果</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// 拦截读取操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 注意这里是在设置追踪之前返回的, 也就是说实际查找方法 includes/indexOf/lastIndexOf 的响应追踪值并不是自身, 而是由于查找方法会读取每一个索引值, 会把副作用函数与没一个索引值绑定</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; arrayInstrumentations.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(arrayInstrumentations, key, receiver)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span> (!isReadonly &amp;&amp; <span class="keyword">typeof</span> key !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">track</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>注意</strong></p>
<p>上面<mark class="label danger">createReactive</mark>函数是在设置追踪之前返回的, 也就是说实际查找方法 includes/indexOf/lastIndexOf 的响应追踪值并不是自身, 而是由于查找方法会读取每一个索引值, 会把副作用函数与每一个索引值绑定</p>
</div>
<h3 id="隐式修改数组长度的原型方法">隐式修改数组长度的原型方法</h3>
<p>对于 <strong>push, pop, shift, unshift, splice</strong> 这些隐式修改数组长度的原型方法,也需要进行重写. 解决形如如下问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">reactive</span>([])</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> arr.<span class="title function_">push</span>(<span class="number">1</span>))</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> arr.<span class="title function_">push</span>(<span class="number">1</span>))	<span class="comment">// 栈溢出 Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>
<p>第二个副作用函数执行时,会隐式改变数组的<mark class="label info">length</mark>属性, 触发第一个副作用函数执行, 第一个副作用函数执行又会触发第二个函数,如此反复</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shouldTrack = <span class="literal">true</span></span><br><span class="line">;[<span class="string">&#x27;push&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originMethod = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method]</span><br><span class="line">  arrayInstrumentations[method] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    shouldTrack = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> res = originMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    shouldTrack = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">track</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 当禁止追踪时, 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!activeEffect || !shouldTrack) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>响应系统 - 非原始值 - 常规对象</title>
    <url>/effect-system-2-1/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第五章 - 非原始值的响应式方案 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<h2 id="Proxy-Reflect">Proxy &amp; Reflect</h2>
<div class="note info"><p><strong>Javascript - Proxy</strong></p>
<p><a href="/Javascript-Proxy-1/">代理基础</a> /<a href="/Javascript-Proxy-2/">捕获器与反射</a>/ <a href="/Javascript-Proxy-3/">代理模式</a></p>
</div>
<p>代理指的是对一个对象<mark class="label primary">基本语义</mark>的代理。它允许我们<mark class="label primary">拦截</mark>并<mark class="label primary">重新定义</mark>对一个对象的基本操作</p>
<span id="more"></span>
<p><strong>基本操作:</strong>  读取、设置属性值、调用函数</p>
<p><strong>复合操作:</strong> 非基本操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">bar</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line">    <span class="comment">// 使用Reflect.get 返回读取到属性值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//  ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">bar</span>))</span><br><span class="line"></span><br><span class="line">p.<span class="property">foo</span>++</span><br></pre></td></tr></table></figure>
<p>注意上面使用<mark class="label primary">Reflect</mark> 以达到收集 <mark class="label danger">obj.foo</mark>依赖. 直接使用<mark class="label info">target[key]</mark>无法收集</p>
<h2 id="Javascript对象及Proxy的工作原理">Javascript对象及Proxy的工作原理</h2>
<p><strong><mark class="label primary">常规对象</mark></strong>:</p>
<ul>
<li>对于 <em><mark class="label info">ECMA-262. 6.1.7.3 Invariants of the Essential Internal Methods</mark></em> 列出的除 [[Call]]、[[Construct]]外的内部方法,必须使用ECMA规范 10.1.x 节给出的定义实现</li>
<li>对于内部方法[[Call]], 必须使用ECMA规范 10.2.1 节给出的定义实现</li>
<li>对于内部方法[[Construct]], 必须使用ECMA规范 10.2.2 节给出的定义实现</li>
</ul>
<p><strong><mark class="label primary">异质对象</mark></strong>: 非常规对象</p>
<div class="note info"><p><strong>ECMA - 262</strong></p>
<p><a href="https://www.ecma-international.org/wp-content/uploads/ECMA-262_12th_edition_june_2021.pdf">12th edition, June 2021</a></p>
</div>
<p>创建代理对象时指定的拦截函数,实际上是用来自定义代理对象本身的内部方法和行为的,而不是用来指定被代理对象的内部方法和行为的</p>
<p>Proxy对象部署的所有内部方法以及用来自定义内部方法和行为的拦截函数名字 <em><mark class="label info">ECMA-262. 10.5 Proxy Object Internal Methods and Internal Slots</mark></em></p>
<table>
<thead>
<tr>
<th>Internal Method</th>
<th>Handler Method</th>
</tr>
</thead>
<tbody>
<tr>
<td>[[GetPrototypeOf]]</td>
<td><strong>getPrototypeOf</strong></td>
</tr>
<tr>
<td>[[SetPrototypeOf]]</td>
<td><strong>setPrototypeOf</strong></td>
</tr>
<tr>
<td>[[IsExtensible]]</td>
<td><strong>isExtensible</strong></td>
</tr>
<tr>
<td>[[PreventExtensions]]</td>
<td><strong>preventExtensions</strong></td>
</tr>
<tr>
<td>[[GetOwnProperty]]</td>
<td><strong>getOwnPropertyDescriptor</strong></td>
</tr>
<tr>
<td>[[DefineOwnProperty]]</td>
<td><strong>defineProperty</strong></td>
</tr>
<tr>
<td>[[HasProperty]]</td>
<td><strong>has</strong></td>
</tr>
<tr>
<td>[[Get]]</td>
<td><strong>get</strong></td>
</tr>
<tr>
<td>[[Set]]</td>
<td><strong>set</strong></td>
</tr>
<tr>
<td>[[Delete]]</td>
<td><strong>deleteProperty</strong></td>
</tr>
<tr>
<td>[[OwnPropertyKeys]]</td>
<td><strong>ownKeys</strong></td>
</tr>
<tr>
<td>[[Call]]</td>
<td><strong>apply</strong></td>
</tr>
<tr>
<td>[[Construct]]</td>
<td><strong>construct</strong></td>
</tr>
</tbody>
</table>
<h2 id="如何代理Object">如何代理Object</h2>
<p>这里直接贴出代理代码, 至于原因请阅读原文或者ECMA-262</p>
<h3 id="in">in</h3>
<mark class="label primary">[[HasProperty]]</mark>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, key</span>)&#123;</span><br><span class="line">    <span class="title function_">tarck</span>(target, key)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">has</span>(target, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="for-…-in">for … in</h3>
<mark class="label primary">ownKeys</mark>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ITERATE_KEY</span> = <span class="title class_">Symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">ownKeys</span>(<span class="params">target</span>)&#123;</span><br><span class="line">    <span class="comment">// 将副作用函数与 ITERATE_KEY 关联</span></span><br><span class="line">    <span class="title function_">tarck</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当为对象添加新属性时,会对<mark class="label primary">for...in</mark>循环产生影响,所以需要触发与<mark class="label primary">ITERATE_KEY</mark>相关联的副作用函数重新执行.</p>
<p>由于添加新属性与修改已有的属性值的基于语义都是<mark class="label info">[[Set]]</mark>, 为避免修改已有属性值时触发副作用.需要区分这两种操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">ITERATE_KEY</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 拦截设置操作</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? <span class="string">&#x27;SET&#x27;</span> : <span class="string">&#x27;ADD&#x27;</span> <span class="comment">// 如果属性不存在，则说明是在添加新的属性，否则是设置已存在的属性</span></span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver) <span class="comment">// 设置属性值</span></span><br><span class="line">    <span class="title function_">trigger</span>(target, key, type) <span class="comment">// 将 type 作为第三个参数传递给 trigger 函数</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> depsMap = bucket.<span class="title function_">get</span>(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">const</span> effects = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> iterateEffects = depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;ADD&#x27;</span>) &#123;</span><br><span class="line">    iterateEffects &amp;&amp; iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delete">delete</h3>
<mark class="label primary">deleteProperty</mark>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> hadKey = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key)</span><br><span class="line">    <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; hadKey) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, <span class="string">&#x27;DELETE&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<mark class="label primary">delete</mark>同样影响<mark class="label info">for...in</mark>循环
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;ADD&#x27;</span> || type === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">    iterateEffects &amp;&amp; iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合理地触发响应">合理地触发响应</h2>
<p>考虑</p>
<ul>
<li>多次设置相同的值</li>
<li>原型链上响应式对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; <span class="comment">/** ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">foo</span>))</span><br><span class="line">p.<span class="property">foo</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建响应式数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123; <span class="comment">/** ... */</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proto = &#123; <span class="attr">bar</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">const</span> child = <span class="title function_">reactive</span>(_obj)</span><br><span class="line"><span class="keyword">const</span> parent = <span class="title function_">reactive</span>(proto)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(child, parent)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(child.<span class="property">bar</span>))</span><br><span class="line"></span><br><span class="line">child.<span class="property">bar</span> = <span class="number">2</span> <span class="comment">// 会导致副作用函数执行两次</span></span><br></pre></td></tr></table></figure>
<p>对于设置相同值,只需要判断新值与旧值即可.  原型链上的响应式值则需要判断 <mark class="label info">receiver</mark>是不是<mark class="label info">target</mark>的代理对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) &#123;	</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldVal = target[key]	<span class="comment">// 对比新旧值</span></span><br><span class="line">      <span class="keyword">const</span> type = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(target, key) ? <span class="string">&#x27;SET&#x27;</span> : <span class="string">&#x27;ADD&#x27;</span></span><br><span class="line">      <span class="comment">// 设置属性值</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newVal, receiver)</span><br><span class="line">      <span class="keyword">if</span> (target === receiver.<span class="property">raw</span>) &#123;	<span class="comment">// 处理原型链上的响应式数据</span></span><br><span class="line">        <span class="keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123; <span class="comment">// 处理NaN</span></span><br><span class="line">          <span class="title function_">trigger</span>(target, key, type)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浅响应与深响应">浅响应与深响应</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowReactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// 拦截读取操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span></span><br><span class="line">      <span class="title function_">track</span>(target, key)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isShallow) &#123; 	<span class="comment">// 浅响应</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reactive</span>(res)	<span class="comment">// 深响应</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="只读与浅只读">只读与浅只读</h2>
<p>如果一个数据是只读的,那就意味着任何方式都无法修改它.因此,没有必要为只读数据建立响应联系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readonly</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowReadonly</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createReactive</span>(obj, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="comment">// 拦截读取操作</span></span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 非只读的时候才需要建立响应联系</span></span><br><span class="line">      <span class="keyword">if</span> (!isReadonly) &#123;</span><br><span class="line">        <span class="title function_">track</span>(target, key)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isShallow) &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 深只读/响应</span></span><br><span class="line">        <span class="keyword">return</span> isReadonly ? <span class="title function_">readonly</span>(res) : <span class="title function_">reactive</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置操作</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newVal, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isReadonly) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`属性 <span class="subst">$&#123;key&#125;</span> 是只读的`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isReadonly) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`属性 <span class="subst">$&#123;key&#125;</span> 是只读的`</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>响应系统 - 非原始值 - Set&amp;Map</title>
    <url>/effect-system-2-3/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第五章 - 非原始值的响应式方案 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<h2 id="代理-Set-和-Map">代理 Set 和 Map</h2>
<p>Set 和 Map 的代理思路与代理数组是一样的, 需要注意的是其<mark class="label info">size</mark>是一个访问器属性, 访问器内部检查了<mark class="label danger">[[SetData]]</mark>内部槽, <mark class="label info">Reflect.get</mark>中<mark class="label info">this</mark>的值要指向原始对象而非代理对象,其余方法也是一样</p>
<span id="more"></span>
<h3 id="建立响应联系">建立响应联系</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableInstrumentations = &#123;</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">    <span class="keyword">const</span> hadKey = target.<span class="title function_">has</span>(key)</span><br><span class="line">    <span class="keyword">const</span> res = target.<span class="title function_">add</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (!hadKey) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, <span class="string">&#x27;ADD&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">    <span class="keyword">const</span> hadKey = target.<span class="title function_">has</span>(key)</span><br><span class="line">    <span class="keyword">const</span> res = target.<span class="title function_">delete</span>(key)</span><br><span class="line">    <span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, <span class="string">&#x27;DELETE&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">    <span class="keyword">const</span> had = target.<span class="title function_">has</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">track</span>(target, key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (had) &#123;</span><br><span class="line">      <span class="keyword">const</span> res = target.<span class="title function_">get</span>(key)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">    <span class="keyword">const</span> had = target.<span class="title function_">has</span>(key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldValue = target.<span class="title function_">get</span>(key)</span><br><span class="line">    <span class="keyword">const</span> rawValue = value.<span class="property">raw</span> || value</span><br><span class="line">    target.<span class="title function_">set</span>(key, rawValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!had) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, <span class="string">&#x27;ADD&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) &#123;</span><br><span class="line">      <span class="title function_">trigger</span>(target, key, <span class="string">&#x27;SET&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createReactive</span>(<span class="params">obj, isShallow = <span class="literal">false</span>, isReadonly = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;raw&#x27;</span>) <span class="keyword">return</span> target</span><br><span class="line">      <span class="keyword">if</span> (key === <span class="string">&#x27;size&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">track</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, target)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> mutableInstrumentations[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="避免污染原始数据">避免污染原始数据</h3>
<p><strong>响应式数据设置到原始数据上的行为称为数据污染</strong>, 形如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title function_">reactive</span>(m)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">set</span>(<span class="string">&#x27;p2&#x27;</span>, p2)</span><br><span class="line"></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">get</span>(<span class="string">&#x27;p2&#x27;</span>).<span class="property">size</span>))</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;p2&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>注意 <a href="#%E5%BB%BA%E7%AB%8B%E5%93%8D%E5%BA%94%E8%81%94%E7%B3%BB">建立响应联系</a>中<mark class="label danger">mutableInstrumentations.set</mark>, 在  target.set 函数设置值之前对值进行检查: 只要发现即将要设置的值时响应式数据,那么就通过raw属性获取原始数据,再把原始数据设置到 target 上</p>
<div class="note primary"><p>除了set方法需要避免污染原始数据外, Set 类型的 add 方法, 普通对象的写值操作, 还有为数组添加元素的方法等, 都需要做类似的处理</p>
</div>
<h3 id="处理forEach">处理forEach</h3>
<p>由于上述 访问 <mark class="label danger">size</mark>属性时, 是通过原始数据进行操作的, 会导致在forEach 回调函数中参数不是响应式的问题, 需要手动处理, 并且对比 <mark class="label info">for...in</mark>操作, Map类型的forEach 需要在值更新时触发响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableInstrumentations = &#123;</span><br><span class="line">  <span class="title function_">forEach</span>(<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">wrap</span> = (<span class="params">val</span>) =&gt; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(val) : val</span><br><span class="line">    <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">    <span class="title function_">track</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v, k</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 手动调用callback, 实现深响应</span></span><br><span class="line">      callback.<span class="title function_">call</span>(thisArg, <span class="title function_">wrap</span>(v), <span class="title function_">wrap</span>(k), <span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type, newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> effectsToRun = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">  effects &amp;&amp; effects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">      effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    type === <span class="string">&#x27;ADD&#x27;</span> ||</span><br><span class="line">    type === <span class="string">&#x27;DELETE&#x27;</span> ||</span><br><span class="line">    (</span><br><span class="line">      type === <span class="string">&#x27;SET&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target) === <span class="string">&#x27;[object Map]&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> iterateEffects = depsMap.<span class="title function_">get</span>(<span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line">    iterateEffects &amp;&amp; iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器方法">迭代器方法</h3>
<p>Map 类型的迭代器方法, 包括<mark class="label info">[Symbol.iterator]/entries/keys/values</mark>, 与上述<mark class="label info">forEach</mark>一样, 迭代器方法需要将迭代产生的值包装成响应式数据.</p>
<div class="note info"><p>可迭代协议指的是一个对象实现了<mark class="label info">Symbol.iterator</mark></p>
<p>迭代器协议指的是一个对象实现了<mark class="label info">next</mark>方法</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mutableInstrumentations = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: iterationMethod,</span><br><span class="line">  <span class="attr">entries</span>: iterationMethod,</span><br><span class="line">  <span class="attr">keys</span>: keysIterationMethod,</span><br><span class="line">  <span class="attr">values</span>: valuesIterationMethod,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">iterationMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原始数据对象 target</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">  <span class="comment">// 获取到原始迭代器方法</span></span><br><span class="line">  <span class="keyword">const</span> itr = target[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">wrap</span> = (<span class="params">val</span>) =&gt; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(val) : val</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 track 函数建立响应联系</span></span><br><span class="line">  <span class="title function_">track</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = itr.<span class="title function_">next</span>()</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: value ? [<span class="title function_">wrap</span>(value[<span class="number">0</span>]), <span class="title function_">wrap</span>(value[<span class="number">1</span>])] : value,</span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="values-与-keys-方法">values 与 keys 方法</h3>
<p>values 方法的实现与entries 方法类似, 不同的是, 当使用 for…of 迭代values是, 得到的仅仅是Map数据的值, 而非键值对</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">valuesIterationMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原始数据对象 target</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">  <span class="comment">// 获取到原始迭代器方法</span></span><br><span class="line">  <span class="keyword">const</span> itr = target.<span class="title function_">values</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">wrap</span> = (<span class="params">val</span>) =&gt; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(val) : val</span><br><span class="line"></span><br><span class="line">  <span class="title function_">track</span>(target, <span class="variable constant_">ITERATE_KEY</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = itr.<span class="title function_">next</span>()</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="title function_">wrap</span>(value),	<span class="comment">// 只有值</span></span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>keys 方法与values 方法非常类似, 不同点在于, 前者处理的是键而非值.</p>
<p>另外对于 values 或 entries 来说 Map 类型的数据 即使操作类型为 SET, 也会触发那些与 ITERATE_KEY 相关联的副作用函数, 但这对keys 来说是没有必要的, keys 方法 只关心Map 类型数据的键的变化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAP_KEY_ITERATE_KEY</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">keysIterationMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取原始数据对象 target</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="variable language_">this</span>.<span class="property">raw</span></span><br><span class="line">  <span class="comment">// 获取到原始迭代器方法</span></span><br><span class="line">  <span class="keyword">const</span> itr = target.<span class="title function_">keys</span>()	<span class="comment">// 获取键值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">wrap</span> = (<span class="params">val</span>) =&gt; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(val) : val</span><br><span class="line"></span><br><span class="line">  <span class="title function_">track</span>(target, <span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将其返回</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = itr.<span class="title function_">next</span>()</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="title function_">wrap</span>(value),</span><br><span class="line">        done</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trigger</span>(<span class="params">target, key, type, newVal</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ((</span><br><span class="line">    type === <span class="string">&#x27;ADD&#x27;</span> || type === <span class="string">&#x27;DELETE&#x27;</span>) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target) === <span class="string">&#x27;[object Map]&#x27;</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 执行 Map 类型 keys 相关联的副作用函数</span></span><br><span class="line">    <span class="keyword">const</span> iterateEffects = depsMap.<span class="title function_">get</span>(<span class="variable constant_">MAP_KEY_ITERATE_KEY</span>)</span><br><span class="line">    iterateEffects &amp;&amp; iterateEffects.<span class="title function_">forEach</span>(<span class="function"><span class="params">effectFn</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (effectFn !== activeEffect) &#123;</span><br><span class="line">        effectsToRun.<span class="title function_">add</span>(effectFn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>响应系统 - 原始值</title>
    <url>/effect-system-3/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第六章 - 原始值的响应式方案 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<p>原始值指的是Boolean, Number, BigInt, String, Symbol, undefined 和 null 等类型的值.在 Javascript 中, 原始值是按值传递的,而非按引用传递. 形参和实参之间没有引用关系, 它们是两个完全独立的值, 对形参的修改不会影响实参. 另外, Javascript 中的Proxy 无法提供对原始值的代理, 因此想要将原始值变成响应式数据, 就必须对其做一层包裹, 也就是<mark class="label info">ref</mark></p>
<span id="more"></span>
<h2 id="引入ref的概念">引入ref的概念</h2>
<p>由于 Proxy 的代理目标必须是非原始值, 没有任何手段拦截对原始值的操作.</p>
<p>对于这个问题,需要使用一个非原始值去“包裹”原始值. 并且需要区分原始值的包裹对象与非原始值的响应式对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">    <span class="attr">value</span>: val</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义不可枚举且不可写的属性, 用于判断数据是否为 ref</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(wrapper, <span class="string">&#x27;__v_isRef&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reactive</span>(wrapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isRef</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val.<span class="property">__v_isRef</span> === <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="响应丢失问题">响应丢失问题</h2>
<p>对响应式数据使用<mark class="label danger">...</mark>展开时, 会导致响应丢失. 可以使用类似 <mark class="label info">ref</mark>的结构,通过访问器属性读取相应的响应式数据, 以触发响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toRefs</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ret = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    ret[key] = <span class="title function_">toRef</span>(obj, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">toRef</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> obj[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      obj[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(wrapper, <span class="string">&#x27;__v_isRef&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动脱ref">自动脱ref</h2>
<p>上述<mark class="label info">toRefs</mark>函数的确解决了响应丢失问题, 但同时也带来了新的问题. <em>必须使用value访问属性值</em>, 这会增加用户的心智负担. 这就提供需要自动脱ref 的能力.</p>
<p>所谓自动脱 ref , 指的是属性的访问行为, 即如果读取的属性是一个 ref, 则直接将该 ref 对应的value值返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxyRefs</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">      <span class="keyword">return</span> value.<span class="property">__v_isRef</span> ? value.<span class="property">value</span> : value	<span class="comment">// 判断 __v_isRef</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = target[key]</span><br><span class="line">      <span class="keyword">if</span> (value.<span class="property">__v_isRef</span>) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newValue</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, receiver)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<blockquote>
<p>天命之谓信，率性之谓道，修道之谓教。道也者，不可须臾离也，可离非道也。是故君子戒慎乎其所不睹，恐惧乎其所不问。莫见乎隐，莫显乎微，故君子慎其独也。喜怒哀乐之未发，谓之中；发而皆中节，谓之和。中也者，天下之大本也；和也者，天下之达道也。致中和，天地位焉，万物育焉。</p>
<p>——《中庸》</p>
</blockquote>
<span id="more"></span>
<h3 id="建站">建站</h3>
<p>很早之前就想写一个自己的博客，但直到 2020/11/18 之前都没有动手去写。最主要的原因是觉得自己太菜了，没什么好写的。就一点皮毛也敢写博客?现在动手建站，是因为我觉得其实博客是写给自己看的，多年后回头看看这第一篇 Hello World。不知会作何感想？</p>
<p>毕业到现在(2020/11/24)算是入行四个月快五个月了，因为工作性质的原因平时也不用写什么难的代码。但就是这些简单的需求，在写的时候都会忘记该如何实现。加上平时记东西基本都是 TXT 记录的，找起来很是麻烦。还有就是虽然是搞实施的，但我一直觉得我是一个程序猿 :)，能有个自己的站点可以按照想法随意改动对我来说是非常舒服的！！！</p>
<h3 id="更新">更新</h3>
<h4 id="更文">更文</h4>
<ul>
<li>
<p><s>设想是每月除去水文至少两篇是对自己来说是干货的文章，希望能坚持下去！</s></p>
</li>
<li>
<p>两篇不行好吧，四篇勉勉强强。内容长的拆开八篇好吧 🍖🍖🍖</p>
</li>
</ul>
<h4 id="功能">功能</h4>
<ul>
<li><s>没计划，有空去别人的 Blog 看看有啥功能好用就抄过来 :)</s></li>
<li>想把 Lab 页面改造为 vue 页面玩玩 🍗🍗🍗</li>
</ul>
<h4 id="样式">样式</h4>
<ul>
<li><s>mokusei 原主题凑合着先吧！有空再去改改。但这不重要，又不是不能用。淦！</s></li>
<li>Sakura</li>
</ul>
<h4 id="More">More</h4>
<ul>
<li>
<div style="text-decoration: line-through;">梦里啥都有。</div>
</li>
</ul>
]]></content>
      <categories>
        <category>随想</category>
      </categories>
      <tags>
        <tag>chat</tag>
      </tags>
  </entry>
  <entry>
    <title>一个基于Node.js的简易局域网图床</title>
    <url>/nodejs-picbed/</url>
    <content><![CDATA[<p>最近有需要向别人分享markdown文档的需求,然而文档上面插入了一些本地图片,这些图片又不好上传到外网图床上.导致在非本机环境中打开文档,均无法查看图片.</p>
<p>既然无法使用外网图床,在本机搭建一个局域网图床不就行了?</p>
<p>在Github上面找了一圈只找到了一个Python+Flask的实现.看了一下它的代码,非常简单,核心就是一个web服务.<a href="https://github.com/fslongjin/My-Easy-Pic-Bed">Github. My-Easy-Pic-Bed</a></p>
<p>我寻思着这也没必要上Flask,只要能起web服务的就行,而且我并不需要网页上传入口,通过<mark class="label primary">curl</mark>命令行上传图片就行,这下<mark class="label primary">html</mark>页面也省了</p>
<span id="more"></span>
<h2 id="代码实现">代码实现</h2>
<p>利用<mark class="label primary">http.createServer()</mark>创建web服务,我们只需要处理图片的上传(<mark class="label primary">post</mark>)和下载(<mark class="label primary">get</mark>)就行.</p>
<div class="note info"><p>环境: node -v12.21.0</p>
<p>代码已上传至GitHub，clone下来<mark class="label primary">npm run start</mark>即可食用<a href="https://github.com/Kinsiy/simple-pic-bed/tree/main">Github. Kinsiy.Simple-pic-bed</a></p>
</div>
<h3 id="Post">Post</h3>
<p>文件上传核心就一件事,将文件以唯一文件名保存到指定文件夹.代码也很简单,使用<mark class="label primary">formidable</mark>库获取请求体中的文件,使用<mark class="label primary">uuid</mark>库生成唯一文件名,保存文件,并返回路径即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (req.<span class="property">url</span> === <span class="string">&quot;/upload&quot;</span> &amp;&amp; req.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&quot;post&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// parse a file upload</span></span><br><span class="line">  <span class="keyword">const</span> form = <span class="title function_">formidable</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  form.<span class="title function_">parse</span>(req, <span class="function">(<span class="params">err, fields, files</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      res.<span class="property">statusCode</span> = err.<span class="property">httpCode</span> || <span class="number">400</span>;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="title class_">String</span>(err));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> file = files.<span class="property">file</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checks if the file is valid</span></span><br><span class="line">    <span class="keyword">const</span> isValid = <span class="title function_">isFileValid</span>(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rename file be unique</span></span><br><span class="line">    <span class="keyword">const</span> fileName = file.<span class="property">originalFilename</span>.<span class="title function_">replace</span>(<span class="regexp">/^.*(?=\.)/</span>, <span class="title function_">uuidv4</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValid) &#123;</span><br><span class="line">      <span class="comment">// throes error if file isn&#x27;t valid</span></span><br><span class="line">      res.<span class="property">statusCode</span> = <span class="number">400</span>;</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;The file type is not a valid type&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> httpCode, result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// store file</span></span><br><span class="line">      fs.<span class="title function_">copyFile</span>(file.<span class="property">filepath</span>, path.<span class="title function_">join</span>(uploadFolder, fileName), <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(err);</span><br><span class="line">      &#125;);</span><br><span class="line">      httpCode = <span class="number">200</span>;</span><br><span class="line">      result = <span class="string">`http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/upload/<span class="subst">$&#123;fileName&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      httpCode = <span class="number">500</span>;</span><br><span class="line">      result = <span class="string">&quot;Image save failed! &quot;</span> + error.<span class="property">message</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="property">statusCode</span> = httpCode;</span><br><span class="line">    res.<span class="title function_">end</span>(result);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Get">Get</h3>
<p>获取图片,也很简单.根据文件名去上传路径找到改文件,正确返回即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="regexp">/\/upload\/[^\/]+/</span>.<span class="title function_">test</span>(req.<span class="property">url</span>) &amp;&amp; req.<span class="property">method</span>.<span class="title function_">toLowerCase</span>() === <span class="string">&quot;get&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> resFileName = req.<span class="property">url</span>.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>).<span class="title function_">pop</span>();</span><br><span class="line">  <span class="keyword">let</span> imagePath = path.<span class="title function_">join</span>(uploadFolder, resFileName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(imagePath)) &#123;</span><br><span class="line">    <span class="comment">// Content-type is very interesting part that guarantee that</span></span><br><span class="line">    <span class="comment">// Web browser will handle response in an appropriate manner.</span></span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: mime.<span class="title function_">lookup</span>(imagePath),</span><br><span class="line">      <span class="string">&quot;Content-Disposition&quot;</span>: <span class="string">&quot;inline;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    fs.<span class="title function_">createReadStream</span>(imagePath).<span class="title function_">pipe</span>(res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">404</span>;</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&quot;ERROR File does not exist&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例">示例</h3>
<p>通过<mark class="label primary">curl</mark>上传.<mark class="label primary">curl</mark>用法自行查阅</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220417011951482.png" alt="image-20220417011951482"></p>
<p>终端无法查看图片，在浏览器中打开/Markdown中插入即可</p>
<div class="note info"><p>贴几个<mark class="label primary">curl</mark>的参考文档</p>
<ul>
<li><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">阮一峰的网络日志. curl的用法指南</a></li>
<li><a href="https://catonmat.net/cookbooks/curl">catonamat.net. Curl CookBook</a></li>
<li><a href="https://curl.se/">curl.se</a></li>
</ul>
</div>
<h2 id="Typora自动上传">Typora自动上传</h2>
<p>图床搭建好了，比较大的缺点就是一次只能上传一张图片并且需要手动复制返回的连接。Typora提供了自动上传的功能，我们只需要编写一个小脚本来自动上传即可. 脚本没考虑出错的情况，局域网内一般也不会有啥错，需要错误处理的可以自己改下</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220417124706484.png" alt="image-20220417124706484"></p>
<h3 id="upload-image-sh"><a href="http://upload-image.sh">upload-image.sh</a></h3>
<mark class="label primary">"C:/Program Files/Git/bin/bash.exe" D:BlogpicBedupload-image.sh</mark>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">result=()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">upload</span></span>() &#123;</span><br><span class="line"><span class="comment"># 上传文件</span></span><br><span class="line">    t=$(curl -X POST -s -F <span class="string">&quot;file=@<span class="variable">$1</span>&quot;</span>  http://192.168.123.54:7070/upload)</span><br><span class="line">    result=(<span class="variable">$&#123;result[@]&#125;</span> <span class="string">&quot;<span class="variable">$&#123;t&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span> -gt 0 ]; <span class="keyword">do</span></span><br><span class="line">    upload <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="variable">$index</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 输出格式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Upload Success:&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;result[*]&#125;</span>; <span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="upload-image-ps1">upload-image.ps1</h3>
<mark class="label primary">"C:\Program Files\PowerShell\7\pwsh.exe" D:BlogpicBedupload-image.ps1</mark>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ipv4</span> = (<span class="built_in">Get-NetIPAddress</span> | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.AddressState <span class="operator">-eq</span> <span class="string">&quot;Preferred&quot;</span> <span class="operator">-and</span> <span class="variable">$_</span>.ValidLifetime <span class="operator">-lt</span> <span class="string">&quot;24:00:00&quot;</span> &#125;).IPAddress</span><br><span class="line"><span class="variable">$Port</span> = <span class="string">&#x27;7070&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publish-Image</span></span> &#123;</span><br><span class="line">  <span class="keyword">param</span> (</span><br><span class="line">    <span class="variable">$ImagePath</span></span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">Write-Output</span> (curl.exe <span class="literal">-X</span> POST <span class="literal">-s</span> <span class="operator">-F</span> (<span class="string">&#x27;&quot;file=@&#x27;</span> + <span class="variable">$ImagePath</span> + <span class="string">&#x27;&quot;&#x27;</span>) (<span class="string">&#x27;http://&#x27;</span> + <span class="variable">$ipv4</span> + <span class="string">&#x27;:&#x27;</span> + <span class="variable">$Port</span> + <span class="string">&#x27;/upload&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">&#x27;Upload Success:&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> <span class="operator">-lt</span> <span class="variable">$args</span>.Count; <span class="variable">$i</span>++) &#123;</span><br><span class="line">  <span class="built_in">Publish-Image</span> <span class="variable">$args</span>[<span class="variable">$i</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="验证">验证</h3>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/image-20220417124921514.png" alt="image-20220417124921514"></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://blog.csdn.net/bklydxz/article/details/116562345">CSDN.Net Typora 配置自定义图床 upload-image.sh</a></p>
]]></content>
      <categories>
        <category>nodeJs</category>
      </categories>
  </entry>
  <entry>
    <title>PowerShell 批量重命名</title>
    <url>/powerShell-rename-multiple-files/</url>
    <content><![CDATA[<h2 id="基础知识">基础知识</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 声明变量</span><br><span class="line"><span class="variable">$h</span> = <span class="string">&quot;Hello&quot;</span> </span><br><span class="line"><span class="variable">$w</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="variable">$h</span> + <span class="string">&quot; &quot;</span> + <span class="variable">$w</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$_</span> // 指向当前遍历到的值，可以理解为js中 Array.each((e,i,a)=&gt; e ) 的e</span><br></pre></td></tr></table></figure>
<div class="note primary"><p><mark class="label success">ls -filter *.EXTENSION | …</mark>搭配 System.String 提供的方法可以满足所有需求。对字符串使用 Get-Member 可以获取所有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello world&quot; | Get-Member</span><br></pre></td></tr></table></figure>
</div>
<span id="more"></span>
<h2 id="同名带序号">同名带序号</h2>
<h3 id="语法">语法</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | %&#123;Rename-Item <span class="variable">$_</span> -NewName (<span class="string">&quot;NEW-FILE-NAME-&#123;0&#125;.EXTENSION&quot;</span> -f <span class="variable">$nr</span>++)&#125;</span><br><span class="line"></span><br><span class="line">// 搭配 -filter 使用，只重命名特定后缀文件</span><br><span class="line"><span class="built_in">ls</span> -filter *.EXTENSION | %&#123;Rename-Item <span class="variable">$_</span> -NewName (<span class="string">&quot;NEW-FILE-NAME-&#123;0&#125;.EXTENSION&quot;</span> -f <span class="variable">$nr</span>++)&#125; </span><br></pre></td></tr></table></figure>
<h3 id="指令">指令</h3>
<ul>
<li>NEW-FILE-NAME：新名字</li>
<li>EXTENSION：文件拓展名</li>
</ul>
<h3 id="效果">效果</h3>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Snipaste_2021-11-12_01-03-07.png" alt=""></p>
<h2 id="部分剪切">部分剪切</h2>
<h3 id="语法-2">语法</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | Rename-Item -NewName &#123;<span class="variable">$_</span>.name.substring(0,<span class="variable">$_</span>.BaseName.length-N) + <span class="variable">$_</span>.Extension&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令-2">指令</h3>
<p>关键在<mark class="label primary">System.String.substring</mark>函数，第一个入参代表<strong>提取起点</strong>，第二个入参代表<strong>要提取的长度</strong>。包含起点，下标从0开始</p>
<h3 id="效果-2">效果</h3>
<p>这里不知道什么原因多遍历了一次，导致报错</p>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Snipaste_2021-11-12_01-30-18.png" alt=""></p>
<h2 id="部分替换">部分替换</h2>
<h3 id="语法-3">语法</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> | Rename-Item -NewName &#123;<span class="variable">$_</span>.name -replace <span class="string">&quot;OLD-FILE-NAME-PART&quot;</span>,<span class="string">&quot;NEW-FILE-NAME-PART&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指令-3">指令</h3>
<ul>
<li>OLD-FILE-NAME-PART：被替换的部分</li>
<li>NEW-FILE-NAME-PART：替换进去的部分，为空就变成了替换删除</li>
</ul>
<h3 id="效果-3">效果</h3>
<p><img data-src="https://kinsiy-blog-img.oss-ap-southeast-1.aliyuncs.com/img/Snipaste_2021-11-12_01-34-34.png" alt=""></p>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://www.windowscentral.com/how-rename-multiple-files-bulk-windows-10#rename-files-using-powershell">Windows Central. How to batch rename multiple files on Windows 10.</a></p>
<p>[2]<a href="https://4sysops.com/archives/strings-in-powershell-replace-compare-concatenate-split-substring/">4sysops. Strings in PowerShell - Replace, compare, concatenate, split, substring.</a></p>
<p>[3]<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/new-item?view=powershell-7.2">Microsoft. powershell</a></p>
]]></content>
      <categories>
        <category>windows</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>rename</tag>
      </tags>
  </entry>
  <entry>
    <title>快速 Diff 算法</title>
    <url>/quick-diff/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第十一章 - 快速 Diff 算法 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<span id="more"></span>
<h2 id="代码实现">代码实现</h2>
<p>在书中有算法实现的完整思路, 由浅入深,说的非常明白. 这里仅贴出最终的示例代码, 供重温用, 更为具体的讲解参见书籍原文.</p>
<p>不同于简单Diff算法和双端Diff算法, 快速Diff算法包含预处理步骤, 在对两列VNode进行Diff之前,先对他们进行<mark class="label danger">“全等”</mark>比较. <mark class="label danger">patchKeyedChildren</mark> 中 <mark class="label danger">2 ~ 36</mark> 行即为其预处理过程.</p>
<p>另一个导致其比简单与双端diff算法都快的原因,在于快速diff算法使用了最长递增子序列辅助完成DOM的移动操作</p>
<p><strong>最长递增子序列</strong>: 简单来说,给定一个数值序列,找到它的一个子序列,并且该子序列中的值是递增的,子序列中的元素在原序列中不一定连续</p>
<div class="note primary"><p>代码中<mark class="label info">patch, patchElement, patchChildren</mark>函数, 在书中第八章 - 挂载与更新中有详细的讲解, 代码已贴到 <a href="/simple-diff/#%E9%99%84%E5%BD%95">简单 Diff 算法#附录</a>中</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newChildren = n2.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span></span><br><span class="line">  <span class="comment">// 更新相同的前缀节点</span></span><br><span class="line">  <span class="comment">// 索引 j 指向新旧两组子节点的开头</span></span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldVNode = oldChildren[j]</span><br><span class="line">  <span class="keyword">let</span> newVNode = newChildren[j]</span><br><span class="line">  <span class="comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    j++</span><br><span class="line">    oldVNode = oldChildren[j]</span><br><span class="line">    newVNode = newChildren[j]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新相同的后缀节点</span></span><br><span class="line">  <span class="comment">// 索引 oldEnd 指向旧的一组子节点的最后一个节点</span></span><br><span class="line">  <span class="keyword">let</span> oldEnd = oldChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 索引 newEnd 指向新的一组子节点的最后一个节点</span></span><br><span class="line">  <span class="keyword">let</span> newEnd = newChildren.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  oldVNode = oldChildren[oldEnd]</span><br><span class="line">  newVNode = newChildren[newEnd]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line">  <span class="keyword">while</span> (oldVNode.<span class="property">key</span> === newVNode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">    oldEnd--</span><br><span class="line">    newEnd--</span><br><span class="line">    oldVNode = oldChildren[oldEnd]</span><br><span class="line">    newVNode = newChildren[newEnd]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足条件，则说明从 j -&gt; newEnd 之间的节点应作为新节点插入</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">    <span class="comment">// 锚点的索引</span></span><br><span class="line">    <span class="keyword">const</span> anchorIndex = newEnd + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 锚点元素</span></span><br><span class="line">    <span class="keyword">const</span> anchor = anchorIndex &lt; newChildren.<span class="property">length</span> ? newChildren[anchorIndex].<span class="property">el</span> : <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 采用 while 循环，调用 patch 函数逐个挂载新增的节点</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= newEnd) &#123;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, newChildren[j++], container, anchor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; newEnd &amp;&amp; j &lt;= oldEnd) &#123;</span><br><span class="line">    <span class="comment">// j -&gt; oldEnd 之间的节点应该被卸载</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= oldEnd) &#123;</span><br><span class="line">      <span class="title function_">unmount</span>(oldChildren[j++])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 source 数组</span></span><br><span class="line">    <span class="comment">// source数组将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引(用于计算最长递增子序列,辅助DOM移动)</span></span><br><span class="line">    <span class="keyword">const</span> count = newEnd - j + <span class="number">1</span>  <span class="comment">// 新的一组子节点中剩余未处理节点的数量</span></span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">new</span> <span class="title class_">Array</span>(count)</span><br><span class="line">    source.<span class="title function_">fill</span>(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> oldStart = j</span><br><span class="line">    <span class="keyword">const</span> newStart = j</span><br><span class="line">    <span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> keyIndex = &#123;&#125;	<span class="comment">// 索引表, 避免嵌套循环.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = newStart; i &lt;= newEnd; i++) &#123;</span><br><span class="line">      keyIndex[newChildren[i].<span class="property">key</span>] = i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> patched = <span class="number">0</span>	<span class="comment">// 已更新节点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = oldStart; i &lt;= oldEnd; i++) &#123;</span><br><span class="line">      oldVNode = oldChildren[i]</span><br><span class="line">      <span class="keyword">if</span> (patched &lt; count) &#123;</span><br><span class="line">        <span class="keyword">const</span> k = keyIndex[oldVNode.<span class="property">key</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">          newVNode = newChildren[k]</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">          patched++</span><br><span class="line">          source[k - newStart] = i</span><br><span class="line">          <span class="comment">// 判断是否需要移动</span></span><br><span class="line">          <span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">            moved = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pos = k</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 没找到</span></span><br><span class="line">          <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">      <span class="keyword">const</span> seq = <span class="title function_">lis</span>(source)	<span class="comment">// 计算最长递增子序列</span></span><br><span class="line">      <span class="comment">// s 指向最长递增子序列的最后一个值</span></span><br><span class="line">      <span class="keyword">let</span> s = seq.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> i = count - <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> (i; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source[i] === -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// 说明索引为 i 的节点是全新的节点，应该将其挂载</span></span><br><span class="line">          <span class="comment">// 该节点在新 children 中的真实位置索引</span></span><br><span class="line">          <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">          <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">          <span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line">          <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">          <span class="comment">// 锚点</span></span><br><span class="line">          <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">            ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">          <span class="comment">// 挂载</span></span><br><span class="line">          <span class="title function_">patch</span>(<span class="literal">null</span>, newVNode, container, anchor)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i !== seq[j]) &#123;</span><br><span class="line">          <span class="comment">// 说明该节点需要移动</span></span><br><span class="line">          <span class="comment">// 该节点在新的一组子节点中的真实位置索引</span></span><br><span class="line">          <span class="keyword">const</span> pos = i + newStart</span><br><span class="line">          <span class="keyword">const</span> newVNode = newChildren[pos]</span><br><span class="line">          <span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line">          <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">          <span class="comment">// 锚点</span></span><br><span class="line">          <span class="keyword">const</span> anchor = nextPos &lt; newChildren.<span class="property">length</span></span><br><span class="line">            ? newChildren[nextPos].<span class="property">el</span></span><br><span class="line">            : <span class="literal">null</span></span><br><span class="line">          <span class="comment">// 移动</span></span><br><span class="line">          <span class="title function_">insert</span>(newVNode.<span class="property">el</span>, container, anchor)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span></span><br><span class="line">          <span class="comment">// 并让 s 指向下一个位置</span></span><br><span class="line">          s--</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录">附录</h2>
<h3 id="计算递增最长子序列">计算递增最长子序列</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">lis</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = arr.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> i, j, u, v, c</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> arrI = arr[i]</span><br><span class="line">    <span class="keyword">if</span> (arrI !== <span class="number">0</span>) &#123;</span><br><span class="line">      j = result[result.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arrI) &#123;</span><br><span class="line">        p[i] = j</span><br><span class="line">        result.<span class="title function_">push</span>(i)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      u = <span class="number">0</span></span><br><span class="line">      v = result.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (u &lt; v) &#123;</span><br><span class="line">        c = ((u + v) / <span class="number">2</span>) | <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (arr[result[c]] &lt; arrI) &#123;</span><br><span class="line">          u = c + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          v = c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arrI &lt; arr[result[u]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          p[i] = result[u - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        result[u] = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  u = result.<span class="property">length</span></span><br><span class="line">  v = result[u - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">while</span> (u-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    result[u] = v</span><br><span class="line">    v = p[v]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>简单 Diff 算法</title>
    <url>/simple-diff/</url>
    <content><![CDATA[<div class="note primary"><p>文章依据<a href="https://book.douban.com/subject/35768338/">《Vue.js设计与实现》</a>第九章 - 简单Diff算法 摘录而来, 更为详细的内容参见书籍原文</p>
</div>
<span id="more"></span>
<h2 id="代码实现">代码实现</h2>
<p>在书中有算法实现的完整思路, 由浅入深,说的非常明白. 这里仅贴出最终的示例代码, 供重温用, 更为具体的讲解参见书籍原文.</p>
<div class="note primary"><p>代码中的<mark class="label info">patch, patchElement, patchChildren</mark>函数, 在书中第八章 - 挂载与更新中有详细的讲解, 代码已贴到附录中</p>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单 Diff 算法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patchKeyedChildren</span>(<span class="params">n1, n2, container</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> newChildren = n2.<span class="property">children</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 遍历新的 children</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> newVNode = newChildren[i]</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> find = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 遍历旧的 children</span></span><br><span class="line">    <span class="keyword">for</span> (j; j &lt; oldChildren.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldVNode = oldChildren[j]</span><br><span class="line">      <span class="comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span></span><br><span class="line">      <span class="keyword">if</span> (newVNode.<span class="property">key</span> === oldVNode.<span class="property">key</span>) &#123;</span><br><span class="line">        find = <span class="literal">true</span></span><br><span class="line">        <span class="title function_">patch</span>(oldVNode, newVNode, container)</span><br><span class="line">        <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">          <span class="comment">// 需要移动</span></span><br><span class="line">          <span class="keyword">const</span> prevVNode = newChildren[i - <span class="number">1</span>]</span><br><span class="line">          <span class="comment">// 如果 prevVNode  不存在, 则说明当前 newVNode 是第一个节点, 它不需要移动</span></span><br><span class="line">          <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">            <span class="keyword">const</span> anchor = prevVNode.<span class="property">el</span>.<span class="property">nextSibling</span></span><br><span class="line">            <span class="comment">// 移动到 prevVNode 对应的真实DOM的后面</span></span><br><span class="line">            <span class="title function_">insert</span>(newVNode.<span class="property">el</span>, container, anchor)	<span class="comment">// insertBefore</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 更新 lastIndex</span></span><br><span class="line">          lastIndex = j</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 这里需要 break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前 newVNode 没有在旧的一组节点中找到可复用的节点</span></span><br><span class="line">    <span class="comment">// 也就是说, 当前newVNode 是新增节点, 需要挂载</span></span><br><span class="line">    <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">      <span class="comment">// 为了将节点挂载到正确位置,我们需要先获取锚点元素</span></span><br><span class="line">      <span class="comment">// 首先获取当前 newVNode 的前一个 vnode 节点</span></span><br><span class="line">      <span class="keyword">const</span> prevVNode = newChildren[i - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">let</span> anchor = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (prevVNode) &#123;</span><br><span class="line">        <span class="comment">// 如果有前一个 vnode 节点, 则使用它的下一个兄弟节点作为锚点元素</span></span><br><span class="line">        anchor = prevVNode.<span class="property">el</span>.<span class="property">nextSibling</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有前一个 vnode 节点, 说明即将挂载的新节点是第一个节点</span></span><br><span class="line">        <span class="comment">// 使用容器元素的 firstChild 作为锚点</span></span><br><span class="line">        anchor = container.<span class="property">firstChild</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">patch</span>(<span class="literal">null</span>, newVNode, container, anchor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历旧的节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldChildren.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVNode = oldChildren[i]</span><br><span class="line">    <span class="comment">// 拿着旧 VNode 去新 children 中寻找相同的节点</span></span><br><span class="line">    <span class="keyword">const</span> has = newChildren.<span class="title function_">find</span>(</span><br><span class="line">      <span class="function"><span class="params">vnode</span> =&gt;</span> vnode.<span class="property">key</span> === oldVNode.<span class="property">key</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">      <span class="comment">// 如果没有找到相同的节点，则移除</span></span><br><span class="line">      <span class="title function_">unmount</span>(oldVNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附录">附录</h2>
<div class="note warning"><p>代码中有很多方法具体实现并未贴出, 根据函数名很容易看出函数的作用, 这里主要做理解用, 具体实现参考书籍原文或<a href="https://github.com/HcySunYang/code-for-vue-3-book/blob/master/course5-%E6%B8%B2%E6%9F%93%E5%99%A8/code-9.6.html">Github</a></p>
</div>
<h3 id="patch">patch</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span>(<span class="params">n1, n2, container, anchor</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n1 &amp;&amp; n1.<span class="property">type</span> !== n2.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="title function_">unmount</span>(n1)</span><br><span class="line">    n1 = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; type &#125; = n2</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="title function_">mountElement</span>(n2, container, anchor)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patchElement</span>(n1, n2)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="title class_">Text</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      <span class="keyword">const</span> el = n2.<span class="property">el</span> = <span class="title function_">createText</span>(n2.<span class="property">children</span>)</span><br><span class="line">      <span class="title function_">insert</span>(el, container)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">      <span class="keyword">if</span> (n2.<span class="property">children</span> !== n1.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="title function_">setText</span>(el, n2.<span class="property">children</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="title class_">Fragment</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!n1) &#123;</span><br><span class="line">      n2.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> <span class="title function_">patch</span>(<span class="literal">null</span>, c, container))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">patchChildren</span>(n1, n2, container)	<span class="comment">// go to Diff</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchElement">patchElement</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchElement</span>(<span class="params">n1, n2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line">  <span class="keyword">const</span> oldProps = n1.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> newProps = n2.<span class="property">props</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">      <span class="title function_">patchProps</span>(el, key, oldProps[key], newProps[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">      <span class="title function_">patchProps</span>(el, key, oldProps[key], <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">patchChildren</span>(n1, n2, el)	<span class="comment">// go to Diff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="patchChildren">patchChildren</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">patchChildren</span>(<span class="params">n1, n2, container</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> n2.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(n1.<span class="property">children</span>)) &#123;</span><br><span class="line">      n1.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">c</span>) =&gt;</span> <span class="title function_">unmount</span>(c))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setElementText</span>(container, n2.<span class="property">children</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(n2.<span class="property">children</span>)) &#123;</span><br><span class="line">    <span class="title function_">patchKeyedChildren</span>(n1, n2, container)	<span class="comment">// Diff </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(n1.<span class="property">children</span>)) &#123;</span><br><span class="line">      n1.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">c</span> =&gt;</span> <span class="title function_">unmount</span>(c))</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> n1.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">setElementText</span>(container, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考">参考</h2>
<p>[1]<a href="https://book.douban.com/subject/35768338/">霍春阳. Vue.js设计与实现</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue.js设计与实现</category>
      </categories>
      <tags>
        <tag>diff</tag>
      </tags>
  </entry>
</search>
